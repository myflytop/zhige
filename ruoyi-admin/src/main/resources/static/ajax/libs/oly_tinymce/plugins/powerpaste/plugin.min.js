/*!
 * Tiny PowerPaste plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 6.1.0-570
 */

!function() {
    "use strict";
    const e = e=>parseInt(e, 10)
      , t = (e,t)=>{
        const n = e - t;
        return 0 === n ? 0 : n > 0 ? 1 : -1
    }
      , n = (e,t,n)=>({
        major: e,
        minor: t,
        patch: n
    })
      , r = t=>{
        const r = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(t);
        return r ? n(e(r[1]), e(r[2]), e(r[3])) : n(0, 0, 0)
    }
      , o = e=>t=>(e=>{
        const t = typeof e;
        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && ((e,t,n)=>{
            var r, o;
            return o = e,
            !!t.prototype.isPrototypeOf(o) || (null === (r = e.constructor) || void 0 === r ? void 0 : r.name) === t.name
        }
        )(e, String) ? "string" : t
    }
    )(t) === e
      , s = e=>t=>typeof t === e
      , a = o("string")
      , i = o("object")
      , l = o("array")
      , c = s("boolean")
      , m = (void 0,
    e=>undefined === e);
    const d = e=>null == e
      , u = e=>!d(e)
      , p = s("function")
      , g = s("number")
      , f = ()=>{}
      , h = (e,t)=>(...n)=>e(t.apply(null, n))
      , v = e=>()=>e
      , y = e=>e
      , b = (e,t)=>e === t;
    function x(e, ...t) {
        return (...n)=>{
            const r = t.concat(n);
            return e.apply(null, r)
        }
    }
    const w = e=>()=>{
        throw new Error(e)
    }
      , T = e=>e()
      , I = v(!1)
      , S = v(!0);
    class O {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new O(!0,e)
        }
        static none() {
            return O.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? O.some(e(this.value)) : O.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : O.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : O.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return u(e) ? O.some(e) : O.none()
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    O.singletonNone = new O(!1);
    const E = Array.prototype.slice
      , N = Array.prototype.indexOf
      , k = Array.prototype.push
      , D = (e,t)=>((e,t)=>N.call(e, t))(e, t) > -1
      , A = (e,t)=>{
        for (let n = 0, r = e.length; n < r; n++)
            if (t(e[n], n))
                return !0;
        return !1
    }
      , C = (e,t)=>{
        const n = e.length
          , r = new Array(n);
        for (let o = 0; o < n; o++) {
            const n = e[o];
            r[o] = t(n, o)
        }
        return r
    }
      , _ = (e,t)=>{
        for (let n = 0, r = e.length; n < r; n++)
            t(e[n], n)
    }
      , L = (e,t)=>{
        const n = []
          , r = [];
        for (let o = 0, s = e.length; o < s; o++) {
            const s = e[o];
            (t(s, o) ? n : r).push(s)
        }
        return {
            pass: n,
            fail: r
        }
    }
      , P = (e,t)=>{
        const n = [];
        for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r];
            t(o, r) && n.push(o)
        }
        return n
    }
      , R = (e,t,n)=>(_(e, ((e,r)=>{
        n = t(n, e, r)
    }
    )),
    n)
      , M = (e,t)=>((e,t,n)=>{
        for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r];
            if (t(o, r))
                return O.some(o);
            if (n(o, r))
                break
        }
        return O.none()
    }
    )(e, t, I)
      , F = (e,t)=>{
        for (let n = 0, r = e.length; n < r; n++)
            if (t(e[n], n))
                return O.some(n);
        return O.none()
    }
      , j = e=>{
        const t = [];
        for (let n = 0, r = e.length; n < r; ++n) {
            if (!l(e[n]))
                throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
            k.apply(t, e[n])
        }
        return t
    }
      , U = (e,t)=>j(C(e, t))
      , H = (e,t)=>{
        for (let n = 0, r = e.length; n < r; ++n)
            if (!0 !== t(e[n], n))
                return !1;
        return !0
    }
      , z = (e,t)=>{
        const n = {};
        for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r];
            n[String(o)] = t(o, r)
        }
        return n
    }
      , W = e=>((e,t)=>0 < e.length ? O.some(e[0]) : O.none())(e)
      , B = (e,t)=>{
        for (let n = 0; n < e.length; n++) {
            const r = t(e[n], n);
            if (r.isSome())
                return r
        }
        return O.none()
    }
      , $ = e=>t=>t.options.get(e)
      , G = $("paste_as_text")
      , V = $("paste_merge_formats")
      , q = $("paste_tab_spaces")
      , K = $("smart_paste")
      , Y = $("cache_suffix")
      , X = $("automatic_uploads")
      , Z = $("indent_use_margin")
      , J = $("powerpaste_block_drop")
      , Q = $("powerpaste_keep_unsupported_src")
      , ee = $("powerpaste_allow_local_images")
      , te = $("powerpaste_word_import")
      , ne = $("powerpaste_googledocs_import")
      , re = $("powerpaste_html_import")
      , oe = $("powerpaste_clean_filtered_inline_elements")
      , se = $("link_default_protocol")
      , ae = e=>{
        var t;
        return tinymce.explode(null !== (t = e.options.get("images_file_types")) && void 0 !== t ? t : "")
    }
      , ie = e=>{
        let t = e;
        return {
            get: ()=>t,
            set: e=>{
                t = e
            }
        }
    }
      , le = ()=>{
        const e = (e=>{
            const t = ie(O.none())
              , n = ()=>t.get().each(e);
            return {
                clear: ()=>{
                    n(),
                    t.set(O.none())
                }
                ,
                isSet: ()=>t.get().isSome(),
                get: ()=>t.get(),
                set: e=>{
                    n(),
                    t.set(O.some(e))
                }
            }
        }
        )(f);
        return {
            ...e,
            on: t=>e.get().each(t)
        }
    }
      , ce = (e,t,n)=>"" === t || e.length >= t.length && e.substr(n, n + t.length) === t
      , me = (e,t)=>ue(e, t) ? ((e,t)=>e.substring(t))(e, t.length) : e
      , de = (e,t)=>-1 !== e.indexOf(t)
      , ue = (e,t)=>ce(e, t, 0)
      , pe = (e,t)=>ce(e, t, e.length - t.length)
      , ge = (fe = /^\s+|\s+$/g,
    e=>e.replace(fe, ""));
    var fe;
    const he = (e,t)=>{
        const n = t=>e(t) ? O.from(t.dom.nodeValue) : O.none();
        return {
            get: r=>{
                if (!e(r))
                    throw new Error("Can only get " + t + " value of a " + t + " node");
                return n(r).getOr("")
            }
            ,
            getOption: n,
            set: (n,r)=>{
                if (!e(n))
                    throw new Error("Can only set raw " + t + " value of a " + t + " node");
                n.dom.nodeValue = r
            }
        }
    }
      , ve = "undefined" != typeof window ? window : Function("return this;")()
      , ye = (e,t)=>(void 0 !== e[t] && null !== e[t] || (e[t] = {}),
    e[t])
      , be = (e,t)=>((e,t)=>{
        let n = void 0 !== t ? t : ve;
        for (let t = 0; t < e.length; ++t)
            n = ye(n, e[t]);
        return n
    }
    )(e.split("."), t)
      , xe = e=>e.dom.nodeName.toLowerCase()
      , we = e=>e.dom.nodeType
      , Te = e=>t=>we(t) === e
      , Ie = e=>8 === we(e) || "#comment" === xe(e)
      , Se = Te(1)
      , Oe = Te(3)
      , Ee = Te(9)
      , Ne = Te(11)
      , ke = e=>t=>Se(t) && xe(t) === e
      , De = he(Ie, "comment")
      , Ae = e=>De.get(e)
      , Ce = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , _e = {
        fromHtml: (e,t)=>{
            const n = (t || document).createElement("div");
            if (n.innerHTML = e,
            !n.hasChildNodes() || n.childNodes.length > 1) {
                const t = "HTML does not have a single root node";
                throw console.error(t, e),
                new Error(t)
            }
            return Ce(n.childNodes[0])
        }
        ,
        fromTag: (e,t)=>{
            const n = (t || document).createElement(e);
            return Ce(n)
        }
        ,
        fromText: (e,t)=>{
            const n = (t || document).createTextNode(e);
            return Ce(n)
        }
        ,
        fromDom: Ce,
        fromPoint: (e,t,n)=>O.from(e.dom.elementFromPoint(t, n)).map(Ce)
    }
      , Le = e=>{
        let t, n = !1;
        return (...r)=>(n || (n = !0,
        t = e.apply(null, r)),
        t)
    }
      , Pe = ()=>Re(0, 0)
      , Re = (e,t)=>({
        major: e,
        minor: t
    })
      , Me = {
        nu: Re,
        detect: (e,t)=>{
            const n = String(t).toLowerCase();
            return 0 === e.length ? Pe() : ((e,t)=>{
                const n = ((e,t)=>{
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n];
                        if (r.test(t))
                            return r
                    }
                }
                )(e, t);
                if (!n)
                    return {
                        major: 0,
                        minor: 0
                    };
                const r = e=>Number(t.replace(n, "$" + e));
                return Re(r(1), r(2))
            }
            )(e, n)
        }
        ,
        unknown: Pe
    }
      , Fe = (e,t)=>{
        const n = String(t).toLowerCase();
        return M(e, (e=>e.search(n)))
    }
      , je = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/
      , Ue = e=>t=>de(t, e)
      , He = [{
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: e=>de(e, "edge/") && de(e, "chrome") && de(e, "safari") && de(e, "applewebkit")
    }, {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, je],
        search: e=>de(e, "chrome") && !de(e, "chromeframe")
    }, {
        name: "IE",
        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
        search: e=>de(e, "msie") || de(e, "trident")
    }, {
        name: "Opera",
        versionRegexes: [je, /.*?opera\/([0-9]+)\.([0-9]+).*/],
        search: Ue("opera")
    }, {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: Ue("firefox")
    }, {
        name: "Safari",
        versionRegexes: [je, /.*?cpu os ([0-9]+)_([0-9]+).*/],
        search: e=>(de(e, "safari") || de(e, "mobile/")) && de(e, "applewebkit")
    }]
      , ze = [{
        name: "Windows",
        search: Ue("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "iOS",
        search: e=>de(e, "iphone") || de(e, "ipad"),
        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
    }, {
        name: "Android",
        search: Ue("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "macOS",
        search: Ue("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    }, {
        name: "Linux",
        search: Ue("linux"),
        versionRegexes: []
    }, {
        name: "Solaris",
        search: Ue("sunos"),
        versionRegexes: []
    }, {
        name: "FreeBSD",
        search: Ue("freebsd"),
        versionRegexes: []
    }, {
        name: "ChromeOS",
        search: Ue("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }]
      , We = {
        browsers: v(He),
        oses: v(ze)
    }
      , Be = "Edge"
      , $e = "Chromium"
      , Ge = "Opera"
      , Ve = "Firefox"
      , qe = "Safari"
      , Ke = e=>{
        const t = e.current
          , n = e.version
          , r = e=>()=>t === e;
        return {
            current: t,
            version: n,
            isEdge: r(Be),
            isChromium: r($e),
            isIE: r("IE"),
            isOpera: r(Ge),
            isFirefox: r(Ve),
            isSafari: r(qe)
        }
    }
      , Ye = ()=>Ke({
        current: void 0,
        version: Me.unknown()
    })
      , Xe = Ke
      , Ze = (v(Be),
    v($e),
    v("IE"),
    v(Ge),
    v(Ve),
    v(qe),
    "Windows")
      , Je = "Android"
      , Qe = "Linux"
      , et = "macOS"
      , tt = "Solaris"
      , nt = "FreeBSD"
      , rt = "ChromeOS"
      , ot = e=>{
        const t = e.current
          , n = e.version
          , r = e=>()=>t === e;
        return {
            current: t,
            version: n,
            isWindows: r(Ze),
            isiOS: r("iOS"),
            isAndroid: r(Je),
            isMacOS: r(et),
            isLinux: r(Qe),
            isSolaris: r(tt),
            isFreeBSD: r(nt),
            isChromeOS: r(rt)
        }
    }
      , st = ()=>ot({
        current: void 0,
        version: Me.unknown()
    })
      , at = ot
      , it = (v(Ze),
    v("iOS"),
    v(Je),
    v(Qe),
    v(et),
    v(tt),
    v(nt),
    v(rt),
    e=>window.matchMedia(e).matches);
    let lt = Le((()=>((e,t,n)=>{
        const r = We.browsers()
          , o = We.oses()
          , s = t.bind((e=>((e,t)=>B(t.brands, (t=>{
            const n = t.brand.toLowerCase();
            return M(e, (e=>{
                var t;
                return n === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
            }
            )).map((e=>({
                current: e.name,
                version: Me.nu(parseInt(t.version, 10), 0)
            })))
        }
        )))(r, e))).orThunk((()=>((e,t)=>Fe(e, t).map((e=>{
            const n = Me.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: n
            }
        }
        )))(r, e))).fold(Ye, Xe)
          , a = ((e,t)=>Fe(e, t).map((e=>{
            const n = Me.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: n
            }
        }
        )))(o, e).fold(st, at)
          , i = ((e,t,n,r)=>{
            const o = e.isiOS() && !0 === /ipad/i.test(n)
              , s = e.isiOS() && !o
              , a = e.isiOS() || e.isAndroid()
              , i = a || r("(pointer:coarse)")
              , l = o || !s && a && r("(min-device-width:768px)")
              , c = s || a && !l
              , m = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n)
              , d = !c && !l && !m;
            return {
                isiPad: v(o),
                isiPhone: v(s),
                isTablet: v(l),
                isPhone: v(c),
                isTouch: v(i),
                isAndroid: e.isAndroid,
                isiOS: e.isiOS,
                isWebView: v(m),
                isDesktop: v(d)
            }
        }
        )(a, s, e, n);
        return {
            browser: s,
            os: a,
            deviceType: i
        }
    }
    )(navigator.userAgent, O.from(navigator.userAgentData), it)));
    const ct = ()=>lt()
      , mt = ct()
      , dt = mt.deviceType.isiOS() || mt.deviceType.isAndroid()
      , ut = v({
        isSupported: !1,
        cleanDocument: ()=>Promise.reject("not supported")
    });
    var pt = dt ? ut : (e,t,n)=>{
        const r = t + "/wordimport.js" + (e=>O.from(e).filter((e=>0 !== e.length)).map((e=>(-1 === e.indexOf("?") ? "?" : "") + e)).getOr(""))(n || "v=9.1.0")
          , o = e.loadScript("ephox.wimp", r);
        return o.catch((e=>{
            console.error("Unable to load word import: ", e)
        }
        )),
        {
            isSupported: !0,
            cleanDocument: (e,t,n)=>o.then((r=>r.cleanDocument(e, t, n.cleanFilteredInlineElements)))
        }
    }
    ;
    const gt = e=>{
        let t = [];
        return {
            bind: e=>{
                if (void 0 === e)
                    throw new Error("Event bind error: undefined handler");
                t.push(e)
            }
            ,
            unbind: e=>{
                t = P(t, (t=>t !== e))
            }
            ,
            trigger: (...n)=>{
                const r = {};
                _(e, ((e,t)=>{
                    r[e] = n[t]
                }
                )),
                _(t, (e=>{
                    e(r)
                }
                ))
            }
        }
    }
      , ft = Object.keys
      , ht = Object.hasOwnProperty
      , vt = (e,t)=>{
        const n = ft(e);
        for (let r = 0, o = n.length; r < o; r++) {
            const o = n[r];
            t(e[o], o)
        }
    }
      , yt = (e,t)=>bt(e, ((e,n)=>({
        k: n,
        v: t(e, n)
    })))
      , bt = (e,t)=>{
        const n = {};
        return vt(e, ((e,r)=>{
            const o = t(e, r);
            n[o.k] = o.v
        }
        )),
        n
    }
      , xt = (e,t)=>{
        const n = {};
        return ((e,t,n,r)=>{
            vt(e, ((e,o)=>{
                (t(e, o) ? n : r)(e, o)
            }
            ))
        }
        )(e, t, (e=>(t,n)=>{
            e[n] = t
        }
        )(n), f),
        n
    }
      , wt = e=>ft(e).length
      , Tt = (e,t)=>ht.call(e, t)
      , It = e=>{
        const t = yt(e, (e=>({
            bind: e.bind,
            unbind: e.unbind
        })))
          , n = yt(e, (e=>e.trigger));
        return {
            registry: t,
            trigger: n
        }
    }
      , St = (e,t)=>{
        const n = e.dom;
        if (1 !== n.nodeType)
            return !1;
        {
            const e = n;
            if (void 0 !== e.matches)
                return e.matches(t);
            if (void 0 !== e.msMatchesSelector)
                return e.msMatchesSelector(t);
            if (void 0 !== e.webkitMatchesSelector)
                return e.webkitMatchesSelector(t);
            if (void 0 !== e.mozMatchesSelector)
                return e.mozMatchesSelector(t);
            throw new Error("Browser lacks native selectors")
        }
    }
      , Ot = e=>1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount
      , Et = (e,t)=>{
        const n = void 0 === t ? document : t.dom;
        return Ot(n) ? [] : C(n.querySelectorAll(e), _e.fromDom)
    }
      , Nt = (e,t)=>e.dom === t.dom
      , kt = St
      , Dt = (e,t,n)=>{
        const r = e.document.createRange();
        var o;
        return o = r,
        t.fold((e=>{
            o.setStartBefore(e.dom)
        }
        ), ((e,t)=>{
            o.setStart(e.dom, t)
        }
        ), (e=>{
            o.setStartAfter(e.dom)
        }
        )),
        ((e,t)=>{
            t.fold((t=>{
                e.setEndBefore(t.dom)
            }
            ), ((t,n)=>{
                e.setEnd(t.dom, n)
            }
            ), (t=>{
                e.setEndAfter(t.dom)
            }
            ))
        }
        )(r, n),
        r
    }
      , At = (e,t,n,r,o)=>{
        const s = e.document.createRange();
        return s.setStart(t.dom, n),
        s.setEnd(r.dom, o),
        s
    }
      , Ct = e=>{
        if (!l(e))
            throw new Error("cases must be an array");
        if (0 === e.length)
            throw new Error("there must be at least one case");
        const t = []
          , n = {};
        return _(e, ((r,o)=>{
            const s = ft(r);
            if (1 !== s.length)
                throw new Error("one and only one name per case");
            const a = s[0]
              , i = r[a];
            if (void 0 !== n[a])
                throw new Error("duplicate key detected:" + a);
            if ("cata" === a)
                throw new Error("cannot have a case named cata (sorry)");
            if (!l(i))
                throw new Error("case arguments must be an array");
            t.push(a),
            n[a] = (...n)=>{
                const r = n.length;
                if (r !== i.length)
                    throw new Error("Wrong number of arguments to case " + a + ". Expected " + i.length + " (" + i + "), got " + r);
                return {
                    fold: (...t)=>{
                        if (t.length !== e.length)
                            throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                        return t[o].apply(null, n)
                    }
                    ,
                    match: e=>{
                        const r = ft(e);
                        if (t.length !== r.length)
                            throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + r.join(","));
                        if (!H(t, (e=>D(r, e))))
                            throw new Error("Not all branches were specified when using match. Specified: " + r.join(", ") + "\nRequired: " + t.join(", "));
                        return e[a].apply(null, n)
                    }
                    ,
                    log: e=>{
                        console.log(e, {
                            constructors: t,
                            constructor: a,
                            params: n
                        })
                    }
                }
            }
        }
        )),
        n
    }
      , _t = Ct([{
        ltr: ["start", "soffset", "finish", "foffset"]
    }, {
        rtl: ["start", "soffset", "finish", "foffset"]
    }])
      , Lt = (e,t,n)=>t(_e.fromDom(n.startContainer), n.startOffset, _e.fromDom(n.endContainer), n.endOffset);
    _t.ltr,
    _t.rtl;
    const Pt = (e,t,n,r)=>({
        start: e,
        soffset: t,
        finish: n,
        foffset: r
    })
      , Rt = e=>_e.fromDom(e.dom.ownerDocument)
      , Mt = e=>Ee(e) ? e : Rt(e)
      , Ft = e=>_e.fromDom(Mt(e).dom.defaultView)
      , jt = e=>O.from(e.dom.parentNode).map(_e.fromDom)
      , Ut = e=>O.from(e.dom.previousSibling).map(_e.fromDom)
      , Ht = e=>O.from(e.dom.nextSibling).map(_e.fromDom)
      , zt = e=>(e=>{
        const t = E.call(e, 0);
        return t.reverse(),
        t
    }
    )(((e,t)=>{
        const n = []
          , r = e=>(n.push(e),
        t(e));
        let o = t(e);
        do {
            o = o.bind(r)
        } while (o.isSome());
        return n
    }
    )(e, Ut))
      , Wt = e=>C(e.dom.childNodes, _e.fromDom)
      , Bt = p(Element.prototype.attachShadow) && p(Node.prototype.getRootNode)
      , $t = v(Bt)
      , Gt = Bt ? e=>_e.fromDom(e.dom.getRootNode()) : Mt
      , Vt = e=>_e.fromDom(e.dom.host)
      , qt = e=>{
        const t = Oe(e) ? e.dom.parentNode : e.dom;
        if (null == t || null === t.ownerDocument)
            return !1;
        const n = t.ownerDocument;
        return (e=>{
            const t = Gt(e);
            return Ne(n = t) && u(n.dom.host) ? O.some(t) : O.none();
            var n
        }
        )(_e.fromDom(t)).fold((()=>n.body.contains(t)), (r = qt,
        o = Vt,
        e=>r(o(e))));
        var r, o
    }
      , Kt = (e,t)=>{
        let n = [];
        return _(Wt(e), (e=>{
            t(e) && (n = n.concat([e])),
            n = n.concat(Kt(e, t))
        }
        )),
        n
    }
      , Yt = (e,t)=>Et(t, e)
      , Xt = Ct([{
        before: ["element"]
    }, {
        on: ["element", "offset"]
    }, {
        after: ["element"]
    }])
      , Zt = {
        before: Xt.before,
        on: Xt.on,
        after: Xt.after,
        cata: (e,t,n,r)=>e.fold(t, n, r),
        getStart: e=>e.fold(y, y, y)
    }
      , Jt = Ct([{
        domRange: ["rng"]
    }, {
        relative: ["startSitu", "finishSitu"]
    }, {
        exact: ["start", "soffset", "finish", "foffset"]
    }])
      , Qt = {
        domRange: Jt.domRange,
        relative: Jt.relative,
        exact: Jt.exact,
        exactFromRange: e=>Jt.exact(e.start, e.soffset, e.finish, e.foffset),
        getWin: e=>{
            const t = (e=>e.match({
                domRange: e=>_e.fromDom(e.startContainer),
                relative: (e,t)=>Zt.getStart(e),
                exact: (e,t,n,r)=>e
            }))(e);
            return Ft(t)
        }
        ,
        range: Pt
    }
      , en = (e,t)=>{
        const n = xe(e);
        return "input" === n ? Zt.after(e) : D(["br", "img"], n) ? 0 === t ? Zt.before(e) : Zt.after(e) : Zt.on(e, t)
    }
      , tn = (e,t,n,r)=>{
        const o = Rt(e).dom.createRange();
        return o.setStart(e.dom, t),
        o.setEnd(n.dom, r),
        o
    }
      , nn = e=>O.from(e.getSelection())
      , rn = (e,t,n,r,o)=>{
        ((e,t)=>{
            nn(e).each((e=>{
                e.removeAllRanges(),
                e.addRange(t)
            }
            ))
        }
        )(e, At(e, t, n, r, o))
    }
      , on = (e,t,n,r,o)=>{
        const s = ((e,t,n,r)=>{
            const o = en(e, t)
              , s = en(n, r);
            return Qt.relative(o, s)
        }
        )(t, n, r, o);
        ((e,t)=>{
            ((e,t)=>{
                const n = ((e,t)=>t.match({
                    domRange: e=>({
                        ltr: v(e),
                        rtl: O.none
                    }),
                    relative: (t,n)=>({
                        ltr: Le((()=>Dt(e, t, n))),
                        rtl: Le((()=>O.some(Dt(e, n, t))))
                    }),
                    exact: (t,n,r,o)=>({
                        ltr: Le((()=>At(e, t, n, r, o))),
                        rtl: Le((()=>O.some(At(e, r, o, t, n))))
                    })
                }))(e, t);
                return ((e,t)=>{
                    const n = t.ltr();
                    return n.collapsed ? t.rtl().filter((e=>!1 === e.collapsed)).map((e=>_t.rtl(_e.fromDom(e.endContainer), e.endOffset, _e.fromDom(e.startContainer), e.startOffset))).getOrThunk((()=>Lt(0, _t.ltr, n))) : Lt(0, _t.ltr, n)
                }
                )(0, n)
            }
            )(e, t).match({
                ltr: (t,n,r,o)=>{
                    rn(e, t, n, r, o)
                }
                ,
                rtl: (t,n,r,o)=>{
                    nn(e).each((s=>{
                        if (s.setBaseAndExtent)
                            s.setBaseAndExtent(t.dom, n, r.dom, o);
                        else if (s.extend)
                            try {
                                ((e,t,n,r,o,s)=>{
                                    t.collapse(n.dom, r),
                                    t.extend(o.dom, s)
                                }
                                )(0, s, t, n, r, o)
                            } catch (s) {
                                rn(e, r, o, t, n)
                            }
                        else
                            rn(e, r, o, t, n)
                    }
                    ))
                }
            })
        }
        )(e, s)
    }
      , sn = e=>{
        if (e.rangeCount > 0) {
            const t = e.getRangeAt(0)
              , n = e.getRangeAt(e.rangeCount - 1);
            return O.some(Pt(_e.fromDom(t.startContainer), t.startOffset, _e.fromDom(n.endContainer), n.endOffset))
        }
        return O.none()
    }
      , an = e=>{
        if (null === e.anchorNode || null === e.focusNode)
            return sn(e);
        {
            const t = _e.fromDom(e.anchorNode)
              , n = _e.fromDom(e.focusNode);
            return ((e,t,n,r)=>{
                const o = tn(e, t, n, r)
                  , s = Nt(e, n) && t === r;
                return o.collapsed && !s
            }
            )(t, e.anchorOffset, n, e.focusOffset) ? O.some(Pt(t, e.anchorOffset, n, e.focusOffset)) : sn(e)
        }
    }
      , ln = e=>nn(e).filter((e=>e.rangeCount > 0)).bind(an)
      , cn = (e,t)=>{
        jt(e).each((n=>{
            n.dom.insertBefore(t.dom, e.dom)
        }
        ))
    }
      , mn = (e,t)=>{
        Ht(e).fold((()=>{
            jt(e).each((e=>{
                un(e, t)
            }
            ))
        }
        ), (e=>{
            cn(e, t)
        }
        ))
    }
      , dn = (e,t)=>{
        (e=>((e,t)=>{
            const n = e.dom.childNodes;
            return O.from(n[0]).map(_e.fromDom)
        }
        )(e))(e).fold((()=>{
            un(e, t)
        }
        ), (n=>{
            e.dom.insertBefore(t.dom, n.dom)
        }
        ))
    }
      , un = (e,t)=>{
        e.dom.appendChild(t.dom)
    }
      , pn = (e,t)=>{
        cn(e, t),
        un(t, e)
    }
      , gn = (e,t)=>{
        _(t, ((n,r)=>{
            const o = 0 === r ? e : t[r - 1];
            mn(o, n)
        }
        ))
    }
      , fn = (e,t)=>{
        _(t, (t=>{
            un(e, t)
        }
        ))
    }
      , hn = e=>{
        e.dom.textContent = "",
        _(Wt(e), (e=>{
            vn(e)
        }
        ))
    }
      , vn = e=>{
        const t = e.dom;
        null !== t.parentNode && t.parentNode.removeChild(t)
    }
      , yn = e=>{
        const t = Wt(e);
        t.length > 0 && gn(e, t),
        vn(e)
    }
      , bn = (e,t,n,r)=>{
        const o = Nt(e, n) && t === r;
        return {
            startContainer: v(e),
            startOffset: v(t),
            endContainer: v(n),
            endOffset: v(r),
            collapsed: v(o)
        }
    }
    ;
    let xn = 0;
    const wn = e=>{
        const t = (new Date).getTime()
          , n = Math.floor(1e9 * Math.random());
        return xn++,
        e + "_" + n + xn + String(t)
    }
      , Tn = (e,t,n)=>{
        if (!(a(n) || c(n) || g(n)))
            throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e),
            new Error("Attribute value was not simple");
        e.setAttribute(t, n + "")
    }
      , In = (e,t,n)=>{
        Tn(e.dom, t, n)
    }
      , Sn = (e,t)=>{
        const n = e.dom;
        vt(t, ((e,t)=>{
            Tn(n, t, e)
        }
        ))
    }
      , On = (e,t)=>{
        const n = e.dom.getAttribute(t);
        return null === n ? void 0 : n
    }
      , En = (e,t)=>O.from(On(e, t))
      , Nn = (e,t)=>{
        const n = e.dom;
        return !(!n || !n.hasAttribute) && n.hasAttribute(t)
    }
      , kn = (e,t)=>{
        e.dom.removeAttribute(t)
    }
      , Dn = (e,t)=>{
        const n = On(e, t);
        return void 0 === n || "" === n ? [] : n.split(" ")
    }
      , An = e=>void 0 !== e.dom.classList
      , Cn = e=>Dn(e, "class")
      , _n = (e,t)=>{
        An(e) ? e.dom.classList.add(t) : ((e,t)=>{
            ((e,t,n)=>{
                const r = Dn(e, t).concat([n]);
                In(e, t, r.join(" "))
            }
            )(e, "class", t)
        }
        )(e, t)
    }
      , Ln = (e,t)=>{
        An(e) ? e.dom.classList.remove(t) : ((e,t)=>{
            ((e,t,n)=>{
                const r = P(Dn(e, t), (e=>e !== n));
                r.length > 0 ? In(e, t, r.join(" ")) : kn(e, t)
            }
            )(e, "class", t)
        }
        )(e, t),
        (e=>{
            0 === (An(e) ? e.dom.classList : Cn(e)).length && kn(e, "class")
        }
        )(e)
    }
      , Pn = (e,t)=>An(e) && e.dom.classList.contains(t)
      , Rn = (e,t,n=b)=>e.exists((e=>n(e, t)))
      , Mn = (e,t)=>e ? O.some(t) : O.none()
      , Fn = e=>void 0 !== e.style && p(e.style.getPropertyValue)
      , jn = (e,t,n)=>{
        if (!a(n))
            throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e),
            new Error("CSS value must be a string: " + n);
        Fn(e) && e.style.setProperty(t, n)
    }
      , Un = (e,t)=>{
        Fn(e) && e.style.removeProperty(t)
    }
      , Hn = (e,t,n)=>{
        const r = e.dom;
        jn(r, t, n)
    }
      , zn = (e,t)=>{
        const n = e.dom;
        vt(t, ((e,t)=>{
            jn(n, t, e)
        }
        ))
    }
      , Wn = (e,t)=>{
        const n = e.dom
          , r = window.getComputedStyle(n).getPropertyValue(t);
        return "" !== r || qt(e) ? r : Bn(n, t)
    }
      , Bn = (e,t)=>Fn(e) ? e.style.getPropertyValue(t) : ""
      , $n = (e,t)=>{
        const n = e.dom
          , r = Bn(n, t);
        return O.from(r).filter((e=>e.length > 0))
    }
      , Gn = e=>{
        const t = {}
          , n = e.dom;
        if (Fn(n))
            for (let e = 0; e < n.style.length; e++) {
                const r = n.style.item(e);
                t[r] = n.style[r]
            }
        return t
    }
      , Vn = (e,t)=>{
        const n = e.dom;
        Un(n, t),
        Rn(En(e, "style").map(ge), "") && kn(e, "style")
    }
      , qn = e=>"rtl" === Wn(e, "direction") ? "rtl" : "ltr"
      , Kn = (e,t)=>{
        const n = (t || document).createElement("div");
        return n.innerHTML = e,
        Wt(_e.fromDom(n))
    }
      , Yn = e=>e.dom.innerHTML
      , Xn = (e,t,n)=>{
        let r = e.dom;
        const o = p(n) ? n : I;
        for (; r.parentNode; ) {
            r = r.parentNode;
            const e = _e.fromDom(r);
            if (t(e))
                return O.some(e);
            if (o(e))
                break
        }
        return O.none()
    }
      , Zn = (e,t)=>M(e.dom.childNodes, (e=>t(_e.fromDom(e)))).map(_e.fromDom)
      , Jn = (e,t)=>{
        const n = e=>{
            for (let r = 0; r < e.childNodes.length; r++) {
                const o = _e.fromDom(e.childNodes[r]);
                if (t(o))
                    return O.some(o);
                const s = n(e.childNodes[r]);
                if (s.isSome())
                    return s
            }
            return O.none()
        }
        ;
        return n(e.dom)
    }
      , Qn = (e,t,n)=>Xn(e, (e=>St(e, t)), n)
      , er = (e,t,n)=>((e,t,n,r,o)=>((e,t)=>St(e, t))(n, r) ? O.some(n) : p(o) && o(n) ? O.none() : t(n, r, o))(0, Qn, e, t, n)
      , tr = e=>{
        const t = nr(e);
        return {
            resolve: e=>{
                const n = e.split(" ");
                return C(n, (e=>rr(t, e))).join(" ")
            }
        }
    }
      , nr = e=>e.replace(/\./g, "-")
      , rr = (e,t)=>e + "-" + t
      , or = tr("ephox-sloth").resolve
      , sr = v(or("bin"))
      , ar = ["b", "i", "u", "sub", "sup", "strike"]
      , ir = sr()
      , lr = ir + wn("")
      , cr = ("-100000px",
    "100000px",
    e=>"rtl" === qn(e) ? "100000px" : "-100000px");
    const mr = (e,t)=>{
        const n = _e.fromTag("div");
        var r;
        Sn(n, t),
        Sn(n, {
            contenteditable: "true",
            "aria-hidden": "true"
        }),
        zn(n, {
            position: "fixed",
            top: "0px",
            width: "100px",
            height: "100px",
            overflow: "hidden",
            opacity: "0"
        }),
        r = n,
        _([ir, lr], (e=>{
            _n(r, e)
        }
        ));
        const o = e=>Pn(e, lr);
        return {
            attach: e=>{
                hn(n),
                Hn(n, "left", cr(e)),
                un(e, n)
            }
            ,
            focus: ()=>{
                Qn(n, "body").each((t=>{
                    e.toOff(t, n)
                }
                ))
            }
            ,
            contents: ()=>(((e,t)=>{
                Ht(e).filter(t).each((t=>{
                    const n = Wt(t);
                    fn(e, n),
                    vn(t)
                }
                )),
                ((e,t)=>{
                    const n = Wt(e);
                    _(n, (e=>{
                        t(e) && ((e,t)=>{
                            const n = Wt(e)
                              , r = _e.fromTag("div", Rt(e).dom);
                            fn(r, n),
                            cn(e, r),
                            vn(e)
                        }
                        )(e)
                    }
                    ))
                }
                )(e, t),
                _(Wt(e), (e=>{
                    (e=>Se(e) && !e.dom.hasChildNodes() && D(ar, xe(e)))(e) && vn(e)
                }
                ))
            }
            )(n, o),
            {
                elements: Wt(n),
                html: Yn(n),
                offscreen: n
            }),
            container: v(n),
            detach: ()=>{
                vn(n)
            }
        }
    }
      , dr = e=>{
        const t = Nt(e.start, e.finish) && e.soffset === e.foffset;
        return {
            startContainer: v(e.start),
            startOffset: v(e.soffset),
            endContainer: v(e.finish),
            endOffset: v(e.foffset),
            collapsed: v(t)
        }
    }
      , ur = {
        set: (e,t)=>{
            on(e, t.startContainer(), t.startOffset(), t.endContainer(), t.endOffset())
        }
        ,
        get: e=>ln(e).map(dr)
    };
    var pr = e=>t=>{
        const n = It({
            after: gt(["container"])
        })
          , r = (e=>{
            const t = _e.fromTag("br");
            let n = O.none();
            const r = e=>Ft(e).dom;
            return {
                cleanup: ()=>{
                    vn(t)
                }
                ,
                toOn: (t,o)=>{
                    const s = r(o);
                    n.each((n=>{
                        const r = (e=>e.dom.childNodes.length)(t)
                          , o = Nt(t, n.startContainer()) && r < n.startOffset() ? r : n.startOffset()
                          , a = Nt(t, n.endContainer()) && r < n.endOffset() ? r : n.endOffset()
                          , i = bn(n.startContainer(), o, n.endContainer(), a);
                        e.set(s, i)
                    }
                    ))
                }
                ,
                toOff: (o,s)=>{
                    const a = r(s);
                    un(s, t),
                    n = e.get(a),
                    e.set(a, bn(t, 0, t, 0))
                }
            }
        }
        )(ur)
          , o = ((e,t,n)=>{
            const r = mr(e, n)
              , o = ()=>{
                e.cleanup();
                const t = r.contents();
                r.detach(),
                s.trigger.after(t.elements, t.html, r.container())
            }
              , s = It({
                before: gt([]),
                after: gt(["elements", "html", "container"])
            })
              , a = f;
            return {
                instance: v((()=>{
                    s.trigger.before(),
                    r.attach(t),
                    r.focus(),
                    ((e,t)=>{
                        ((e,t)=>{
                            setTimeout(t, 1)
                        }
                        )(0, t)
                    }
                    )(Rt(t), o)
                }
                )),
                destroy: a,
                events: s.registry
            }
        }
        )(r, t, e);
        return o.events.after.bind((e=>{
            r.toOn(t, e.container),
            n.trigger.after(e.container)
        }
        )),
        {
            run: ()=>{
                o.instance()()
            }
            ,
            events: n.registry
        }
    }
    ;
    const gr = e=>{
        let t = O.none()
          , n = [];
        const r = e=>{
            o() ? s(e) : n.push(e)
        }
          , o = ()=>t.isSome()
          , s = e=>{
            t.each((t=>{
                setTimeout((()=>{
                    e(t)
                }
                ), 0)
            }
            ))
        }
        ;
        return e((e=>{
            o() || (t = O.some(e),
            _(n, s),
            n = [])
        }
        )),
        {
            get: r,
            map: e=>gr((t=>{
                r((n=>{
                    t(e(n))
                }
                ))
            }
            )),
            isReady: o
        }
    }
      , fr = {
        nu: gr,
        pure: e=>gr((t=>{
            t(e)
        }
        ))
    }
      , hr = e=>{
        setTimeout((()=>{
            throw e
        }
        ), 0)
    }
      , vr = e=>{
        const t = t=>{
            e().then(t, hr)
        }
        ;
        return {
            map: t=>vr((()=>e().then(t))),
            bind: t=>vr((()=>e().then((e=>t(e).toPromise())))),
            anonBind: t=>vr((()=>e().then((()=>t.toPromise())))),
            toLazy: ()=>fr.nu(t),
            toCached: ()=>{
                let t = null;
                return vr((()=>(null === t && (t = e()),
                t)))
            }
            ,
            toPromise: e,
            get: t
        }
    }
      , yr = e=>vr((()=>new Promise(e)))
      , br = e=>((e,t)=>t((t=>{
        const n = [];
        let r = 0;
        0 === e.length ? t([]) : _(e, ((o,s)=>{
            o.get((o=>s=>{
                n[o] = s,
                r++,
                r >= e.length && t(n)
            }
            )(s))
        }
        ))
    }
    )))(e, yr)
      , xr = ()=>{
        const e = {};
        return {
            getOrSetIndexed: (t,n)=>(t=>void 0 !== e[t])(t) ? e[t] : ((t,n)=>(e[t] = n,
            n))(t, n()),
            waitForLoad: ()=>{
                const t = ((e,t)=>{
                    const n = [];
                    return vt(e, ((e,r)=>{
                        n.push(t(e, r))
                    }
                    )),
                    n
                }
                )(e, y);
                return br(t)
            }
        }
    }
      , wr = e=>{
        const t = t=>t(e)
          , n = v(e)
          , r = ()=>o
          , o = {
            tag: !0,
            inner: e,
            fold: (t,n)=>n(e),
            isValue: S,
            isError: I,
            map: t=>Ir.value(t(e)),
            mapError: r,
            bind: t,
            exists: t,
            forall: t,
            getOr: n,
            or: r,
            getOrThunk: n,
            orThunk: r,
            getOrDie: n,
            each: t=>{
                t(e)
            }
            ,
            toOptional: ()=>O.some(e)
        };
        return o
    }
      , Tr = e=>{
        const t = ()=>n
          , n = {
            tag: !1,
            inner: e,
            fold: (t,n)=>t(e),
            isValue: I,
            isError: S,
            map: t,
            mapError: t=>Ir.error(t(e)),
            bind: t,
            exists: I,
            forall: S,
            getOr: y,
            or: y,
            getOrThunk: T,
            orThunk: T,
            getOrDie: w(String(e)),
            each: f,
            toOptional: O.none
        };
        return n
    }
      , Ir = {
        value: wr,
        error: Tr,
        fromOption: (e,t)=>e.fold((()=>Tr(t)), wr)
    }
      , Sr = e=>{
        const t = _e.fromDom((e=>{
            if ($t() && u(e.target)) {
                const t = _e.fromDom(e.target);
                if (Se(t) && u(t.dom.shadowRoot) && e.composed && e.composedPath) {
                    const t = e.composedPath();
                    if (t)
                        return W(t)
                }
            }
            return O.from(e.target)
        }
        )(e).getOr(e.target))
          , n = ()=>e.stopPropagation()
          , r = ()=>e.preventDefault()
          , o = h(r, n);
        return ((e,t,n,r,o,s,a)=>({
            target: e,
            x: t,
            y: n,
            stop: r,
            prevent: o,
            kill: s,
            raw: a
        }))(t, e.clientX, e.clientY, n, r, o, e)
    }
      , Or = (e,t,n,r)=>{
        e.dom.removeEventListener(t, n, r)
    }
      , Er = S
      , Nr = (e,t,n)=>((e,t,n,r)=>((e,t,n,r,o)=>{
        const s = ((e,t)=>n=>{
            e(n) && t(Sr(n))
        }
        )(n, r);
        return e.dom.addEventListener(t, s, o),
        {
            unbind: x(Or, e, t, s, o)
        }
    }
    )(e, t, n, r, !1))(e, t, Er, n)
      , kr = (e=>{
        const t = x(be, e);
        be("callbacks", t());
        const n = (n,o)=>{
            const s = t()
              , a = (e=>{
                const t = void 0 === e.count ? 0 : e.count
                  , n = "callback_" + t;
                return e.count = t + 1,
                n
            }
            )(s);
            return s.callbacks[a] = (...e)=>{
                o || r(a),
                n(...e)
            }
            ,
            (t=>e + ".callbacks." + t)(a)
        }
          , r = e=>{
            const n = e.substring(e.lastIndexOf(".") + 1)
              , r = t();
            void 0 !== r.callbacks[n] && delete r.callbacks[n]
        }
        ;
        return {
            ephemeral: e=>n(e, !1),
            permanent: e=>n(e, !0),
            unregister: r
        }
    }
    )("ephox.henchman.features")
      , Dr = (e,t)=>fr.nu((n=>{
        const r = t=>{
            _(s, (e=>{
                e.unbind()
            }
            )),
            n(t.fold((t=>Ir.error(t + 'Unable to download editor stylesheets from "' + e + '"')), Ir.value))
        }
          , o = ((e,t)=>{
            const n = _e.fromDom(document)
              , r = _e.fromTag("link", n.dom);
            return Sn(r, {
                rel: "stylesheet",
                type: "text/css",
                href: e
            }),
            ((e,t)=>{
                const n = (e=>{
                    const t = e.dom.head;
                    if (null == t)
                        throw new Error("Head is not available yet");
                    return _e.fromDom(t)
                }
                )(e);
                un(n, t)
            }
            )(n, r),
            r
        }
        )(e)
          , s = [Nr(o, "load", (e=>{
            (e=>{
                var t;
                try {
                    const n = null === (t = e.target.dom.sheet) || void 0 === t ? void 0 : t.cssRules;
                    return i(n) && 0 === n.length
                } catch (e) {}
                return !1
            }
            )(e) ? r(Ir.error("")) : t(r)
        }
        )), Nr(o, "error", x(r, Ir.error("")))]
    }
    ))
      , Ar = (()=>{
        const e = xr()
          , t = ()=>e.waitForLoad();
        return {
            preload: ()=>{
                t().get(y)
            }
            ,
            addStylesheet: (t,n)=>e.getOrSetIndexed(t, (()=>Dr(t, n))),
            addScript: (t,n)=>e.getOrSetIndexed(t, (()=>(e=>fr.nu((t=>{
                const n = ()=>{
                    o.unbind(),
                    s.unbind()
                }
                  , r = _e.fromTag("script");
                In(r, "src", e),
                In(r, "type", "text/javascript"),
                In(r, "async", "async"),
                In(r, "data-main", kr.ephemeral((e=>{
                    t(Ir.value(e))
                }
                )));
                const o = Nr(r, "error", (()=>{
                    n(),
                    t(Ir.error("Error loading external script tag " + e))
                }
                ))
                  , s = Nr(r, "load", n);
                un(_e.fromDom(document.head), r)
            }
            )))(t).map(n))),
            waitForLoad: t
        }
    }
    )()
      , Cr = {
        loadScript: (e,t)=>new Promise(((e,n)=>{
            ((e,t)=>Ar.addScript(e, t))(t, y).get((t=>{
                t.fold(n, e)
            }
            ))
        }
        ))
    }
      , _r = Ct([{
        error: ["message"]
    }, {
        paste: ["elements", "correlated"]
    }, {
        cancel: []
    }, {
        incomplete: ["elements", "correlated", "message"]
    }])
      , Lr = (e,t,n,r,o)=>e.fold(t, n, r, o)
      , Pr = _r.error
      , Rr = _r.paste
      , Mr = _r.cancel
      , Fr = _r.incomplete
      , jr = ["officeStyles", "htmlStyles", "gdocsStyles", "isWord", "isGoogleDocs", "proxyBin", "isInternal"]
      , Ur = (e,t)=>{
        const n = {};
        return _(jr, (r=>{
            t[r].or(e[r]).each((e=>{
                n[r] = e
            }
            ))
        }
        )),
        Hr(n)
    }
      , Hr = e=>z(jr, (t=>O.from(e[t])))
      , zr = e=>({
        response: Pr(e),
        bundle: Hr({})
    })
      , Wr = e=>Promise.resolve(zr(e))
      , Br = {
        response: Mr(),
        bundle: Hr({})
    }
      , $r = e=>u(e.then)
      , Gr = (e,t,n,r)=>({
        steps: e,
        input: t,
        label: n,
        capture: r
    })
      , Vr = (e,t)=>{
        const n = Ur(e.bundle, t.bundle)
          , r = ((e,t)=>Lr(e, O.none, O.none, O.none, ((e,n,r)=>Lr(t, O.none, ((e,t)=>O.some(_r.incomplete(e, t, r))), O.none, O.none))).getOr(t))(e.response, t.response);
        return {
            response: r,
            bundle: n
        }
    }
      , qr = (e,t,n)=>{
        const r = ()=>e
          , o = ()=>{
            const r = n(t, e);
            return $r(r) ? r.then((t=>Vr(e, t))) : Vr(e, r)
        }
        ;
        return Lr(e.response, r, o, r, o)
    }
      , Kr = (Yr = (e,t)=>t,
    (...e)=>{
        if (0 === e.length)
            throw new Error("Can't merge zero objects");
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            for (const e in r)
                Tt(r, e) && (t[e] = Yr(t[e], r[e]))
        }
        return t
    }
    );
    var Yr;
    const Xr = Ct([{
        starts: ["value", "f"]
    }, {
        pattern: ["regex", "f"]
    }, {
        contains: ["value", "f"]
    }, {
        exact: ["value", "f"]
    }, {
        all: []
    }, {
        not: ["stringMatch"]
    }])
      , Zr = y
      , Jr = (e,t)=>e.fold(((e,n)=>0 === n(t).indexOf(n(e))), ((e,n)=>e.test(n(t))), ((e,n)=>n(t).indexOf(n(e)) >= 0), ((e,n)=>n(t) === n(e)), S, (e=>!Jr(e, t)))
      , Qr = {
        starts: Xr.starts,
        pattern: Xr.pattern,
        contains: Xr.contains,
        exact: Xr.exact,
        all: Xr.all,
        not: Xr.not,
        cata: (e,t,n,r,o,s,a)=>e.fold(t, n, r, o, s, a),
        matches: Jr,
        caseSensitive: Zr,
        caseInsensitive: e=>e.toLowerCase()
    }
      , eo = (e,t)=>{
        const n = xe(e)
          , r = t.name
          , o = void 0 !== t.condition ? t.condition : S;
        return Qr.matches(r, n) && o(e)
    }
      , to = (e,t,n)=>{
        const r = (e=>{
            const t = {}
              , n = u(e) ? e.split(";") : [];
            return _(n, (e=>{
                const n = e.split(":");
                2 === n.length && (t[ge(n[0])] = ge(n[1]))
            }
            )),
            t
        }
        )(e.dom.getAttribute("style"))
          , o = {};
        return _(t, (e=>{
            const t = r[e];
            void 0 === t || n(t, e) || (o[e] = t)
        }
        )),
        o
    }
      , no = e=>{
        const t = ft(e);
        return C(t, (t=>t + ": " + e[t])).join("; ")
    }
      , ro = ["mso-list"]
      , oo = (e,t)=>{
        const n = to(e, ro, t)
          , r = ((e,t)=>{
            const n = e.dom.style
              , r = d(n) ? [] : n
              , o = {};
            return _(r, (n=>{
                $n(e, n).each((e=>{
                    t(e, n) || (o[n] = e)
                }
                ))
            }
            )),
            o
        }
        )(e, t);
        ((e,t,n)=>{
            In(e, "style", "");
            const r = wt(t)
              , o = wt(n);
            if (0 === r && 0 === o)
                kn(e, "style");
            else if (0 === r)
                In(e, "style", no(n));
            else {
                vt(t, ((t,n)=>{
                    Hn(e, n, t)
                }
                ));
                const r = On(e, "style")
                  , s = o > 0 ? no(n) + "; " : "";
                In(e, "style", s + r)
            }
        }
        )(e, r, n)
    }
      , so = (e,t)=>{
        const n = ((e,t)=>{
            const n = {};
            return _(e.dom.attributes, (e=>{
                t(e.value, e.name) || (n[e.name] = e.value)
            }
            )),
            n
        }
        )(e, t);
        ((e,t)=>{
            const n = C(e.dom.attributes, (e=>e.name));
            wt(t) !== n.length && ((e,t,n)=>{
                _(t, (t=>{
                    kn(e, t)
                }
                )),
                vt(n, ((t,n)=>{
                    In(e, n, t)
                }
                ))
            }
            )(e, n, t)
        }
        )(e, n)
    }
      , ao = (e,t)=>{
        oo(_e.fromDom(e), t)
    }
      , io = (e,t,n)=>{
        e(n, ((e,r)=>A(t, (t=>((e,t,n,r)=>{
            const o = r.name
              , s = void 0 !== r.condition ? r.condition : S
              , a = void 0 !== r.value ? r.value : Qr.all();
            return Qr.matches(o, n) && Qr.matches(a, t) && s(e)
        }
        )(n, e, r, t)))))
    }
      , lo = "startElement"
      , co = "endElement"
      , mo = "text"
      , uo = "comment"
      , po = (e,t,n)=>{
        let r, o, s;
        const a = _e.fromDom(e);
        switch (e.nodeType) {
        case 1:
            t ? r = co : (r = lo,
            zn(a, n || {}));
            const i = e;
            o = "HTML" !== i.scopeName && i.scopeName && i.tagName && i.tagName.indexOf(":") <= 0 ? (i.scopeName + ":" + i.tagName).toLowerCase() : i.tagName.toLowerCase();
            break;
        case 3:
            r = mo,
            s = e.nodeValue;
            break;
        case 8:
            r = uo,
            s = e.nodeValue;
            break;
        default:
            console.log("WARNING: Unsupported node type encountered: " + e.nodeType)
        }
        return {
            getNode: v(e),
            tag: ()=>o,
            type: ()=>r,
            text: ()=>s
        }
    }
      , go = (e,t,n,r)=>{
        const o = r.createElement(e);
        return vt(t, ((e,t)=>{
            o.setAttribute(t, e + "")
        }
        )),
        po(o, !1, n)
    }
      , fo = (e,t)=>po(t.createElement(e), !0)
      , ho = fo("html", window.document)
      , vo = e=>{
        const t = e.createDocumentFragment();
        let n = t;
        const r = e=>{
            n.appendChild(e)
        }
        ;
        return {
            dom: t,
            receive: o=>{
                switch (o.type()) {
                case lo:
                    s = o.getNode().cloneNode(!1),
                    r(s),
                    n = s;
                    break;
                case mo:
                    (t=>{
                        const n = e.createTextNode(t.text());
                        r(n)
                    }
                    )(o);
                    break;
                case co:
                    (()=>{
                        const e = n.parentNode;
                        n = null === e ? t : e
                    }
                    )();
                    break;
                case uo:
                    break;
                default:
                    throw new Error("Unsupported token type: " + o.type())
                }
                var s
            }
            ,
            label: "SERIALISER"
        }
    }
      , yo = e=>t=>{
        ((e,t)=>{
            const n = Kr({
                styles: [],
                attributes: [],
                classes: [],
                tags: []
            }, t)
              , r = Yt(e, "*");
            _(r, (e=>{
                io(oo, n.styles, e),
                io(so, n.attributes, e),
                _(n.classes, (t=>{
                    const n = Nn(e, "class") ? (e=>An(e) ? (e=>{
                        const t = e.dom.classList
                          , n = new Array(t.length);
                        for (let e = 0; e < t.length; e++) {
                            const r = t.item(e);
                            null !== r && (n[e] = r)
                        }
                        return n
                    }
                    )(e) : Cn(e))(e) : [];
                    _(n, (n=>{
                        Qr.matches(t.name, n) && Ln(e, n)
                    }
                    ))
                }
                ))
            }
            ));
            const o = Yt(e, "*");
            _(o, (e=>{
                A(n.tags, x(eo, e)) && vn(e)
            }
            ))
        }
        )(t, e)
    }
      , bo = e=>t=>{
        ((e,t)=>{
            const n = Kr({
                tags: []
            }, t)
              , r = Yt(e, "*");
            _(r, (e=>{
                A(n.tags, x(eo, e)) && yn(e)
            }
            ))
        }
        )(t, e)
    }
      , xo = e=>t=>{
        ((e,t)=>{
            const n = Kr({
                tags: []
            }, t)
              , r = Yt(e, "*");
            _(r, (e=>{
                M(n.tags, x(eo, e)).each((t=>{
                    t.mutate(e)
                }
                ))
            }
            ))
        }
        )(t, e)
    }
      , wo = e=>t=>{
        const n = Yn(t)
          , r = ((e,t,n)=>{
            const r = vo(e)
              , o = ((e,t=window.document)=>{
                const n = t.createElement("div");
                t.body.appendChild(n),
                n.style.position = "absolute",
                n.style.left = "-10000px",
                n.innerHTML = e;
                let r = n.firstChild || ho;
                const o = [];
                let s = !1;
                return {
                    hasNext: ()=>void 0 !== r,
                    next: ()=>{
                        const e = r
                          , a = r
                          , i = s;
                        return !s && e.firstChild ? (o.push(e),
                        r = e.firstChild) : s || 1 !== e.nodeType ? e.nextSibling ? (r = e.nextSibling,
                        s = !1) : (r = o.pop(),
                        s = !0) : s = !0,
                        a === ho || r || (t.body.removeChild(n),
                        r = ho),
                        (l = a) === ho ? l : l ? po(l, i) : void 0;
                        var l
                    }
                }
            }
            )(t, e)
              , s = ((e,t,n)=>{
                let r = n;
                for (let n = t.length - 1; n >= 0; n--)
                    r = t[n](r, {}, e);
                return r
            }
            )(e, n, r);
            for (; o.hasNext(); ) {
                const e = o.next();
                s.receive(e)
            }
            return r.dom
        }
        )(Rt(t).dom, n, e);
        hn(t),
        t.dom.appendChild(r)
    }
      , To = (e,t,n)=>{
        const r = _e.fromTag("div", e.dom);
        zn(r, {
            position: "fixed",
            left: "-100000px",
            top: "0px"
        }),
        un((e=>{
            const t = e.dom.body;
            if (null == t)
                throw new Error("Body is not available yet");
            return _e.fromDom(t)
        }
        )(e), r),
        r.dom.innerHTML = t,
        _(n, (e=>{
            e(r)
        }
        ));
        const o = Yn(r);
        return vn(r),
        o
    }
      , Io = (e,t)=>n=>{
        const r = e=>{
            n.receive(e)
        }
          , o = (e,t,n)=>(n = void 0 !== n ? n : e.type() === co,
        po(t, n, {}))
          , s = {
            emit: r,
            emitTokens: e=>{
                _(e, r)
            }
            ,
            receive: t=>{
                e(s, t, o)
            }
            ,
            document: window.document
        };
        return t(s),
        s
    }
      , So = (e,t)=>{
        if (void 0 === e || void 0 === t)
            throw console.trace(),
            new Error("brick");
        e.nextFilter.set(t)
    }
      , Oo = (e,t,n=!1)=>e === t || u(e) && u(t) && e.tag === t.tag && e.type === t.type && (n || e.variant === t.variant)
      , Eo = (e,t)=>Nn(_e.fromDom(t.getNode()), "data-list-level")
      , No = (e,t,n,r)=>{
        const o = n.getCurrentListType()
          , s = n.getCurrentLevel() == r.level() ? o : null;
        return (a = r.emblems(),
        i = s,
        M(a, (e=>"ul" === e.tag || u(i) && Oo(e, i, !0))).orThunk((()=>W(a)))).filter((e=>!("ol" === e.tag && (e=>{
            if (D(["p"], e.tag())) {
                const t = ((e,t)=>{
                    const n = _e.fromDom(e.getNode());
                    return On(n, "class")
                }
                )(e);
                return u(t) && /^MsoHeading/.test(t)
            }
            return !0
        }
        )(t))));
        var a, i
    }
      , ko = e=>(t,n,r)=>{
        const o = r
          , s = (e=>{
            const t = parseInt(On(e, "data-list-level"), 10)
              , n = On(e, "data-list-emblems")
              , r = u(n) ? JSON.parse(n) : [];
            return kn(e, "data-list-level"),
            kn(e, "data-list-emblems"),
            {
                level: v(t),
                emblems: v(r)
            }
        }
        )(_e.fromDom(o.getNode()));
        n.originalToken.set(o);
        const a = ((e,t,n)=>(No(n.listType.get(), e, n.emitter, t).each(n.listType.set),
        ((e,t,n)=>({
            level: v(e),
            token: v(t),
            type: v(n)
        }))(t.level(), n.originalToken.get(), n.listType.get())))(o, s, n);
        n.emitter.openItem(a.level(), a.token(), a.type()),
        So(n, e.inside())
    }
      , Do = (e,t,n)=>({
        pred: e,
        action: t,
        label: v(n)
    });
    var Ao = (e,t,n)=>{
        const r = (e,r,o)=>{
            M(t, (e=>e.pred(r, o))).fold(v(n), (e=>e.action))(e, r, o)
        }
        ;
        return r.toString = ()=>"Handlers for " + e,
        r
    }
    ;
    const Co = (e,t)=>({
        state: v(e),
        result: v(t)
    })
      , _o = (e,t)=>({
        state: v(e),
        value: v(t)
    })
      , Lo = (e,t,n,r)=>({
        level: v(e),
        type: v(t),
        types: v(n),
        items: v(r)
    })
      , Po = e=>{
        const t = e.items().slice(0);
        if (t.length > 0 && "p" !== t[t.length - 1]) {
            const n = t[t.length - 1];
            t[t.length - 1] = "p";
            const r = Lo(e.level(), e.type(), e.types(), t);
            return _o(r, O.some(n))
        }
        return _o(e, O.none())
    }
      , Ro = (e,t,n)=>{
        let r = []
          , o = e;
        for (; t(o); ) {
            const e = n(o);
            o = e.state(),
            r = r.concat(e.result())
        }
        return Co(o, r)
    }
      , Mo = (e,t,n)=>{
        const r = t.start && t.start > 1 ? {
            start: t.start
        } : {}
          , o = e.level() + 1
          , s = t
          , a = e.types().concat([t])
          , i = [x(go, t.tag, r, n)]
          , l = Lo(o, s, a, e.items());
        return Co(l, i)
    }
      , Fo = e=>{
        const t = e.types().slice(0)
          , n = [x(fo, t.pop().tag)]
          , r = e.level() - 1
          , o = t[t.length - 1]
          , s = Lo(r, o, t, e.items());
        return Co(s, n)
    }
      , jo = (e,t,n)=>{
        const r = (l = t) ? (e=>{
            const t = ((e,t)=>{
                const n = _e.fromDom(e.getNode());
                return Wn(n, "margin-left")
            }
            )(e);
            return u(t) && "0px" !== t ? {
                "margin-left": t
            } : {}
        }
        )(l) : {
            "list-style-type": "none"
        }
          , o = e.type() && !Oo(e.type(), n) ? ((e,t)=>{
            const n = Fo(e)
              , r = Mo(n.state(), t, t.type ? {
                "list-style-type": t.type
            } : {});
            return Co(r.state(), n.result().concat(r.result()))
        }
        )(e, n) : Co(e, [])
          , s = [x(go, "li", {}, r)]
          , a = ((e,t)=>{
            const n = e.items().slice(0)
              , r = void 0 !== t && "p" !== t ? O.some(t) : O.none();
            r.fold((()=>{
                n.push("p")
            }
            ), (e=>{
                n.push(e)
            }
            ));
            const o = Lo(e.level(), e.type(), e.types(), n);
            return _o(o, r)
        }
        )(o.state(), t && t.tag())
          , i = a.value().map((e=>{
            const n = t;
            return ao(n.getNode(), S),
            [v(n)]
        }
        )).getOr([]);
        var l;
        return Co(a.state(), o.result().concat(s).concat(i))
    }
      , Uo = e=>{
        const t = x(fo, "li")
          , n = Po(e)
          , r = n.value().fold((()=>[t]), (e=>[x(fo, e), t]));
        return Co(n.state(), r)
    }
      , Ho = e=>{
        if (0 === e.length)
            throw new Error("Compose must have at least one element in the list");
        const t = e[e.length - 1]
          , n = U(e, (e=>e.result()));
        return Co(t.state(), n)
    }
      , zo = e=>{
        const t = Uo(e)
          , n = Fo(t.state());
        return Ho([t, n])
    }
      , Wo = (e,t)=>((e,t,n)=>Ro(e, (e=>e.level() > t), n))(e, t, zo)
      , Bo = (e,t,n,r)=>{
        const o = e.level() > t ? Wo(e, t) : Co(e, [])
          , s = o.state().level() === t ? ((e,t,n)=>{
            const r = e.level() > 0 ? Uo(e) : Co(e, [])
              , o = jo(r.state(), n, t);
            return Ho([r, o])
        }
        )(o.state(), r, n) : ((e,t,n,r)=>{
            const o = n > 1 ? Po(e) : _o(e, O.none())
              , s = o.value().map((e=>[x(fo, e)])).getOr([])
              , a = ((e,t,n,r)=>((e,t,n)=>Ro(e, (e=>e.level() < t), n))(e, n, (e=>((e,t,n,r)=>{
                const o = e.level() === n - 1 && t.type ? {
                    "list-style-type": t.type
                } : {}
                  , s = Mo(e, t, o)
                  , a = jo(s.state(), s.state().level() == n ? r : void 0, t);
                return Ho([s, a])
            }
            )(e, t, n, r))))(o.state(), t, n, r);
            return Co(a.state(), s.concat(a.result()))
        }
        )(o.state(), r, t, n);
        return Ho([o, s])
    }
      , $o = Wo
      , Go = ["disc", "circle", "square"]
      , Vo = {
        getCurrentListType: ()=>qo().getCurrentListType(),
        getCurrentLevel: ()=>qo().getCurrentLevel(),
        closeAllLists: ()=>qo().closeAllLists(),
        openItem: (e,t,n)=>qo().openItem(e, t, n)
    };
    let qo = ()=>({
        getCurrentListType: v({}),
        getCurrentLevel: v(1),
        closeAllLists: f,
        openItem: y
    });
    const Ko = {
        inside: ()=>Xo,
        outside: ()=>Zo
    }
      , Yo = (()=>{
        let e = !1;
        return {
            check: t=>!(!e || t.type() !== mo) || (t.type() === lo && "style" === t.tag() ? (e = !0,
            !0) : t.type() === co && "style" === t.tag() && (e = !1,
            !0))
        }
    }
    )()
      , Xo = (e=>Ao("Inside.List.Item", [Do(((e,t)=>{
        const n = e.originalToken.get();
        return t.type() === co && null !== n && t.tag() === n.tag()
    }
    ), ((t,n)=>{
        So(n, e.outside())
    }
    ), "Closing open tag")], ((e,t,n)=>{
        e.emit(n)
    }
    )))(Ko)
      , Zo = (e=>Ao("Outside.List.Item", [Do(Eo, ko(e), "Data List ****"), Do(((e,t)=>t.type() === mo && (e=>e.type() === mo && /^[\s\u00A0]*$/.test(e.text()))(t)), ((e,t,n)=>{
        e.emit(n)
    }
    ), "Whitespace")], ((t,n,r)=>{
        n.emitter.closeAllLists(),
        t.emit(r),
        So(n, e.outside())
    }
    )))(Ko)
      , Jo = (e=>{
        const t = ie(e)
          , n = ie(null)
          , r = ie(null);
        return {
            reset: o=>{
                t.set(e),
                n.set(null),
                r.set(null),
                qo = v(((e,t)=>{
                    let n = Lo(0, void 0, [], []);
                    const r = n=>{
                        _(n.result(), (n=>{
                            const r = n(t);
                            e.emit(r)
                        }
                        ))
                    }
                    ;
                    return {
                        closeAllLists: ()=>{
                            const e = $o(n, 0);
                            n = e.state(),
                            r(e)
                        }
                        ,
                        openItem: (e,t,o)=>{
                            if (!o)
                                return;
                            const s = ((e,t)=>"ul" === e.tag && Go[t - 1] === e.type ? {
                                tag: "ul"
                            } : e)(o, e)
                              , a = Bo(n, e, t, s);
                            n = a.state(),
                            r(a)
                        }
                        ,
                        getCurrentListType: ()=>n.type(),
                        getCurrentLevel: ()=>n.level()
                    }
                }
                )(o, o.document))
            }
            ,
            nextFilter: t,
            originalToken: n,
            listType: r,
            emitter: Vo
        }
    }
    )(Zo);
    var Qo = Io(((e,t,n)=>{
        Yo.check(t) || ((e,t,n)=>{
            t.nextFilter.get()(e, t, n)
        }
        )(e, Jo, t)
    }
    ), Jo.reset);
    const es = e=>e.dom.textContent
      , ts = [{
        regex: /^\(?[dc][\.\)]$/,
        type: {
            tag: "ol",
            type: "lower-alpha"
        }
    }, {
        regex: /^\(?[DC][\.\)]$/,
        type: {
            tag: "ol",
            type: "upper-alpha"
        }
    }, {
        regex: /^\(?M*(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})[\.\)]$/,
        type: {
            tag: "ol",
            type: "upper-roman"
        }
    }, {
        regex: /^\(?m*(cm|cd|d?c{0,3})(xc|xl|l?x{0,3})(ix|iv|v?i{0,3})[\.\)]$/,
        type: {
            tag: "ol",
            type: "lower-roman"
        }
    }, {
        regex: /^\(?[0-9]+[\.\)]$/,
        type: {
            tag: "ol"
        }
    }, {
        regex: /^([0-9]+\.)*[0-9]+\.?$/,
        type: {
            tag: "ol",
            variant: "outline"
        }
    }, {
        regex: /^\(?[a-z]+[\.\)]$/,
        type: {
            tag: "ol",
            type: "lower-alpha"
        }
    }, {
        regex: /^\(?[A-Z]+[\.\)]$/,
        type: {
            tag: "ol",
            type: "upper-alpha"
        }
    }]
      , ns = {
        "\u2022": {
            tag: "ul",
            type: "disc"
        },
        "\xb7": {
            tag: "ul",
            type: "disc"
        },
        "\xa7": {
            tag: "ul",
            type: "square"
        }
    }
      , rs = {
        o: {
            tag: "ul",
            type: "circle"
        },
        "-": {
            tag: "ul",
            type: "disc"
        },
        "\u25cf": {
            tag: "ul",
            type: "disc"
        },
        "\ufffd": {
            tag: "ul",
            type: "circle"
        }
    }
      , os = (e,t)=>m(e.variant) ? "(" === t.charAt(0) ? "()" : ")" === t.charAt(t.length - 1) ? ")" : "." : e.variant
      , ss = e=>{
        const t = e.split(".")
          , n = (()=>{
            if (0 === t.length)
                return e;
            const n = t[t.length - 1];
            return 0 === n.length && t.length > 1 ? t[t.length - 2] : n
        }
        )()
          , r = parseInt(n, 10);
        return isNaN(r) ? {} : {
            start: r
        }
    }
      , as = e=>{
        const t = (e=>to(e, ["mso-list"], I)["mso-list"])(e)
          , n = u(t) && / level([0-9]+)/.exec(t);
        return n && n[1] ? O.some(parseInt(n[1], 10)) : O.none()
    }
      , is = (e,t)=>{
        const n = ((e,t)=>{
            const n = rs[e] ? [rs[e]] : []
              , r = ((e,t)=>t && ns[e] ? [ns[e]] : t ? [{
                tag: "ul",
                variant: e
            }] : [])(e, t)
              , o = U(ts, (t=>t.regex.test(e) ? [Kr(t.type, ss(e), {
                variant: os(t.type, e)
            })] : []))
              , s = n.concat(r).concat(o);
            return C(s, (t=>void 0 !== t.variant ? t : Kr(t, {
                variant: e
            })))
        }
        )(es(e).trim(), t);
        return n.length > 0 ? O.some(n) : O.none()
    }
      , ls = e=>Zn(e, Ie).bind(Ht).filter(ke("span"))
      , cs = e=>Jn(e, (e=>!!(Se(e) ? to(e, ["mso-list"], I) : {})["mso-list"]))
      , ms = e=>Se(e) && $n(e, "font-family").exists((e=>D(["wingdings", "symbol"], e.toLowerCase())))
      , ds = (e,t,n,r)=>{
        ((e,t,n)=>{
            In(e, "data-list-level", t);
            const r = JSON.stringify(n);
            In(e, "data-list-emblems", r)
        }
        )(e, t, n),
        (e=>{
            const t = ((e,t)=>{
                const n = t.getOr(S);
                return (e=>{
                    const t = [];
                    for (; null !== e.nextNode(); )
                        t.push(_e.fromDom(e.currentNode));
                    return t
                }
                )(document.createTreeWalker(e.dom, NodeFilter.SHOW_COMMENT, {
                    acceptNode: e=>n(e.nodeValue) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
                }))
            }
            )(e, O.none());
            _(t, vn)
        }
        )(e),
        _(r, vn),
        kn(e, "style"),
        kn(e, "class")
    }
      , us = e=>(e=>as(e).bind((t=>(e=>Zn(e, ms))(e).bind((n=>is(n, !0).map((r=>({
        mutate: ()=>{
            ds(e, t, r, [n])
        }
    }))))))))(e).orThunk((()=>(e=>as(e).bind((t=>ls(e).bind((n=>is(n, ms(n)).map((r=>({
        mutate: ()=>{
            ds(e, t, r, [n])
        }
    }))))))))(e))).orThunk((()=>(e=>as(e).bind((t=>ls(e).bind((n=>is(n, ms(n)).map((r=>({
        mutate: ()=>{
            ds(e, t, r, [n])
        }
    }))))))))(e))).orThunk((()=>(e=>"p" !== xe(e) ? O.none() : as(e).bind((t=>cs(e).bind((n=>is(n, !1).map((r=>({
        mutate: ()=>{
            ds(e, t, r, [jt(n).getOr(n)])
        }
    }))))))))(e))).orThunk((()=>(e=>"p" !== xe(e) ? O.none() : cs(e).bind((t=>{
        const n = jt(t).getOr(t)
          , r = ms(n);
        return is(t, r).bind((t=>(e=>$n(e, "margin-left").bind((e=>{
            const t = parseInt(e, 10);
            return isNaN(t) ? O.none() : O.some(Math.max(1, Math.ceil(t / 18)))
        }
        )))(e).map((r=>({
            mutate: ()=>{
                ds(e, r, t, [n])
            }
        })))))
    }
    )))(e)))
      , ps = xo({
        tags: [{
            name: Qr.pattern(/^(p|h\d+)$/, Qr.caseInsensitive),
            mutate: e=>{
                us(e).each((e=>{
                    e.mutate()
                }
                ))
            }
        }]
    })
      , gs = Qo
      , fs = e=>{
        return (o = e,
        Ie(o) ? (t = o,
        n = "v:shape",
        O.from((r = t,
        r.dom.nodeValue)).bind((e=>{
            const t = e.indexOf("]>")
              , r = (e=>{
                try {
                    return (new DOMParser).parseFromString(e, "text/html").body
                } catch (t) {
                    const n = document.implementation.createHTMLDocument("").body;
                    return n.innerHTML = e,
                    n
                }
            }
            )(`<div>${e.slice(t + "]>".length, e.lastIndexOf("<!["))}</div>`);
            return Jn(_e.fromDom(r), (e=>xe(e) === n))
        }
        ))) : O.none()).map((e=>{
            const t = On(e, "o:spid")
              , n = void 0 === t ? En(e, "id").getOr("") : t
              , r = _e.fromTag("img");
            return _n(r, "rtf-data-image"),
            In(r, "data-image-id", n.substr("_x0000_".length)),
            In(r, "data-image-type", "code"),
            ((e,t)=>{
                const n = e.dom;
                vt(t, ((e,t)=>{
                    e.fold((()=>{
                        Un(n, t)
                    }
                    ), (e=>{
                        jn(n, t, e)
                    }
                    ))
                }
                ))
            }
            )(r, {
                width: $n(e, "width"),
                height: $n(e, "height")
            }),
            r
        }
        ));
        var t, n, r, o
    }
      , hs = e=>{
        if (ke("img")(e)) {
            const t = On(e, "src");
            if (null != t && ue(t, "file://")) {
                const n = (e=>((e,t)=>_e.fromDom(e.dom.cloneNode(!1)))(e))(e)
                  , r = t.split(/[\/\\]/)
                  , o = r[r.length - 1];
                return In(n, "data-image-id", o),
                kn(n, "src"),
                In(n, "data-image-type", "local"),
                _n(n, "rtf-data-image"),
                O.some(n)
            }
            return O.none()
        }
        return O.none()
    }
    ;
    var vs;
    !function(e) {
        e[e.Word = 0] = "Word",
        e[e.GoogleDocs = 1] = "GoogleDocs",
        e[e.Html = 2] = "Html"
    }(vs || (vs = {}));
    const ys = e=>t=>{
        En(t, e.attrName).each((n=>{
            const r = u(e.styleName) ? e.styleName : e.attrName;
            if ($n(t, r).isNone()) {
                const o = e.mapValue(n);
                Hn(t, r, o)
            }
            kn(t, e.attrName)
        }
        ))
    }
      , bs = e=>{
        const t = xe(e);
        return "td" === t || "tr" === t || "col" === t || "th" === t
    }
      , xs = /^#?([a-f\d])([a-f\d])([a-f\d])$/i
      , ws = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i
      , Ts = e=>me(e, "#").toUpperCase()
      , Is = e=>{
        const t = e.toString(16);
        return (1 === t.length ? "0" + t : t).toUpperCase()
    }
      , Ss = e=>(e=>({
        value: e
    }))(Is(e.red) + Is(e.green) + Is(e.blue))
      , Os = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i
      , Es = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i
      , Ns = (e,t,n,r)=>({
        red: e,
        green: t,
        blue: n,
        alpha: r
    })
      , ks = (e,t,n,r)=>{
        const o = parseInt(e, 10)
          , s = parseInt(t, 10)
          , a = parseInt(n, 10)
          , i = parseFloat(r);
        return Ns(o, s, a, i)
    }
      , Ds = e=>{
        return "currentcolor" === e || "transparent" === e ? e : "#" + (t = me(e, "#").toUpperCase(),
        (e=>xs.test(e) || ws.test(e))(t) ? O.some({
            value: Ts(t)
        }) : O.none()).orThunk((()=>(e=>{
            if ("transparent" === e)
                return O.some(Ns(0, 0, 0, 0));
            const t = Os.exec(e);
            if (null !== t)
                return O.some(ks(t[1], t[2], t[3], "1"));
            const n = Es.exec(e);
            return null !== n ? O.some(ks(n[1], n[2], n[3], n[4])) : O.none()
        }
        )(e).map(Ss))).getOrThunk((()=>{
            const t = document.createElement("canvas");
            t.height = 1,
            t.width = 1;
            const n = t.getContext("2d");
            n.clearRect(0, 0, t.width, t.height),
            n.fillStyle = "#FFFFFF",
            n.fillStyle = e,
            n.fillRect(0, 0, 1, 1);
            const r = n.getImageData(0, 0, 1, 1).data
              , o = r[0]
              , s = r[1]
              , a = r[2]
              , i = r[3];
            return Ss(Ns(o, s, a, i))
        }
        )).value;
        var t
    }
      , As = (e,t)=>{
        switch (t) {
        case "color":
            return Ds(e);
        case "font-family":
            return e.replace(/['"]/g, "");
        case "font-weight":
            return (e=>{
                switch (e) {
                case "bold":
                    return "700";
                case "normal":
                    return "400";
                default:
                    return e
                }
            }
            )(e);
        default:
            return pe(t, "-color") ? Ds(e) : (e=>e.replace(/^0(pt|px|pc|in|cm|mm|Q|cap|ch|ic|em|ex|lh|rlh|rem|vw|vh|vb|vi|vmax|vmin|%)$/, "0"))(e)
        }
    }
      , Cs = xo({
        tags: [{
            name: Qr.pattern(/^(p|div)$/, Qr.caseInsensitive),
            mutate: e=>{
                const t = "ltr" === qn(e)
                  , n = t ? "margin-left" : "margin-right"
                  , r = t ? "padding-left" : "padding-right";
                $n(e, n).each((()=>{
                    const t = Wn(e, n);
                    Hn(e, r, t),
                    Vn(e, n)
                }
                ))
            }
        }]
    })
      , _s = bo({
        tags: [{
            name: Qr.exact("b", Qr.caseInsensitive),
            condition: e=>En(e, "id").exists((e=>ue(e, "docs-internal-guid")))
        }]
    })
      , Ls = yo({
        attributes: [{
            name: Qr.exact("id", Qr.caseInsensitive),
            value: Qr.starts("docs-internal-guid", Qr.caseInsensitive)
        }]
    })
      , Ps = [xo({
        tags: [{
            name: Qr.exact("col", Qr.caseInsensitive),
            mutate: ys({
                attrName: "width",
                mapValue: e=>e.replace(/^(\d+)$/, "$1px")
            })
        }]
    })]
      , Rs = e=>xo({
        tags: [{
            name: Qr.exact(e.matchTag, Qr.caseInsensitive),
            mutate: t=>{
                var n, r;
                (n = Gn(t),
                r = e.key,
                Tt(n, r) ? O.from(n[r]) : O.none()).exists((t=>D(e.values, t))) && (pn(t, _e.fromTag(e.newTag)),
                Vn(t, e.key),
                l(e.removeExtra) && _(e.removeExtra, (e=>Vn(t, e))))
            }
        }]
    })
      , Ms = [Rs({
        matchTag: "span",
        key: "font-weight",
        values: ["700", "bold"],
        newTag: "strong"
    }), Rs({
        matchTag: "span",
        key: "font-style",
        values: ["italic"],
        newTag: "em"
    }), Rs({
        matchTag: "span",
        key: "vertical-align",
        values: ["sub"],
        newTag: "sub",
        removeExtra: ["font-size"]
    }), Rs({
        matchTag: "span",
        key: "vertical-align",
        values: ["super"],
        newTag: "sup",
        removeExtra: ["font-size"]
    })]
      , Fs = e=>t=>{
        const n = []
          , r = {
            border: e.browser.isFirefox() ? "medium none" : "none",
            "text-decoration": "none"
        }
          , o = (e,t)=>{
            if (!m(t)) {
                const r = _e.fromTag(xe(e));
                un(t, r),
                n.push({
                    me: e,
                    fake: r
                })
            }
            const r = P(Wt(e), Se);
            _(r, (t=>o(t, e)))
        }
        ;
        o(t);
        const s = C(n, (e=>{
            const {fake: t, me: n} = e
              , o = Gn(n)
              , s = xt(o, ((e,n)=>{
                const r = Wn(t, n);
                return As(e, n) === As(r, n)
            }
            ))
              , a = xt(r, ((e,t)=>Rn($n(n, t), e)));
            return {
                fake: t,
                me: n,
                toRemove: s,
                toPreserve: a
            }
        }
        ));
        _(s, (e=>{
            const {me: t, toRemove: n, toPreserve: r, fake: o} = e;
            vt(n, ((e,n)=>{
                Vn(t, n)
            }
            )),
            vt(r, ((e,n)=>{
                Hn(t, n, e)
            }
            )),
            vn(o)
        }
        ))
    }
      , js = ["p", "div", "article", "aside", "details", "dt", "figcaption", "footer", "form", "fieldset", "header", "hgroup", "html", "main", "nav", "section", "summary", "body", "dl", "multicol", "dd", "figure", "address", "center", "blockquote", "h1", "h2", "h3", "h4", "h5", "h6", "listing", "xmp", "pre", "plaintext", "menu", "dir", "ul", "ol", "li", "hr", "table", "tbody", "thead", "tfoot", "th", "tr", "td", "caption"]
      , Us = yo({
        styles: [{
            name: Qr.exact("background-color", Qr.caseInsensitive),
            value: Qr.exact("transparent", Qr.caseInsensitive)
        }, {
            name: Qr.exact("white-space", Qr.caseInsensitive),
            value: Qr.starts("pre", Qr.caseInsensitive)
        }, {
            name: Qr.pattern(/^overflow(-[xy])?$/, Qr.caseInsensitive),
            condition: e=>bs(e) && Rn($n(e, "overflow"), "hidden")
        }, {
            name: Qr.exact("overflow-wrap", Qr.caseInsensitive),
            condition: bs
        }, {
            name: Qr.exact("table-layout", Qr.caseInsensitive),
            value: Qr.exact("fixed", Qr.caseInsensitive),
            condition: ke("table")
        }, {
            name: Qr.exact("line-height", Qr.caseInsensitive),
            value: Qr.exact("1.38", Qr.caseInsensitive)
        }, {
            name: Qr.exact("vertical-align", Qr.caseInsensitive),
            value: Qr.exact("baseline", Qr.caseInsensitive)
        }, {
            name: Qr.exact("font-style", Qr.caseInsensitive),
            value: Qr.exact("normal", Qr.caseInsensitive)
        }, {
            name: Qr.exact("font-variant", Qr.caseInsensitive),
            value: Qr.exact("normal", Qr.caseInsensitive)
        }, {
            name: Qr.exact("background-color", Qr.caseInsensitive),
            value: Qr.exact("transparent", Qr.caseInsensitive)
        }, {
            name: Qr.starts("padding", Qr.caseInsensitive),
            condition: bs
        }, {
            name: Qr.pattern(/^text-decoration(-(line|thickness|style|color))?$/, Qr.caseInsensitive),
            condition: e=>!ke("a")(e) && Rn($n(e, "text-decoration"), "none")
        }],
        attributes: [{
            name: Qr.exact("aria-level", Qr.caseInsensitive),
            condition: ke("li")
        }, {
            name: Qr.exact("dir", Qr.caseInsensitive),
            value: Qr.exact("ltr", Qr.caseInsensitive),
            condition: e=>D(js, xe(e))
        }, {
            name: Qr.exact("role", Qr.caseInsensitive),
            value: Qr.exact("presentation", Qr.caseInsensitive),
            condition: e=>ke("p")(e) && jt(e).exists(ke("li"))
        }]
    })
      , Hs = yo({
        styles: [{
            name: Qr.exact("text-align", Qr.caseInsensitive),
            value: Qr.exact("right", Qr.caseInsensitive),
            condition: e=>"rtl" === qn(e)
        }]
    })
      , zs = xo({
        tags: [{
            name: Qr.exact("p", Qr.caseInsensitive),
            condition: e=>{
                const t = t=>$n(e, t).map((e=>parseInt(e, 10))).filter((e=>!isNaN(e))).getOr(0)
                  , n = qn(e);
                return t("text-indent") + t("rtl" === n ? "padding-right" : "padding-left") === 0
            }
            ,
            mutate: e=>{
                const t = qn(e);
                Vn(e, "text-indent"),
                Vn(e, "rtl" === t ? "padding-right" : "padding-left")
            }
        }]
    })
      , Ws = e=>t=>Pn(t, e)
      , Bs = he(Oe, "text")
      , $s = e=>Bs.get(e)
      , Gs = e=>{
        const t = e.dom.attributes;
        return null == t || 0 === t.length || 1 === t.length && "style" === t[0].name
    }
      , Vs = (e,t)=>{
        const n = _e.fromTag(e);
        cn(t, n);
        const r = t.dom.attributes;
        _(r, (e=>{
            n.dom.setAttribute(e.name, e.value)
        }
        ));
        const o = Wt(t);
        return fn(n, o),
        vn(t),
        n
    }
      , qs = ke("li")
      , Ks = e=>Ut(e).bind((e=>Oe(e) && 0 === $s(e).trim().length ? Ks(e) : qs(e) ? O.some(e) : O.none()))
      , Ys = e=>{
        const t = Vs("span", e)
          , n = {
            "font-size": {
                1: "8pt",
                2: "10pt",
                3: "12pt",
                4: "14pt",
                5: "18pt",
                6: "24pt",
                7: "36pt"
            }
        };
        vt({
            face: "font-family",
            size: "font-size",
            color: "color"
        }, ((e,r)=>{
            En(t, r).each((o=>{
                const s = n[e]
                  , a = void 0 !== s && void 0 !== s[o] ? s[o] : o;
                Hn(t, e, a),
                kn(t, r)
            }
            ))
        }
        ))
    }
      , Xs = yo({
        tags: [{
            name: Qr.exact("script", Qr.caseInsensitive)
        }, {
            name: Qr.exact("link", Qr.caseInsensitive)
        }, {
            name: Qr.exact("style", Qr.caseInsensitive),
            condition: e=>0 === Yn(e).length
        }],
        attributes: [{
            name: Qr.starts("on", Qr.caseInsensitive)
        }, {
            name: Qr.exact('"', Qr.caseInsensitive)
        }, {
            name: Qr.exact("lang", Qr.caseInsensitive)
        }, {
            name: Qr.exact("language", Qr.caseInsensitive)
        }],
        styles: [{
            name: Qr.all(),
            value: Qr.pattern(/OLE_LINK/i, Qr.caseInsensitive)
        }]
    })
      , Zs = yo({
        tags: [{
            name: Qr.exact("meta", Qr.caseInsensitive)
        }]
    })
      , Js = yo({
        tags: [{
            name: Qr.exact("style", Qr.caseInsensitive)
        }]
    })
      , Qs = yo({
        styles: [{
            name: Qr.not(Qr.pattern(/^(width|height|list-style-type)$/, Qr.caseInsensitive)),
            condition: e=>!Pn(e, "ephox-limbo-transform")
        }, {
            name: Qr.pattern(/^(width|height)$/, Qr.caseInsensitive),
            condition: e=>{
                return (e=>"img" !== xe(e))(e) && !("table" === xe(t = e) || bs(t));
                var t
            }
        }]
    })
      , ea = (e=[])=>{
        const t = C(e, (e=>({
            name: Qr.exact(e, Qr.caseInsensitive)
        })));
        return bo({
            tags: t
        })
    }
      , ta = yo({
        classes: [{
            name: Qr.not(Qr.exact("rtf-data-image", Qr.caseInsensitive))
        }]
    })
      , na = yo({
        styles: [{
            name: Qr.pattern(/^(mso-.*|tab-stops|tab-interval|language|text-underline|text-effect|text-line-through|font-color|horiz-align|list-image-[0-9]+|separator-image|table-border-color-(dark|light)|vert-align|vnd\..*)$/, Qr.caseInsensitive)
        }]
    })
      , ra = yo({
        classes: [{
            name: Qr.pattern(/mso/i, Qr.caseInsensitive)
        }]
    })
      , oa = bo({
        tags: [{
            name: Qr.exact("img", Qr.caseInsensitive),
            condition: e=>{
                const t = On(e, "src");
                return a(t) && /^file:/.test(t)
            }
        }]
    })
      , sa = bo({
        tags: [{
            name: Qr.exact("a", Qr.caseInsensitive),
            condition: Gs
        }]
    })
      , aa = yo({
        attributes: [{
            name: Qr.exact("style", Qr.caseInsensitive),
            value: Qr.exact("", Qr.caseInsensitive)
        }]
    })
      , ia = yo({
        attributes: [{
            name: Qr.exact("class", Qr.caseInsensitive),
            value: Qr.exact("", Qr.caseInsensitive)
        }]
    })
      , la = bo({
        tags: [{
            name: Qr.pattern(/^(font|em|strong|samp|acronym|cite|code|dfn|kbd|tt|b|i|u|s|sub|sup|ins|del|var|span)$/, Qr.caseInsensitive),
            condition: (ca = e=>!Gs(e) || (e=>{
                const t = e.dom.attributes
                  , n = null != t && t.length > 0;
                return "span" !== xe(e) || n
            }
            )(e) && Jn(e, (e=>{
                const t = !Gs(e)
                  , n = !D(["font", "em", "strong", "samp", "acronym", "cite", "code", "dfn", "kbd", "tt", "b", "i", "u", "s", "sub", "sup", "ins", "del", "var", "span"], xe(e));
                return Oe(e) || t || n
            }
            )).isSome(),
            e=>!ca(e))
        }]
    });
    var ca;
    const ma = xo({
        tags: [{
            name: Qr.exact("p", Qr.caseInsensitive),
            mutate: e=>{
                0 === Yn(e).length && un(e, _e.fromTag("br"))
            }
        }]
    })
      , da = e=>{
        const t = Vs("span", e);
        _n(t, "ephox-limbo-transform"),
        Hn(t, "text-decoration", "underline")
    }
      , ua = xo({
        tags: [{
            name: Qr.pattern(/ol|ul/, Qr.caseInsensitive),
            mutate: e=>{
                jt(e).each((t=>{
                    const n = xe(t);
                    D(["ol", "ul"], n) && Ks(e).fold((()=>{
                        const t = _e.fromTag("li");
                        Hn(t, "list-style-type", "none"),
                        pn(e, t)
                    }
                    ), (t=>{
                        un(t, e)
                    }
                    ))
                }
                ))
            }
        }]
    })
      , pa = e=>{
        const t = [{
            name: "b",
            transform: {
                mutate: x(Vs, "strong")
            }
        }, {
            name: "i",
            transform: {
                mutate: x(Vs, "em")
            }
        }, {
            name: "u",
            transform: {
                mutate: da
            }
        }, {
            name: "s",
            transform: {
                mutate: x(Vs, "strike")
            }
        }, {
            name: "font",
            transform: {
                mutate: Ys,
                debug: !0
            }
        }]
          , n = P(t, (t=>!D(e, t.name))).map((e=>({
            name: Qr.exact(e.name, Qr.caseInsensitive),
            ...e.transform
        })));
        return xo({
            tags: n
        })
    }
      , ga = yo({
        classes: [{
            name: Qr.exact("ephox-limbo-transform", Qr.caseInsensitive)
        }]
    })
      , fa = yo({
        tags: [{
            name: Qr.exact("br", Qr.caseInsensitive),
            condition: Ws("Apple-interchange-newline")
        }]
    })
      , ha = yo({
        styles: [{
            name: Qr.pattern(/^-/, Qr.caseInsensitive)
        }, {
            name: Qr.all(),
            value: Qr.exact("initial", Qr.caseInsensitive)
        }, {
            name: Qr.exact("background-color", Qr.caseInsensitive),
            value: Qr.exact("transparent", Qr.caseInsensitive)
        }, {
            name: Qr.exact("font-style", Qr.caseInsensitive),
            value: Qr.exact("normal", Qr.caseInsensitive)
        }, {
            name: Qr.pattern(/font-variant.*/, Qr.caseInsensitive)
        }, {
            name: Qr.exact("letter-spacing", Qr.caseInsensitive)
        }, {
            name: Qr.exact("font-weight", Qr.caseInsensitive),
            value: Qr.pattern(/400|normal/, Qr.caseInsensitive)
        }, {
            name: Qr.exact("orphans", Qr.caseInsensitive)
        }, {
            name: Qr.exact("text-decoration", Qr.caseInsensitive),
            value: Qr.exact("none", Qr.caseInsensitive)
        }, {
            name: Qr.exact("text-size-adjust", Qr.caseInsensitive)
        }, {
            name: Qr.exact("text-indent", Qr.caseInsensitive),
            value: Qr.exact("0px", Qr.caseInsensitive)
        }, {
            name: Qr.exact("text-transform", Qr.caseInsensitive),
            value: Qr.exact("none", Qr.caseInsensitive)
        }, {
            name: Qr.exact("white-space", Qr.caseInsensitive),
            value: Qr.exact("normal", Qr.caseInsensitive)
        }, {
            name: Qr.exact("widows", Qr.caseInsensitive)
        }, {
            name: Qr.exact("word-spacing", Qr.caseInsensitive),
            value: Qr.exact("0px", Qr.caseInsensitive)
        }, {
            name: Qr.exact("text-align", Qr.caseInsensitive),
            value: Qr.pattern(/start|end/, Qr.caseInsensitive)
        }, {
            name: Qr.exact("font-weight", Qr.caseInsensitive),
            value: Qr.pattern(/700|bold/, Qr.caseInsensitive),
            condition: e=>/^h\d$/.test(xe(e))
        }]
    })
      , va = (()=>{
        const e = (e,t)=>n=>e(n).filter((e=>Oe(n) && t(es(e) || "", " "))).isSome()
          , t = e(Ut, pe)
          , n = e(Ht, ue);
        return xo({
            tags: [{
                name: Qr.exact("span", Qr.caseInsensitive),
                condition: Ws("Apple-converted-space"),
                mutate: e=>{
                    "\xa0" === es(e) && (t(e) || n(e) ? yn(e) : (cn(e, _e.fromText(" ")),
                    vn(e)))
                }
            }]
        })
    }
    )()
      , ya = (()=>{
        const e = /^file:\/\/\/[^#]+(#[^#]+)$/;
        return xo({
            tags: [{
                name: Qr.exact("a", Qr.caseInsensitive),
                condition: t=>{
                    const n = On(t, "href");
                    return !!n && e.test(n)
                }
                ,
                mutate: t=>{
                    En(t, "href").each((n=>{
                        In(t, "href", n.replace(e, "$1"))
                    }
                    ))
                }
            }]
        })
    }
    )()
      , ba = yo({
        attributes: [{
            name: Qr.exact("href", Qr.caseInsensitive),
            value: Qr.starts("file:///", Qr.caseInsensitive)
        }]
    })
      , xa = (()=>{
        const e = (e,t,n)=>({
            name: Qr.exact(e, Qr.caseInsensitive),
            condition: e=>Nn(e, t),
            mutate: e=>{
                En(e, t).each((r=>{
                    In(e, n, r),
                    kn(e, t)
                }
                ))
            }
        });
        return xo({
            tags: [e("a", "data-ephox-href", "href"), e("img", "data-ephox-src", "src")]
        })
    }
    )()
      , wa = e=>{
        const t = ["table", "thead", "tbody", "tfoot", "th", "tr", "td", "ul", "ol", "li"]
          , n = Kt(e, Ie)
          , r = M(n, (e=>de(Ae(e), "StartFragment")))
          , o = M(n, (e=>de(Ae(e), "EndFragment")));
        r.each((n=>{
            o.each((r=>{
                let o = n;
                const s = [];
                let a = ((e,t,n,r)=>{
                    const o = tn(e, 0, n, 0);
                    return _e.fromDom(o.commonAncestorContainer)
                }
                )(n, 0, r);
                for (; void 0 !== a && !Nt(a, e); )
                    D(t, xe(a)) ? o = a : s.push(a),
                    a = jt(a).getOrUndefined();
                _(s, yn),
                _(zt(o), vn)
            }
            )),
            vn(n)
        }
        )),
        o.each(vn)
    }
      , Ta = xo({
        tags: [{
            name: Qr.pattern(/^(img|table)$/, Qr.caseInsensitive),
            mutate: e=>{
                $n(e, "margin-left").exists((e=>ue(e, "-"))) && Vn(e, "margin-left"),
                ue(Wn(e, "margin-left"), "-") && (Hn(e, "margin-top", Wn(e, "margin-top")),
                Hn(e, "margin-bottom", Wn(e, "margin-bottom")),
                Hn(e, "margin-right", Wn(e, "margin-right")),
                Vn(e, "margin"))
            }
        }]
    })
      , Ia = xo({
        tags: [{
            name: Qr.exact("p", Qr.caseInsensitive),
            mutate: ys({
                attrName: "align",
                styleName: "text-align",
                mapValue: y
            })
        }]
    })
      , Sa = (e,t)=>{
        return (n = e,
        Bs.getOption(n)).exists((e=>0 === t(e).length));
        var n
    }
      , Oa = yo({
        tags: [{
            name: Qr.exact("font", Qr.caseInsensitive),
            condition: e=>{
                const t = Wt(e)
                  , n = e=>e.replace(/[ \r\n\uFEFF]+/g, "");
                return 0 === t.length || H(t, (e=>Sa(e, n)))
            }
        }]
    })
      , Ea = e=>_(Wt(e), (e=>{
        Sa(e, ge) && vn(e)
    }
    ))
      , Na = xo({
        tags: [{
            name: Qr.exact("ol", Qr.caseInsensitive),
            mutate: Ea
        }, {
            name: Qr.exact("ul", Qr.caseInsensitive),
            mutate: Ea
        }]
    })
      , ka = bo({
        tags: [{
            name: Qr.pattern(/^([OVWXP]|U[0-9]+|ST[0-9]+):/i, Qr.caseInsensitive)
        }]
    })
      , Da = [wo([gs])]
      , Aa = yo({
        attributes: [{
            name: Qr.exact("height", Qr.caseInsensitive),
            condition: ke("table")
        }]
    })
      , Ca = yo({
        attributes: [{
            name: Qr.pattern(/^(width|height)$/, Qr.caseInsensitive),
            condition: bs
        }]
    })
      , _a = xo({
        tags: [{
            name: Qr.exact("table", Qr.caseInsensitive),
            mutate: ys({
                attrName: "width",
                mapValue: e=>e.replace(/^(\d+)$/, "$1px")
            })
        }]
    })
      , La = yo({
        styles: [{
            name: Qr.exact("height", Qr.caseInsensitive),
            condition: ke("td")
        }, {
            name: Qr.exact("width", Qr.caseInsensitive),
            condition: ke("tr")
        }, {
            name: Qr.exact("height", Qr.caseInsensitive),
            condition: ke("col")
        }]
    })
      , Pa = yo({
        attributes: [{
            name: Qr.pattern(/^v:/, Qr.caseInsensitive)
        }, {
            name: Qr.exact("href", Qr.caseInsensitive),
            value: Qr.contains("#_toc", Qr.caseInsensitive)
        }, {
            name: Qr.exact("href", Qr.caseInsensitive),
            value: Qr.contains("#_mso", Qr.caseInsensitive)
        }, {
            name: Qr.pattern(/^xmlns(:|$)/, Qr.caseInsensitive)
        }, {
            name: Qr.exact("type", Qr.caseInsensitive),
            condition: e=>"ol" === xe(e) || "ul" === xe(e)
        }]
    });
    bo({
        tags: [{
            name: Qr.exact("p", Qr.caseInsensitive),
            condition: ("li",
            e=>jt(e).exists((e=>"li" === xe(e) && 1 === Wt(e).length)))
        }]
    }),
    xo({
        tags: [{
            name: Qr.pattern(/^(img|table)$/, Qr.caseInsensitive),
            mutate: e=>{
                $n(e, "margin-left").exists((e=>ue(e, "-"))) && Vn(e, "margin-left"),
                ue(Wn(e, "margin-left"), "-") && (Hn(e, "margin-top", Wn(e, "margin-top")),
                Hn(e, "margin-bottom", Wn(e, "margin-bottom")),
                Hn(e, "margin-right", Wn(e, "margin-right")),
                Vn(e, "margin"))
            }
        }]
    });
    const Ra = e=>{
        const t = [Ia, na, ra]
          , n = [Ia, Qs, ea(e.cleanFilteredInlineElements), ta];
        return e.merge ? t : n
    }
      , Ma = e=>e.type === vs.Word ? [ps] : []
      , Fa = e=>e.type === vs.Word ? [ka, ...Da, Pa] : []
      , ja = e=>e.type === vs.GoogleDocs ? [_s] : []
      , Ua = e=>e.type !== vs.GoogleDocs || e.indentUseMargin ? [] : [Cs]
      , Ha = (e,t)=>e.type === vs.GoogleDocs ? [Us, ...Ms, ...Ps, Fs(t), Hs, zs, ...Ua(e)] : []
      , za = e=>e.type === vs.Html && e.merge ? [ha] : []
      , Wa = e=>e.type === vs.Word ? [La, _a, Ca, Aa] : [];
    Ct([{
        bothErrors: ["error1", "error2"]
    }, {
        firstError: ["error1", "value2"]
    }, {
        secondError: ["value1", "error2"]
    }, {
        bothValues: ["value1", "value2"]
    }]);
    const Ba = (e,t)=>Va(document.createElement("canvas"), e, t)
      , $a = e=>{
        const t = Ba(e.width, e.height);
        return Ga(t).drawImage(e, 0, 0),
        t
    }
      , Ga = e=>e.getContext("2d")
      , Va = (e,t,n)=>(e.width = t,
    e.height = n,
    e)
      , qa = e=>e.naturalWidth || e.width
      , Ka = e=>e.naturalHeight || e.height
      , Ya = e=>fetch(e).then((e=>e.ok ? e.blob() : Promise.reject(new Error("Error " + e.status + " downloading image"))), (()=>Promise.reject((()=>{
        const e = new Error("No access to download image");
        return e.code = 18,
        e.name = "SecurityError",
        e
    }
    )())))
      , Xa = e=>{
        const t = e.split(",")
          , n = /data:([^;]+)/.exec(t[0]);
        if (!n)
            return O.none();
        const r = n[1]
          , o = t[1]
          , s = 1024
          , a = atob(o)
          , i = a.length
          , l = Math.ceil(i / s)
          , c = new Array(l);
        for (let e = 0; e < l; ++e) {
            const t = e * s
              , n = Math.min(t + s, i)
              , r = new Array(n - t);
            for (let e = t, o = 0; e < n; ++o,
            ++e)
                r[o] = a[e].charCodeAt(0);
            c[e] = new Uint8Array(r)
        }
        return O.some(new Blob(c,{
            type: r
        }))
    }
      , Za = e=>new Promise(((t,n)=>{
        Xa(e).fold((()=>{
            n("uri is not base64: " + e)
        }
        ), t)
    }
    ))
      , Ja = (e,t,n)=>(t = t || "image/png",
    p(HTMLCanvasElement.prototype.toBlob) ? new Promise(((r,o)=>{
        e.toBlob((e=>{
            e ? r(e) : o()
        }
        ), t, n)
    }
    )) : Za(e.toDataURL(t, n)))
      , Qa = e=>(e=>{
        const t = URL.createObjectURL(e)
          , n = new Image;
        return n.src = t,
        (e=>new Promise(((t,n)=>{
            const r = ()=>{
                s(),
                t(e)
            }
              , o = [Nr(e, "load", r), Nr(e, "error", (()=>{
                s(),
                n("Unable to load data from image: " + e.dom.src)
            }
            ))]
              , s = ()=>_(o, (e=>e.unbind()));
            e.dom.complete && r()
        }
        )))(_e.fromDom(n)).then((e=>e.dom))
    }
    )(e).then((e=>{
        ti(e);
        const t = Ba(qa(e), Ka(e));
        return Ga(t).drawImage(e, 0, 0),
        t
    }
    ))
      , ei = e=>new Promise((t=>{
        const n = new FileReader;
        n.onloadend = ()=>{
            t(n.result)
        }
        ,
        n.readAsDataURL(e)
    }
    ))
      , ti = e=>{
        URL.revokeObjectURL(e.src)
    }
      , ni = (e,t,n)=>{
        const r = t.type
          , o = v(r)
          , s = v(n)
          , a = (t,n)=>e.then((e=>((e,t,n)=>(t = t || "image/png",
        e.toDataURL(t, n)))(e, t, n)));
        return {
            getType: o,
            toBlob: ()=>Promise.resolve(t),
            toDataURL: s,
            toBase64: ()=>n.split(",")[1],
            toAdjustedBlob: (t,n)=>e.then((e=>Ja(e, t, n))),
            toAdjustedDataURL: a,
            toAdjustedBase64: (e,t)=>a(e, t).then((e=>e.split(",")[1])),
            toCanvas: ()=>e.then($a)
        }
    }
      , ri = (e,t)=>Ja(e, t).then((t=>ni(Promise.resolve(e), t, e.toDataURL())))
      , oi = (e,t,n)=>{
        const r = qa(e)
          , o = Ka(e);
        let s = t / r
          , a = n / o
          , i = !1;
        (s < .5 || s > 2) && (s = s < .5 ? .5 : 2,
        i = !0),
        (a < .5 || a > 2) && (a = a < .5 ? .5 : 2,
        i = !0);
        const l = si(e, s, a);
        return i ? l.then((e=>oi(e, t, n))) : l
    }
      , si = (e,t,n)=>new Promise((r=>{
        const o = qa(e)
          , s = Ka(e)
          , a = Math.floor(o * t)
          , i = Math.floor(s * n)
          , l = Ba(a, i);
        Ga(l).drawImage(e, 0, 0, o, s, 0, 0, a, i),
        r(l)
    }
    ))
      , ai = (e,t=2)=>{
        const n = Math.pow(10, t)
          , r = Math.round(e * n);
        return Math.ceil(r / n)
    }
      , ii = (e,t,n,r,o)=>((e,t,n,r,o)=>e.toCanvas().then((s=>((e,t,n,r,o,s)=>{
        const a = Ba(o, s);
        return Ga(a).drawImage(e, -n, -r),
        ri(a, t)
    }
    )(s, e.getType(), t, n, r, o))))(e, t, n, r, o)
      , li = (e,t)=>((e,t)=>e.toCanvas().then((n=>((e,t,n)=>{
        const r = (n < 0 ? 360 + n : n) * Math.PI / 180
          , o = e.width
          , s = e.height
          , a = Math.sin(r)
          , i = Math.cos(r)
          , l = ai(Math.abs(o * i) + Math.abs(s * a))
          , c = ai(Math.abs(o * a) + Math.abs(s * i))
          , m = Ba(l, c)
          , d = Ga(m);
        return d.translate(l / 2, c / 2),
        d.rotate(r),
        d.drawImage(e, -o / 2, -s / 2),
        ri(m, t)
    }
    )(n, e.getType(), t))))(e, t)
      , ci = (e,t)=>((e,t)=>ni(Qa(e), e, t))(e, t)
      , mi = e=>(e=>(e=>{
        const t = e.src;
        return 0 === t.indexOf("data:") ? Za(t) : Ya(t)
    }
    )(e).then((e=>(e=>ei(e).then((t=>ni(Qa(e), e, t))))(e))))(e)
      , di = e=>e.toBlob()
      , ui = e=>e.toDataURL()
      , pi = e=>parseInt(e, 10)
      , gi = e=>e.isPx && (e.cropWidth !== e.width || e.cropHeight !== e.height)
      , fi = /rotate\((\d\.\d+)rad\)/
      , hi = (e,t,n)=>mi(e.dom).then((e=>t=>((e,t,n)=>((e,t,n)=>e.toCanvas().then((r=>oi(r, t, n).then((t=>ri(t, e.getType()))))))(e, t, n))(t, e.width, e.height))(t)).then(((e,t)=>n=>{
        if (gi(t)) {
            const r = -1 * pi(Wn(e, "margin-top"))
              , o = -1 * pi(Wn(e, "margin-left"));
            return ii(n, o, r, t.cropWidth, t.cropHeight).then((n=>(Sn(e, {
                width: t.cropWidth,
                height: t.cropHeight
            }),
            n)))
        }
        return Promise.resolve(n)
    }
    )(e, t)).then(((e,t)=>n=>(e=>{
        const t = Wn(e, "transform");
        return O.from(fi.exec(t)).map((e=>Math.round(parseFloat(e[1]) * (180 / Math.PI))))
    }
    )(t).fold((()=>Promise.resolve(n)), (r=>li(n, r).then((n=>(Vn(t, "transform"),
    kn(e, "width"),
    kn(e, "height"),
    n))))))(e, n)).then((t=>{
        const n = ui(t);
        return In(e, "src", n),
        Promise.resolve()
    }
    ))
      , vi = e=>jt(e).filter(ke("span")).map((t=>{
        const n = ()=>((e,t)=>{
            var n, r, o;
            Vn(e, "margin-top"),
            Vn(e, "margin-left"),
            Vn(t, "width"),
            Vn(t, "height"),
            Vn(t, "overflow"),
            Vn(t, "display"),
            r = e,
            o = ["transform"],
            Se(n = t) && Se(r) && _(o, (e=>{
                ((e,t,n)=>{
                    $n(e, n).each((e=>{
                        $n(t, n).isNone() && Hn(t, n, e)
                    }
                    ))
                }
                )(n, r, e)
            }
            )),
            Vn(t, "transform")
        }
        )(e, t)
          , r = ((e,t)=>{
            const n = (e,t)=>En(e, t).map(pi).filter((e=>!isNaN(e))).getOr(0)
              , r = Wn(t, "width")
              , o = Wn(t, "height")
              , s = n(e, "width")
              , a = n(e, "height")
              , i = /^\d+px$/;
            return {
                isPx: i.test(r) && i.test(o),
                cropWidth: pi(r),
                cropHeight: pi(o),
                width: s,
                height: a
            }
        }
        )(e, t);
        return (gi(r) || fi.test(Wn(t, "transform")) ? hi(e, r, t) : Promise.resolve()).then(n, n)
    }
    )).getOrThunk((()=>Promise.resolve()));
    var yi = ["body", "p", "div", "article", "aside", "figcaption", "figure", "footer", "header", "nav", "section", "ol", "ul", "li", "table", "thead", "tbody", "tfoot", "caption", "tr", "td", "th", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "pre", "address"];
    const bi = (e,t)=>F(e, (e=>e.start === t))
      , xi = (e,t,n=0)=>R(e, ((e,n)=>t(n, e.len).fold(v(e), (t=>({
        len: t.finish,
        list: e.list.concat([t])
    })))), {
        len: n,
        list: []
    }).list
      , wi = (e,t,n)=>0 === t.length ? e : U(e, (e=>{
        const r = U(t, (t=>((e,t)=>t >= e.start && t <= e.finish)(e, t) ? [t - e.start] : []));
        return r.length > 0 ? ((e,t,n)=>((e,t)=>C(e, (e=>({
            ...e,
            start: e.start + t,
            finish: e.finish + t
        }))))(n(e, t), e.start))(e, r, n) : [e]
    }
    ))
      , Ti = (e,t,n)=>({
        element: e,
        start: t,
        finish: n
    })
      , Ii = Ct([{
        include: ["item"]
    }, {
        excludeWith: ["item"]
    }, {
        excludeWithout: ["item"]
    }])
      , Si = {
        include: Ii.include,
        excludeWith: Ii.excludeWith,
        excludeWithout: Ii.excludeWithout,
        cata: (e,t,n,r)=>e.fold(t, n, r)
    }
      , Oi = Ct([{
        boundary: ["item", "universe"]
    }, {
        empty: ["item", "universe"]
    }, {
        text: ["item", "universe"]
    }, {
        nonEditable: ["item", "universe"]
    }])
      , Ei = I
      , Ni = S
      , ki = v(0)
      , Di = v(1)
      , Ai = e=>({
        ...e,
        isBoundary: ()=>e.fold(Ni, Ei, Ei, Ei),
        toText: ()=>e.fold(O.none, O.none, (e=>O.some(e)), O.none),
        is: t=>e.fold(Ei, Ei, ((e,n)=>n.eq(e, t)), Ei),
        len: ()=>e.fold(ki, Di, ((e,t)=>t.property().getText(e).length), Di)
    })
      , Ci = {
        text: h(Ai, Oi.text),
        boundary: h(Ai, Oi.boundary),
        empty: h(Ai, Oi.empty),
        nonEditable: h(Ai, Oi.empty),
        cata: (e,t,n,r,o)=>e.fold(t, n, r, o)
    }
      , _i = v([])
      , Li = (e,t,n)=>{
        if (e.property().isText(t))
            return [Ci.text(t, e)];
        if (e.property().isEmptyTag(t))
            return [Ci.empty(t, e)];
        if (e.property().isNonEditable(t))
            return [];
        if (e.property().isElement(t)) {
            const r = e.property().children(t)
              , o = e.property().isBoundary(t) ? [Ci.boundary(t, e)] : []
              , s = void 0 !== n && n(t) ? [] : U(r, (t=>Li(e, t, n)));
            return o.concat(s).concat(o)
        }
        return []
    }
      , Pi = Li
      , Ri = (e,t,n)=>{
        const r = ((e,t)=>{
            const n = [];
            let r = [];
            return _(e, (e=>{
                const o = t(e);
                Si.cata(o, (()=>{
                    r.push(e)
                }
                ), (()=>{
                    r.length > 0 && n.push(r),
                    n.push([e]),
                    r = []
                }
                ), (()=>{
                    r.length > 0 && n.push(r),
                    r = []
                }
                ))
            }
            )),
            r.length > 0 && n.push(r),
            n
        }
        )(U(t, (t=>Pi(e, t, n))), (e=>e.match({
            boundary: ()=>Si.excludeWithout(e),
            empty: ()=>Si.excludeWith(e),
            text: ()=>Si.include(e),
            nonEditable: ()=>Si.excludeWithout(e)
        })));
        return P(r, (e=>e.length > 0))
    }
      , Mi = (e,t,n)=>{
        const r = U(n, (e=>[e.start, e.finish]))
          , o = wi(t, r, ((t,n)=>((e,t,n)=>{
            const r = e.property().getText(t)
              , o = P(((e,t)=>{
                if (0 === t.length)
                    return [e];
                const n = R(t, ((t,n)=>{
                    if (0 === n)
                        return t;
                    const r = e.substring(t.prev, n);
                    return {
                        prev: n,
                        values: t.values.concat([r])
                    }
                }
                ), {
                    prev: 0,
                    values: []
                })
                  , r = t[t.length - 1];
                return r < e.length ? n.values.concat(e.substring(r)) : n.values
            }
            )(r, n), (e=>e.length > 0));
            if (o.length <= 1)
                return [Ti(t, 0, r.length)];
            e.property().setText(t, o[0]);
            const s = xi(o.slice(1), ((t,n)=>{
                const r = e.create().text(t)
                  , o = Ti(r, n, n + t.length);
                return O.some(o)
            }
            ), o[0].length)
              , a = C(s, (e=>e.element));
            return e.insert().afterAll(t, a),
            [Ti(t, 0, o[0].length)].concat(s)
        }
        )(e, t.element, n)));
        return C(n, (t=>{
            const n = ((e,t,n)=>{
                const r = bi(e, t)
                  , o = bi(e, n);
                return r.bind((t=>{
                    const r = o.getOr(((e,t)=>e[e.length - 1] && e[e.length - 1].finish === t ? e.length + 1 : -1)(e, n));
                    return r > -1 ? O.some(e.slice(t, r)) : O.none()
                }
                )).getOr([])
            }
            )(o, t.start, t.finish)
              , r = C(n, (e=>e.element))
              , s = C(r, e.property().getText).join("");
            return {
                elements: r,
                word: t.word,
                exact: s
            }
        }
        ))
    }
      , Fi = (e,t,n,r)=>{
        const o = Ri(e, t, r)
          , s = U(o, (t=>{
            const r = U(t, (e=>e.fold(_i, _i, (e=>[e]), _i)))
              , o = ((e,t)=>{
                const n = U(t, (t=>{
                    const n = ((e,t)=>{
                        const n = t.term()
                          , r = [];
                        let o = n.exec(e);
                        for (; o; ) {
                            const s = o.index + t.prefix(o)
                              , a = o[0].length - t.prefix(o) - t.suffix(o);
                            r.push({
                                start: s,
                                finish: s + a
                            }),
                            n.lastIndex = s + a,
                            o = n.exec(e)
                        }
                        return r
                    }
                    )(e, t.pattern);
                    return C(n, (e=>({
                        ...t,
                        ...e
                    })))
                }
                ));
                return (e=>{
                    const t = Array.prototype.slice.call(e, 0);
                    return t.sort(((e,t)=>e.start < t.start ? -1 : t.start < e.start ? 1 : 0)),
                    t
                }
                )(n)
            }
            )(C(r, e.property().getText).join(""), n)
              , s = ((e,t)=>xi(t, ((t,n)=>{
                const r = n + e.property().getText(t).length;
                return O.from(Ti(t, n, r))
            }
            )))(e, r);
            return Mi(e, s, o)
        }
        ));
        return s
    }
      , ji = {
        up: v({
            selector: Qn,
            closest: er,
            predicate: Xn,
            all: (e,t)=>{
                const n = p(t) ? t : I;
                let r = e.dom;
                const o = [];
                for (; null !== r.parentNode && void 0 !== r.parentNode; ) {
                    const e = r.parentNode
                      , t = _e.fromDom(e);
                    if (o.push(t),
                    !0 === n(t))
                        break;
                    r = e
                }
                return o
            }
        }),
        down: v({
            selector: Yt,
            predicate: Kt
        }),
        styles: v({
            get: Wn,
            getRaw: $n,
            set: Hn,
            remove: Vn
        }),
        attrs: v({
            get: On,
            set: In,
            remove: kn,
            copyTo: (e,t)=>{
                const n = R(e.dom.attributes, ((e,t)=>(e[t.name] = t.value,
                e)), {});
                Sn(t, n)
            }
        }),
        insert: v({
            before: cn,
            after: mn,
            afterAll: gn,
            append: un,
            appendAll: fn,
            prepend: dn,
            wrap: pn
        }),
        remove: v({
            unwrap: yn,
            remove: vn
        }),
        create: v({
            nu: _e.fromTag,
            clone: e=>_e.fromDom(e.dom.cloneNode(!1)),
            text: _e.fromText
        }),
        query: v({
            comparePosition: (e,t)=>e.dom.compareDocumentPosition(t.dom),
            prevSibling: Ut,
            nextSibling: Ht
        }),
        property: v({
            children: Wt,
            name: xe,
            parent: jt,
            document: e=>Mt(e).dom,
            isText: Oe,
            isComment: Ie,
            isElement: Se,
            isSpecial: e=>{
                const t = xe(e);
                return D(["script", "noscript", "iframe", "noframes", "noembed", "title", "style", "textarea", "xmp"], t)
            }
            ,
            getLanguage: e=>Se(e) ? En(e, "lang") : O.none(),
            getText: $s,
            setText: (e,t)=>Bs.set(e, t),
            isBoundary: e=>!!Se(e) && ("body" === xe(e) || D(yi, xe(e))),
            isEmptyTag: e=>!!Se(e) && D(["br", "img", "hr", "input"], xe(e)),
            isNonEditable: e=>Se(e) && "false" === On(e, "contenteditable")
        }),
        eq: Nt,
        is: kt
    }
      , Ui = /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g.source
      , Hi = e=>!er(e, "a", undefined).isSome()
      , zi = (e,t)=>{
        const n = (e=>{
            return ((e,t,n)=>Fi(ji, e, t, void 0))(e, [{
                word: "__INTERNAL__",
                pattern: (t = Ui,
                ((e,t,n,r)=>({
                    term: ()=>new RegExp(e,r.getOr("g")),
                    prefix: t,
                    suffix: n
                }))(t, v(0), v(0), O.none()))
            }]);
            var t
        }
        )(e);
        _(n, (e=>{
            const n = e.exact;
            if (n.indexOf("@") < 0 || Wi(n)) {
                const r = de(n, "://") ? n : `${t.defaultProtocol}://${n}`;
                ((e,t)=>{
                    O.from(e[0]).filter(Hi).map((n=>{
                        const r = _e.fromTag("a");
                        return cn(n, r),
                        fn(r, e),
                        In(r, "href", t),
                        r
                    }
                    ))
                }
                )(e.elements, r)
            }
        }
        ))
    }
      , Wi = e=>{
        const t = e.indexOf("://");
        return t >= 3 && t <= 9
    }
      , Bi = (e,t)=>{
        _(e, (e=>{
            Se(e) && $n(e, "position").isSome() && Vn(e, "position")
        }
        ))
    }
      , $i = (e,t)=>{
        const n = P(e, ke("li"));
        if (n.length > 0) {
            const t = zt(n[0])
              , r = _e.fromTag("ul");
            if (cn(e[0], r),
            t.length > 0) {
                const e = _e.fromTag("li");
                un(r, e),
                fn(e, t)
            }
            fn(r, n)
        }
    }
      , Gi = (e,t)=>{
        const n = Wt(e);
        _([zi, Bi, $i], (e=>{
            e(n, t)
        }
        ))
    }
      , Vi = {
        disabled: ()=>({
            discriminator: "disabled",
            data: {}
        }),
        fromClipboard: e=>({
            discriminator: "fromClipboard",
            data: {
                rtf: e
            }
        })
    }
      , qi = ft(Vi)
      , Ki = Vi.disabled
      , Yi = Vi.fromClipboard
      , Xi = e=>void 0 !== e && void 0 !== e.types && null !== e.types
      , Zi = (e,t)=>{
        const n = new RegExp(t,"i");
        return B(e, (e=>Mn(null !== n.exec(e), {
            type: e,
            flavor: t
        })))
    }
    ;
    function Ji(e) {
        return Ji = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        ,
        Ji(e)
    }
    function Qi(e, t) {
        return Qi = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t,
            e
        }
        ,
        Qi(e, t)
    }
    function el() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
            return !1;
        if (Reflect.construct.sham)
            return !1;
        if ("function" == typeof Proxy)
            return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
            ))),
            !0
        } catch (e) {
            return !1
        }
    }
    function tl(e, t, n) {
        return tl = el() ? Reflect.construct : function(e, t, n) {
            var r = [null];
            r.push.apply(r, t);
            var o = new (Function.bind.apply(e, r));
            return n && Qi(o, n.prototype),
            o
        }
        ,
        tl.apply(null, arguments)
    }
    function nl(e) {
        return function(e) {
            if (Array.isArray(e))
                return rl(e)
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                return Array.from(e)
        }(e) || function(e, t) {
            if (e) {
                if ("string" == typeof e)
                    return rl(e, t);
                var n = Object.prototype.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name),
                "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? rl(e, t) : void 0
            }
        }(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function rl(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++)
            r[n] = e[n];
        return r
    }
    var ol = Object.hasOwnProperty
      , sl = Object.setPrototypeOf
      , al = Object.isFrozen
      , il = Object.getPrototypeOf
      , ll = Object.getOwnPropertyDescriptor
      , cl = Object.freeze
      , ml = Object.seal
      , dl = Object.create
      , ul = "undefined" != typeof Reflect && Reflect
      , pl = ul.apply
      , gl = ul.construct;
    pl || (pl = function(e, t, n) {
        return e.apply(t, n)
    }
    ),
    cl || (cl = function(e) {
        return e
    }
    ),
    ml || (ml = function(e) {
        return e
    }
    ),
    gl || (gl = function(e, t) {
        return tl(e, nl(t))
    }
    );
    var fl, hl = El(Array.prototype.forEach), vl = El(Array.prototype.pop), yl = El(Array.prototype.push), bl = El(String.prototype.toLowerCase), xl = El(String.prototype.match), wl = El(String.prototype.replace), Tl = El(String.prototype.indexOf), Il = El(String.prototype.trim), Sl = El(RegExp.prototype.test), Ol = (fl = TypeError,
    function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        return gl(fl, t)
    }
    );
    function El(e) {
        return function(t) {
            for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
                r[o - 1] = arguments[o];
            return pl(e, t, r)
        }
    }
    function Nl(e, t) {
        sl && sl(e, null);
        for (var n = t.length; n--; ) {
            var r = t[n];
            if ("string" == typeof r) {
                var o = bl(r);
                o !== r && (al(t) || (t[n] = o),
                r = o)
            }
            e[r] = !0
        }
        return e
    }
    function kl(e) {
        var t, n = dl(null);
        for (t in e)
            pl(ol, e, [t]) && (n[t] = e[t]);
        return n
    }
    function Dl(e, t) {
        for (; null !== e; ) {
            var n = ll(e, t);
            if (n) {
                if (n.get)
                    return El(n.get);
                if ("function" == typeof n.value)
                    return El(n.value)
            }
            e = il(e)
        }
        return function(e) {
            return console.warn("fallback value for", e),
            null
        }
    }
    var Al = cl(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"])
      , Cl = cl(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"])
      , _l = cl(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"])
      , Ll = cl(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"])
      , Pl = cl(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"])
      , Rl = cl(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"])
      , Ml = cl(["#text"])
      , Fl = cl(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"])
      , jl = cl(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"])
      , Ul = cl(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"])
      , Hl = cl(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"])
      , zl = ml(/\{\{[\w\W]*|[\w\W]*\}\}/gm)
      , Wl = ml(/<%[\w\W]*|[\w\W]*%>/gm)
      , Bl = ml(/^data-[\-\w.\u00B7-\uFFFF]/)
      , $l = ml(/^aria-[\-\w]+$/)
      , Gl = ml(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i)
      , Vl = ml(/^(?:\w+script|data):/i)
      , ql = ml(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g)
      , Kl = ml(/^html$/i)
      , Yl = function() {
        return "undefined" == typeof window ? null : window
    }
      , Xl = function(e, t) {
        if ("object" !== Ji(e) || "function" != typeof e.createPolicy)
            return null;
        var n = null
          , r = "data-tt-policy-suffix";
        t.currentScript && t.currentScript.hasAttribute(r) && (n = t.currentScript.getAttribute(r));
        var o = "dompurify" + (n ? "#" + n : "");
        try {
            return e.createPolicy(o, {
                createHTML: function(e) {
                    return e
                }
            })
        } catch (e) {
            return console.warn("TrustedTypes policy " + o + " could not be created."),
            null
        }
    }
      , Zl = function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yl()
          , n = function(t) {
            return e(t)
        };
        if (n.version = "2.3.8",
        n.removed = [],
        !t || !t.document || 9 !== t.document.nodeType)
            return n.isSupported = !1,
            n;
        var r = t.document
          , o = t.document
          , s = t.DocumentFragment
          , a = t.HTMLTemplateElement
          , i = t.Node
          , l = t.Element
          , c = t.NodeFilter
          , m = t.NamedNodeMap
          , d = void 0 === m ? t.NamedNodeMap || t.MozNamedAttrMap : m
          , u = t.HTMLFormElement
          , p = t.DOMParser
          , g = t.trustedTypes
          , f = l.prototype
          , h = Dl(f, "cloneNode")
          , v = Dl(f, "nextSibling")
          , y = Dl(f, "childNodes")
          , b = Dl(f, "parentNode");
        if ("function" == typeof a) {
            var x = o.createElement("template");
            x.content && x.content.ownerDocument && (o = x.content.ownerDocument)
        }
        var w = Xl(g, r)
          , T = w ? w.createHTML("") : ""
          , I = o
          , S = I.implementation
          , O = I.createNodeIterator
          , E = I.createDocumentFragment
          , N = I.getElementsByTagName
          , k = r.importNode
          , D = {};
        try {
            D = kl(o).documentMode ? o.documentMode : {}
        } catch (e) {}
        var A = {};
        n.isSupported = "function" == typeof b && S && void 0 !== S.createHTMLDocument && 9 !== D;
        var C, _, L = zl, P = Wl, R = Bl, M = $l, F = Vl, j = ql, U = Gl, H = null, z = Nl({}, [].concat(nl(Al), nl(Cl), nl(_l), nl(Pl), nl(Ml))), W = null, B = Nl({}, [].concat(nl(Fl), nl(jl), nl(Ul), nl(Hl))), $ = Object.seal(Object.create(null, {
            tagNameCheck: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: null
            },
            attributeNameCheck: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: null
            },
            allowCustomizedBuiltInElements: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: !1
            }
        })), G = null, V = null, q = !0, K = !0, Y = !1, X = !1, Z = !1, J = !1, Q = !1, ee = !1, te = !1, ne = !1, re = !0, oe = !0, se = !1, ae = {}, ie = null, le = Nl({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), ce = null, me = Nl({}, ["audio", "video", "img", "source", "image", "track"]), de = null, ue = Nl({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), pe = "http://www.w3.org/1998/Math/MathML", ge = "http://www.w3.org/2000/svg", fe = "http://www.w3.org/1999/xhtml", he = fe, ve = !1, ye = ["application/xhtml+xml", "text/html"], be = "text/html", xe = null, we = o.createElement("form"), Te = function(e) {
            return e instanceof RegExp || e instanceof Function
        }, Ie = function(e) {
            xe && xe === e || (e && "object" === Ji(e) || (e = {}),
            e = kl(e),
            H = "ALLOWED_TAGS"in e ? Nl({}, e.ALLOWED_TAGS) : z,
            W = "ALLOWED_ATTR"in e ? Nl({}, e.ALLOWED_ATTR) : B,
            de = "ADD_URI_SAFE_ATTR"in e ? Nl(kl(ue), e.ADD_URI_SAFE_ATTR) : ue,
            ce = "ADD_DATA_URI_TAGS"in e ? Nl(kl(me), e.ADD_DATA_URI_TAGS) : me,
            ie = "FORBID_CONTENTS"in e ? Nl({}, e.FORBID_CONTENTS) : le,
            G = "FORBID_TAGS"in e ? Nl({}, e.FORBID_TAGS) : {},
            V = "FORBID_ATTR"in e ? Nl({}, e.FORBID_ATTR) : {},
            ae = "USE_PROFILES"in e && e.USE_PROFILES,
            q = !1 !== e.ALLOW_ARIA_ATTR,
            K = !1 !== e.ALLOW_DATA_ATTR,
            Y = e.ALLOW_UNKNOWN_PROTOCOLS || !1,
            X = e.SAFE_FOR_TEMPLATES || !1,
            Z = e.WHOLE_DOCUMENT || !1,
            ee = e.RETURN_DOM || !1,
            te = e.RETURN_DOM_FRAGMENT || !1,
            ne = e.RETURN_TRUSTED_TYPE || !1,
            Q = e.FORCE_BODY || !1,
            re = !1 !== e.SANITIZE_DOM,
            oe = !1 !== e.KEEP_CONTENT,
            se = e.IN_PLACE || !1,
            U = e.ALLOWED_URI_REGEXP || U,
            he = e.NAMESPACE || fe,
            e.CUSTOM_ELEMENT_HANDLING && Te(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && ($.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck),
            e.CUSTOM_ELEMENT_HANDLING && Te(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && ($.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),
            e.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && ($.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),
            C = C = -1 === ye.indexOf(e.PARSER_MEDIA_TYPE) ? be : e.PARSER_MEDIA_TYPE,
            _ = "application/xhtml+xml" === C ? function(e) {
                return e
            }
            : bl,
            X && (K = !1),
            te && (ee = !0),
            ae && (H = Nl({}, nl(Ml)),
            W = [],
            !0 === ae.html && (Nl(H, Al),
            Nl(W, Fl)),
            !0 === ae.svg && (Nl(H, Cl),
            Nl(W, jl),
            Nl(W, Hl)),
            !0 === ae.svgFilters && (Nl(H, _l),
            Nl(W, jl),
            Nl(W, Hl)),
            !0 === ae.mathMl && (Nl(H, Pl),
            Nl(W, Ul),
            Nl(W, Hl))),
            e.ADD_TAGS && (H === z && (H = kl(H)),
            Nl(H, e.ADD_TAGS)),
            e.ADD_ATTR && (W === B && (W = kl(W)),
            Nl(W, e.ADD_ATTR)),
            e.ADD_URI_SAFE_ATTR && Nl(de, e.ADD_URI_SAFE_ATTR),
            e.FORBID_CONTENTS && (ie === le && (ie = kl(ie)),
            Nl(ie, e.FORBID_CONTENTS)),
            oe && (H["#text"] = !0),
            Z && Nl(H, ["html", "head", "body"]),
            H.table && (Nl(H, ["tbody"]),
            delete G.tbody),
            cl && cl(e),
            xe = e)
        }, Se = Nl({}, ["mi", "mo", "mn", "ms", "mtext"]), Oe = Nl({}, ["foreignobject", "desc", "title", "annotation-xml"]), Ee = Nl({}, ["title", "style", "font", "a", "script"]), Ne = Nl({}, Cl);
        Nl(Ne, _l),
        Nl(Ne, Ll);
        var ke = Nl({}, Pl);
        Nl(ke, Rl);
        var De = function(e) {
            var t = b(e);
            t && t.tagName || (t = {
                namespaceURI: fe,
                tagName: "template"
            });
            var n = bl(e.tagName)
              , r = bl(t.tagName);
            return e.namespaceURI === ge ? t.namespaceURI === fe ? "svg" === n : t.namespaceURI === pe ? "svg" === n && ("annotation-xml" === r || Se[r]) : Boolean(Ne[n]) : e.namespaceURI === pe ? t.namespaceURI === fe ? "math" === n : t.namespaceURI === ge ? "math" === n && Oe[r] : Boolean(ke[n]) : e.namespaceURI === fe && !(t.namespaceURI === ge && !Oe[r]) && !(t.namespaceURI === pe && !Se[r]) && !ke[n] && (Ee[n] || !Ne[n])
        }
          , Ae = function(e) {
            yl(n.removed, {
                element: e
            });
            try {
                e.parentNode.removeChild(e)
            } catch (t) {
                try {
                    e.outerHTML = T
                } catch (t) {
                    e.remove()
                }
            }
        }
          , Ce = function(e, t) {
            try {
                yl(n.removed, {
                    attribute: t.getAttributeNode(e),
                    from: t
                })
            } catch (e) {
                yl(n.removed, {
                    attribute: null,
                    from: t
                })
            }
            if (t.removeAttribute(e),
            "is" === e && !W[e])
                if (ee || te)
                    try {
                        Ae(t)
                    } catch (e) {}
                else
                    try {
                        t.setAttribute(e, "")
                    } catch (e) {}
        }
          , _e = function(e) {
            var t, n;
            if (Q)
                e = "<remove></remove>" + e;
            else {
                var r = xl(e, /^[\r\n\t ]+/);
                n = r && r[0]
            }
            "application/xhtml+xml" === C && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
            var s = w ? w.createHTML(e) : e;
            if (he === fe)
                try {
                    t = (new p).parseFromString(s, C)
                } catch (e) {}
            if (!t || !t.documentElement) {
                t = S.createDocument(he, "template", null);
                try {
                    t.documentElement.innerHTML = ve ? "" : s
                } catch (e) {}
            }
            var a = t.body || t.documentElement;
            return e && n && a.insertBefore(o.createTextNode(n), a.childNodes[0] || null),
            he === fe ? N.call(t, Z ? "html" : "body")[0] : Z ? t.documentElement : a
        }
          , Le = function(e) {
            return O.call(e.ownerDocument || e, e, c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT, null, !1)
        }
          , Pe = function(e) {
            return e instanceof u && ("string" != typeof e.nodeName || "string" != typeof e.textContent || "function" != typeof e.removeChild || !(e.attributes instanceof d) || "function" != typeof e.removeAttribute || "function" != typeof e.setAttribute || "string" != typeof e.namespaceURI || "function" != typeof e.insertBefore)
        }
          , Re = function(e) {
            return "object" === Ji(i) ? e instanceof i : e && "object" === Ji(e) && "number" == typeof e.nodeType && "string" == typeof e.nodeName
        }
          , Me = function(e, t, r) {
            A[e] && hl(A[e], (function(e) {
                e.call(n, t, r, xe)
            }
            ))
        }
          , Fe = function(e) {
            var t;
            if (Me("beforeSanitizeElements", e, null),
            Pe(e))
                return Ae(e),
                !0;
            if (Sl(/[\u0080-\uFFFF]/, e.nodeName))
                return Ae(e),
                !0;
            var r = _(e.nodeName);
            if (Me("uponSanitizeElement", e, {
                tagName: r,
                allowedTags: H
            }),
            e.hasChildNodes() && !Re(e.firstElementChild) && (!Re(e.content) || !Re(e.content.firstElementChild)) && Sl(/<[/\w]/g, e.innerHTML) && Sl(/<[/\w]/g, e.textContent))
                return Ae(e),
                !0;
            if ("select" === r && Sl(/<template/i, e.innerHTML))
                return Ae(e),
                !0;
            if (!H[r] || G[r]) {
                if (!G[r] && Ue(r)) {
                    if ($.tagNameCheck instanceof RegExp && Sl($.tagNameCheck, r))
                        return !1;
                    if ($.tagNameCheck instanceof Function && $.tagNameCheck(r))
                        return !1
                }
                if (oe && !ie[r]) {
                    var o = b(e) || e.parentNode
                      , s = y(e) || e.childNodes;
                    if (s && o)
                        for (var a = s.length - 1; a >= 0; --a)
                            o.insertBefore(h(s[a], !0), v(e))
                }
                return Ae(e),
                !0
            }
            return e instanceof l && !De(e) ? (Ae(e),
            !0) : "noscript" !== r && "noembed" !== r || !Sl(/<\/no(script|embed)/i, e.innerHTML) ? (X && 3 === e.nodeType && (t = e.textContent,
            t = wl(t, L, " "),
            t = wl(t, P, " "),
            e.textContent !== t && (yl(n.removed, {
                element: e.cloneNode()
            }),
            e.textContent = t)),
            Me("afterSanitizeElements", e, null),
            !1) : (Ae(e),
            !0)
        }
          , je = function(e, t, n) {
            if (re && ("id" === t || "name" === t) && (n in o || n in we))
                return !1;
            if (K && !V[t] && Sl(R, t))
                ;
            else if (q && Sl(M, t))
                ;
            else if (!W[t] || V[t]) {
                if (!(Ue(e) && ($.tagNameCheck instanceof RegExp && Sl($.tagNameCheck, e) || $.tagNameCheck instanceof Function && $.tagNameCheck(e)) && ($.attributeNameCheck instanceof RegExp && Sl($.attributeNameCheck, t) || $.attributeNameCheck instanceof Function && $.attributeNameCheck(t)) || "is" === t && $.allowCustomizedBuiltInElements && ($.tagNameCheck instanceof RegExp && Sl($.tagNameCheck, n) || $.tagNameCheck instanceof Function && $.tagNameCheck(n))))
                    return !1
            } else if (de[t])
                ;
            else if (Sl(U, wl(n, j, "")))
                ;
            else if ("src" !== t && "xlink:href" !== t && "href" !== t || "script" === e || 0 !== Tl(n, "data:") || !ce[e])
                if (Y && !Sl(F, wl(n, j, "")))
                    ;
                else if (n)
                    return !1;
            return !0
        }
          , Ue = function(e) {
            return e.indexOf("-") > 0
        }
          , He = function(e) {
            var t, r, o, s;
            Me("beforeSanitizeAttributes", e, null);
            var a = e.attributes;
            if (a) {
                var i = {
                    attrName: "",
                    attrValue: "",
                    keepAttr: !0,
                    allowedAttributes: W
                };
                for (s = a.length; s--; ) {
                    var l = t = a[s]
                      , c = l.name
                      , m = l.namespaceURI;
                    if (r = "value" === c ? t.value : Il(t.value),
                    o = _(c),
                    i.attrName = o,
                    i.attrValue = r,
                    i.keepAttr = !0,
                    i.forceKeepAttr = void 0,
                    Me("uponSanitizeAttribute", e, i),
                    r = i.attrValue,
                    !i.forceKeepAttr && (Ce(c, e),
                    i.keepAttr))
                        if (Sl(/\/>/i, r))
                            Ce(c, e);
                        else {
                            X && (r = wl(r, L, " "),
                            r = wl(r, P, " "));
                            var d = _(e.nodeName);
                            if (je(d, o, r))
                                try {
                                    m ? e.setAttributeNS(m, c, r) : e.setAttribute(c, r),
                                    vl(n.removed)
                                } catch (e) {}
                        }
                }
                Me("afterSanitizeAttributes", e, null)
            }
        }
          , ze = function e(t) {
            var n, r = Le(t);
            for (Me("beforeSanitizeShadowDOM", t, null); n = r.nextNode(); )
                Me("uponSanitizeShadowNode", n, null),
                Fe(n) || (n.content instanceof s && e(n.content),
                He(n));
            Me("afterSanitizeShadowDOM", t, null)
        };
        return n.sanitize = function(e, o) {
            var a, l, c, m, d;
            if ((ve = !e) && (e = "\x3c!--\x3e"),
            "string" != typeof e && !Re(e)) {
                if ("function" != typeof e.toString)
                    throw Ol("toString is not a function");
                if ("string" != typeof (e = e.toString()))
                    throw Ol("dirty is not a string, aborting")
            }
            if (!n.isSupported) {
                if ("object" === Ji(t.toStaticHTML) || "function" == typeof t.toStaticHTML) {
                    if ("string" == typeof e)
                        return t.toStaticHTML(e);
                    if (Re(e))
                        return t.toStaticHTML(e.outerHTML)
                }
                return e
            }
            if (J || Ie(o),
            n.removed = [],
            "string" == typeof e && (se = !1),
            se) {
                if (e.nodeName) {
                    var u = _(e.nodeName);
                    if (!H[u] || G[u])
                        throw Ol("root node is forbidden and cannot be sanitized in-place")
                }
            } else if (e instanceof i)
                1 === (l = (a = _e("\x3c!----\x3e")).ownerDocument.importNode(e, !0)).nodeType && "BODY" === l.nodeName || "HTML" === l.nodeName ? a = l : a.appendChild(l);
            else {
                if (!ee && !X && !Z && -1 === e.indexOf("<"))
                    return w && ne ? w.createHTML(e) : e;
                if (!(a = _e(e)))
                    return ee ? null : ne ? T : ""
            }
            a && Q && Ae(a.firstChild);
            for (var p = Le(se ? e : a); c = p.nextNode(); )
                3 === c.nodeType && c === m || Fe(c) || (c.content instanceof s && ze(c.content),
                He(c),
                m = c);
            if (m = null,
            se)
                return e;
            if (ee) {
                if (te)
                    for (d = E.call(a.ownerDocument); a.firstChild; )
                        d.appendChild(a.firstChild);
                else
                    d = a;
                return W.shadowroot && (d = k.call(r, d, !0)),
                d
            }
            var g = Z ? a.outerHTML : a.innerHTML;
            return Z && H["!doctype"] && a.ownerDocument && a.ownerDocument.doctype && a.ownerDocument.doctype.name && Sl(Kl, a.ownerDocument.doctype.name) && (g = "<!DOCTYPE " + a.ownerDocument.doctype.name + ">\n" + g),
            X && (g = wl(g, L, " "),
            g = wl(g, P, " ")),
            w && ne ? w.createHTML(g) : g
        }
        ,
        n.setConfig = function(e) {
            Ie(e),
            J = !0
        }
        ,
        n.clearConfig = function() {
            xe = null,
            J = !1
        }
        ,
        n.isValidAttribute = function(e, t, n) {
            xe || Ie({});
            var r = _(e)
              , o = _(t);
            return je(r, o, n)
        }
        ,
        n.addHook = function(e, t) {
            "function" == typeof t && (A[e] = A[e] || [],
            yl(A[e], t))
        }
        ,
        n.removeHook = function(e) {
            if (A[e])
                return vl(A[e])
        }
        ,
        n.removeHooks = function(e) {
            A[e] && (A[e] = [])
        }
        ,
        n.removeAllHooks = function() {
            A = {}
        }
        ,
        n
    }();
    const Jl = ["script", "svg"]
      , Ql = e=>-1 !== e.lastIndexOf("</html>")
      , ec = e=>({
        sanitizeHtml: (t,n)=>e(t) ? t : ((e,t)=>{
            Zl.addHook("uponSanitizeElement", ((e,t)=>{
                D(Jl, t.tagName) || Tt(t.allowedTags, t.tagName) || (t.allowedTags[t.tagName] = !0)
            }
            )),
            Zl.addHook("uponSanitizeAttribute", ((e,t)=>{
                0 === t.attrName.indexOf("on") || Tt(t.allowedAttributes, t.attrName) || (t.allowedAttributes[t.attrName] = !0),
                t.attrValue && -1 !== t.attrValue.indexOf("\n") && (t.attrValue = t.attrValue.replace(/\r?\n/g, ""))
            }
            ));
            const n = (e=>ue(ge(e), "<!"))(e)
              , r = n ? `<body>${e}</body>` : (e=>e.replace(/^[\S\s]*?(<!DOCTYPE|<html)/i, "$1"))(e)
              , o = Zl.sanitize(r, {
                ALLOW_UNKNOWN_PROTOCOLS: !0,
                FORBID_TAGS: Jl,
                WHOLE_DOCUMENT: Ql(e)
            });
            return Zl.removeHook("uponSanitizeElement"),
            Zl.removeHook("uponSanitizeAttribute"),
            n ? (s = me(o, "<body>"),
            pe(s, "</body>") ? ((e,t)=>e.substring(0, e.length - t))(s, "</body>".length) : s) : o;
            var s
        }
        )(t),
        sanitizeText: y
    })
      , tc = {
        sanitizeHtml: y,
        sanitizeText: y
    }
      , nc = e=>t=>({
        discriminator: e,
        data: t
    })
      , rc = e=>t=>t.discriminator === e ? O.some(t.data) : O.none()
      , oc = nc("event")
      , sc = nc("html")
      , ac = nc("images")
      , ic = nc("word")
      , lc = nc("text")
      , cc = nc("void")
      , mc = rc("html")
      , dc = rc("images")
      , uc = rc("word")
      , pc = rc("text")
      , gc = ["^image/", "file"]
      , fc = e=>(e=>de(e, "<html") && (de(e, 'xmlns:o="urn:schemas-microsoft-com:office:office"') || de(e, 'xmlns:x="urn:schemas-microsoft-com:office:excel"')))(e) || (e=>de(e, 'meta name="ProgId" content="Word.Document"'))(e)
      , hc = e=>de(e, 'id="docs-internal-guid-')
      , vc = e=>e.length > 0
      , yc = (e,t)=>Zi(e.types, t).map((t=>e.getData(t.type))).filter(vc)
      , bc = e=>yc(e, "html")
      , xc = e=>bc(e).filter(hc)
      , wc = e=>O.from(e.clipboardData).filter(Xi)
      , Tc = e=>{
        const t = _e.fromTag("div")
          , n = ((e,t)=>To(e, t, [wa]))(Rt(t), e);
        return ((e,t)=>{
            const n = Rt(e).dom
              , r = _e.fromDom(n.createDocumentFragment())
              , o = Kn(t, n);
            fn(r, o),
            hn(e),
            un(e, r)
        }
        )(t, n),
        sc({
            container: t
        })
    }
      , Ic = {
        native: "Outside of Textbox.io pasting HTML5 API (could be internal)",
        fallback: "Outside of Textbox.io pasting offscreen (could be internal)",
        msoffice: "Word Import pasting",
        googledocs: "Google Docs pasting",
        image: "Image pasting",
        plaintext: "Only plain text is available to paste",
        text: "Plain text pasting",
        none: "There is no valid way to paste",
        discard: "There is no valid way to paste, discarding content"
    }
      , Sc = {
        getLabelForApi: e=>{
            const t = ft(Ic);
            return M(t, (t=>Ic[t] === e)).fold(v("unknown"), (e=>{
                switch (e) {
                case "native":
                case "fallback":
                    return "html";
                case "none":
                case "discard":
                    return "invalid";
                default:
                    return e
                }
            }
            ))
        }
        ,
        ...Ic
    }
      , Oc = e=>C(e, (e=>e.asset))
      , Ec = (e,t,n)=>{
        const r = It({
            cancel: gt([]),
            error: gt(["message"]),
            insert: gt(["elements", "assets", "correlated", "isInternal", "source", "mode"]),
            block: gt(["state"])
        });
        let o = !1;
        r.registry.block.bind((e=>o = e.state));
        const s = (n,o)=>{
            r.trigger.block(!0);
            const s = ((e,t,n)=>{
                const r = ((e,t)=>B(e, (e=>e.getAvailable(t).map((t=>Gr(e.steps, t, e.label, e.capture()))))))(e, n);
                return r.getOrThunk((()=>{
                    const e = t.getAvailable(n);
                    return Gr(t.steps, e, t.label, t.capture())
                }
                ))
            }
            )(e, t, n);
            s.capture && o();
            const a = ((e,t)=>{
                const n = {
                    response: Rr([], []),
                    bundle: Hr({})
                }
                  , r = R(e, ((e,n)=>$r(e) ? e.then((e=>qr(e, t, n))) : qr(e, t, n)), n);
                return $r(r) ? r : Promise.resolve(r)
            }
            )(s.steps, s.input)
              , i = Sc.getLabelForApi(s.label);
            a.then((e=>{
                const t = e.bundle.isInternal.getOr(!1)
                  , n = e.bundle.officeStyles.fold(v("auto"), (e=>e ? "merge" : "clean"));
                r.trigger.block(!1),
                Lr(e.response, (e=>{
                    r.trigger.error(e)
                }
                ), ((e,o)=>{
                    r.trigger.insert(e, Oc(o), o, t, i, n)
                }
                ), (()=>{
                    r.trigger.cancel()
                }
                ), ((e,o,s)=>{
                    r.trigger.insert(e, Oc(o), o, t, i, n),
                    r.trigger.error(s)
                }
                ))
            }
            ))
        }
        ;
        return {
            paste: e=>{
                const t = Ft(_e.fromDom(e.target));
                ln(t.dom).each((t=>{
                    if (!Pn(t.start, sr())) {
                        const t = ((e,t=tc)=>{
                            const n = e=>{
                                return void 0 === e.items ? O.none() : (t = gc,
                                n = e.types,
                                B(t, (e=>Zi(n, e)))).map((t=>{
                                    const n = [];
                                    for (let t = 0; t < e.items.length; t++)
                                        n.push(e.items[t]);
                                    return ac({
                                        images: n
                                    })
                                }
                                ));
                                var t, n
                            }
                              , r = e=>B(e.types, (n=>"text/plain" === n ? O.some(e.getData(n)).map((e=>lc({
                                text: t.sanitizeText(e)
                            }))) : O.none()));
                            return {
                                getWordData: ()=>wc(e).bind((e=>(e=>bc(e).filter(fc))(e).map((t=>{
                                    const n = (e=>yc(e, "rtf"))(e);
                                    return ic({
                                        html: t,
                                        rtf: n.fold((()=>Ki()), (e=>Yi(e)))
                                    })
                                }
                                )))),
                                getGoogleDocsData: ()=>wc(e).bind(xc).map((e=>t.sanitizeHtml(e, "googledocs"))).map(Tc),
                                getImage: ()=>wc(e).bind(n),
                                getText: ()=>wc(e).bind(r),
                                getHtml: ()=>wc(e).bind(bc).map(t.sanitizeHtml).map(Tc),
                                getOnlyText: ()=>wc(e).bind((e=>{
                                    return 1 === (t = e.types).length && "text/plain" === t[0] ? r(e) : O.none();
                                    var t
                                }
                                )),
                                getNative: ()=>oc({
                                    nativeEvent: e
                                }),
                                getVoid: ()=>cc({})
                            }
                        }
                        )(e, n);
                        s(t, (()=>{
                            e.preventDefault()
                        }
                        ))
                    }
                }
                ))
            }
            ,
            pasteCustom: (e,t=f)=>{
                s(e, t)
            }
            ,
            isBlocked: ()=>o,
            destroy: f,
            events: r.registry
        }
    }
      , Nc = e=>ei(e);
    var kc = {
        cata: (e,t,n)=>e.fold(t, n),
        ...Ct([{
            blob: ["id", "imageresult", "objurl"]
        }, {
            url: ["id", "url", "raw"]
        }])
    };
    const Dc = e=>{
        const t = URL.createObjectURL(e);
        return Ac(e, t)
    }
      , Ac = (e,t)=>yr((n=>{
        Nc(e).then((r=>{
            const o = ci(e, r)
              , s = wn("image")
              , a = kc.blob(s, o, t);
            n(a)
        }
        ))
    }
    ))
      , Cc = e=>br(C(e, Dc))
      , _c = (e,t)=>({
        asset: e,
        image: t
    })
      , Lc = (e,t)=>kc.cata(e, ((e,n,r)=>(In(t, "src", r),
    !0)), I)
      , Pc = (e,t)=>{
        const n = [];
        return _(e, ((e,r)=>{
            const o = t[r];
            Lc(e, o) && n.push(_c(e, o))
        }
        )),
        n
    }
      , Rc = e=>Dc(e).toPromise()
      , Mc = (e,t)=>({
        asyncAsset: e.then(Ir.value, Ir.error),
        image: t
    })
      , Fc = e=>{
        const t = _e.fromTag("div");
        return fn(t, e),
        Yt(t, "img[src]")
    }
      , jc = e=>0 === e.indexOf("data:") && e.indexOf("base64") > -1
      , Uc = e=>0 === e.indexOf("blob:")
      , Hc = e=>En(e, "src").exists((e=>jc(e) || Uc(e)))
      , zc = e=>U(Fc(e), (e=>{
        const t = En(e, "src").getOr("");
        return jc(t) ? ((e,t)=>{
            return (n = t,
            Xa(n)).map((t=>Mc(Rc(t), e)));
            var n
        }
        )(e, t).toArray() : Uc(t) ? ((e,t)=>{
            return (n = t,
            O.from(0 === (r = n).indexOf("blob:") ? Ya(r) : 0 === r.indexOf("data:") ? Za(r) : null)).map((t=>{
                const n = t.then(Rc);
                return Mc(n, e)
            }
            ));
            var n, r
        }
        )(e, t).toArray() : []
    }
    ))
      , Wc = e=>{
        const t = P(e, (e=>!ke("img")(e) || !Hc(e)));
        return Fr(t, [], "errors.local.images.disallowed")
    }
    ;
    var Bc = e=>(t,n)=>{
        const r = ()=>Promise.resolve(n)
          , o = (t,o)=>!1 === e.allowLocalImages ? (e=>{
            const t = P(Fc(e), Hc);
            return _(t, vn),
            Promise.resolve({
                response: t.length > 0 ? Wc(e) : n.response,
                bundle: n.bundle
            })
        }
        )(t) : 0 === o.length ? (e=>{
            const t = zc(e)
              , r = Promise.all(C(t, (e=>e.asyncAsset)))
              , o = C(t, (e=>e.image));
            return r.then((t=>{
                const r = (e=>{
                    const t = []
                      , n = [];
                    return _(e, (e=>{
                        e.fold((e=>{
                            t.push(e)
                        }
                        ), (e=>{
                            n.push(e)
                        }
                        ))
                    }
                    )),
                    {
                        errors: t,
                        values: n
                    }
                }
                )(t)
                  , s = Pc(r.values, o);
                return {
                    response: r.errors.length > 0 ? Fr(e, s, "errors.imageimport.failed") : Rr(e, s),
                    bundle: n.bundle
                }
            }
            ))
        }
        )(t) : r();
        return Lr(n.response, Wr, o, r, o)
    }
    ;
    const $c = (e,t,n=!1)=>fetch(e, {
        credentials: n ? "include" : "same-origin",
        headers: t
    }).then((async e=>{
        const t = await e.blob();
        return {
            ok: e.ok,
            status: e.status,
            blob: t
        }
    }
    ), (()=>({
        ok: !1,
        status: 0
    })))
      , Gc = [{
        code: 404,
        message: "Could not find Image Proxy"
    }, {
        code: 403,
        message: "Rejected request"
    }, {
        code: 0,
        message: "Incorrect Image Proxy URL"
    }]
      , Vc = [{
        type: "not_found",
        message: "Failed to load image."
    }, {
        type: "key_missing",
        message: "The request did not include an api key."
    }, {
        type: "key_not_found",
        message: "The provided api key could not be found."
    }, {
        type: "domain_not_trusted",
        message: "The api key is not valid for the request origins."
    }]
      , qc = e=>{
        const t = (e=>{
            const t = M(Gc, (t=>e === t.code)).fold(v("Unknown ImageProxy error"), (e=>e.message));
            return "ImageProxy HTTP error: " + t
        }
        )(e);
        return Promise.reject(t)
    }
      , Kc = e=>M(Vc, (t=>t.type === e)).fold(v("Unknown service error"), (e=>e.message))
      , Yc = e=>(e=>new Promise(((t,n)=>{
        const r = new FileReader;
        r.onload = ()=>{
            t(r.result)
        }
        ,
        r.onerror = e=>{
            n(e)
        }
        ,
        r.readAsText(e)
    }
    )))(e).then((e=>{
        const t = (e=>{
            const t = (e=>{
                try {
                    return O.some(JSON.parse(e))
                } catch (e) {
                    return O.none()
                }
            }
            )(e)
              , n = t.bind((e=>((e,t)=>{
                const n = R(["error", "type"], ((e,t)=>u(e) ? e[t] : void 0), e);
                return O.from(n)
            }
            )(e).map(Kc))).getOr("Invalid JSON in service error message");
            return "ImageProxy Service error: " + n
        }
        )(e);
        return Promise.reject(t)
    }
    ))
      , Xc = (e,t,n=!1)=>t ? ((e,t)=>{
        const n = {
            "Content-Type": "application/json;charset=UTF-8",
            "tiny-api-key": t
        };
        return $c(((e,t)=>{
            const n = -1 === e.indexOf("?") ? "?" : "&";
            return /[?&]apiKey=/.test(e) ? e : e + n + "apiKey=" + encodeURIComponent(t)
        }
        )(e, t), n).then((e=>{
            return e.ok ? Promise.resolve(e.blob) : ((e,t)=>"application/json" === (null == t ? void 0 : t.type) && (400 === e || 403 === e || 404 === e || 500 === e))(t = e.status, n = e.blob) ? Yc(n) : qc(t);
            var t, n
        }
        ))
    }
    )(e, t) : ((e,t)=>$c(e, {}, t).then((e=>e.ok ? Promise.resolve(e.blob) : qc(e.status))))(e, n)
      , Zc = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*)(?::([^:@\/]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
      , Jc = /^(?:(?![^:@\/]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*)(?::([^:@\/]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
      , Qc = /(?:^|&)([^&=]+)=?([^&]*)/g
      , em = e=>{
        const t = {};
        for (; ; ) {
            const n = Qc.exec(e);
            if (null === n)
                return t;
            t[n[1]] = n[2]
        }
    }
      , tm = (e,t)=>{
        const n = ()=>Promise.resolve({
            response: t.response,
            bundle: t.bundle
        })
          , r = e=>Nc(e).then((t=>{
            const n = wn("image")
              , r = ci(e, t)
              , o = URL.createObjectURL(e);
            return kc.blob(n, r, o)
        }
        ))
          , o = (e,t)=>kc.url(wn("image"), t, e)
          , s = (e,n)=>{
            let s = !1;
            const a = U(e, (e=>Yt(e, "img")));
            return Promise.all(C(a, (e=>{
                const t = e.dom.src;
                return (e=>{
                    const t = ((e,t={})=>{
                        var n;
                        return ((e,t)=>{
                            const n = (t ? Zc : Jc).exec(e)
                              , r = z(["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], ((e,t)=>{
                                var r;
                                return null !== (r = n[t]) && void 0 !== r ? r : ""
                            }
                            ));
                            return {
                                ...r,
                                queryKey: em(r.query)
                            }
                        }
                        )(e, null !== (n = t.strictMode) && void 0 !== n && n)
                    }
                    )(e);
                    return de(t.host, "google") && !ue(t.path, "/drawings/")
                }
                )(t) ? Xc(e.dom.src).then(r, (()=>(s = !0,
                o(e, t)))) : o(e, t)
            }
            ))).then((r=>{
                const o = n.concat(Pc(r, a));
                return {
                    response: s ? Fr(e, o, "errors.imageimport.failed") : Rr(e, o),
                    bundle: t.bundle
                }
            }
            ), (()=>({
                response: Pr("errors.imageimport.invalid"),
                bundle: t.bundle
            })))
        }
        ;
        return Lr(t.response, n, s, n, s)
    }
      , nm = e=>{
        const t = sm(e);
        return t && rm(e) || !t && om(e)
    }
      , rm = e=>e.officeStyles.getOr(!0)
      , om = e=>e.htmlStyles.getOr(!1)
      , sm = e=>e.isWord.getOr(!1)
      , am = e=>e.isInternal.getOr(!1)
      , im = e=>sm(e) ? vs.Word : (e=>e.isGoogleDocs.getOr(!1))(e) ? vs.GoogleDocs : vs.Html
      , lm = tr("ephox-cement").resolve
      , cm = (e,t)=>{
        const n = ((e,t)=>{
            const n = t.translations
              , r = e=>O.some(Kr(t, {
                officeStyles: e,
                gdocsStyles: e,
                htmlStyles: e
            }));
            return {
                get: o=>{
                    const s = (e=>{
                        switch (e) {
                        case vs.Word:
                            return "officeStyles";
                        case vs.GoogleDocs:
                            return "gdocsStyles";
                        default:
                            return "htmlStyles"
                        }
                    }
                    )(o)
                      , a = t[s];
                    return p(a) ? a().then((e=>r("merge" === e)), (e=>(console.error(e),
                    r(!1)))) : "clean" === a ? Promise.resolve(r(!1)) : "merge" === a ? Promise.resolve(r(!0)) : new Promise((t=>{
                        const o = _e.fromTag("div");
                        _n(o, lm("styles-dialog-content"));
                        const s = _e.fromTag("p")
                          , a = Kn(n("cement.dialog.paste.instructions"));
                        fn(s, a),
                        un(o, s);
                        const i = {
                            text: n("cement.dialog.paste.clean"),
                            tabindex: 0,
                            className: lm("clean-styles"),
                            click: ()=>{
                                c(),
                                t(r(!1))
                            }
                        }
                          , l = {
                            text: n("cement.dialog.paste.merge"),
                            tabindex: 1,
                            className: lm("merge-styles"),
                            click: ()=>{
                                c(),
                                t(r(!0))
                            }
                        }
                          , c = ()=>{
                            m.destroy()
                        }
                          , m = e();
                        m.setTitle(n("cement.dialog.paste.title")),
                        m.setContent(o),
                        m.setButtons([i, l]),
                        m.events.close.bind((()=>{
                            c(),
                            t(O.none())
                        }
                        )),
                        m.show()
                    }
                    ))
                }
                ,
                destroy: f
            }
        }
        )(e, t);
        return (e,t)=>{
            const r = t.bundle
              , o = t.response;
            return n.get(im(r)).then((e=>e.fold((()=>({
                response: Mr(),
                bundle: t.bundle
            })), (e=>({
                response: o,
                bundle: Hr({
                    officeStyles: e.officeStyles,
                    gdocsStyles: e.gdocsStyles,
                    htmlStyles: e.htmlStyles
                })
            })))))
        }
    }
      , mm = (e,t)=>(n,r)=>am(r.bundle) ? (e=>Promise.resolve({
        response: r.response,
        bundle: Hr({
            officeStyles: e,
            gdocsStyles: e,
            htmlStyles: e
        })
    }))(!0) : cm(e, t)(n, r)
      , dm = (e,t)=>{
        if (!qt(e))
            throw new Error("Internal error: attempted to write to an iframe that is not in the DOM");
        const n = (e=>(e=>{
            const t = e.dom;
            try {
                return ((e,t)=>null != e ? O.some(t(e)) : O.none())(t.contentWindow ? t.contentWindow.document : t.contentDocument, _e.fromDom)
            } catch (e) {
                return console.log("Error reading iframe: ", t),
                console.log("Error was: " + e),
                O.none()
            }
        }
        )(e).getOrThunk((()=>Rt(e))))(e)
          , r = n.dom;
        r.open("text/html", "replace"),
        r.writeln(t),
        r.close()
    }
    ;
    var um = function(e) {
        var t, n, r = e, o = {
            a: 0,
            b: 0,
            c: 0
        }, s = [];
        return t = function(t, n) {
            var a, i, l, c, m, d;
            if (t.test(r))
                for (i = 0,
                l = (a = r.match(t)).length; i < l; i += 1)
                    o[n] += 1,
                    c = a[i],
                    m = r.indexOf(c),
                    d = c.length,
                    s.push({
                        selector: e.substr(m, d),
                        type: n,
                        index: m,
                        length: d
                    }),
                    r = r.replace(c, Array(d + 1).join(" "))
        }
        ,
        n = function(e) {
            var t, n, o, s;
            if (e.test(r))
                for (n = 0,
                o = (t = r.match(e)).length; n < o; n += 1)
                    s = t[n],
                    r = r.replace(s, Array(s.length + 1).join("A"))
        }
        ,
        n(/\\[0-9A-Fa-f]{6}\s?/g),
        n(/\\[0-9A-Fa-f]{1,5}\s/g),
        n(/\\./g),
        function() {
            var e, t, n, o, s = /{[^]*/gm;
            if (s.test(r))
                for (t = 0,
                n = (e = r.match(s)).length; t < n; t += 1)
                    o = e[t],
                    r = r.replace(o, Array(o.length + 1).join(" "))
        }(),
        t(/(\[[^\]]+\])/g, "b"),
        t(/(#[^\#\s\+>~\.\[:\)]+)/g, "a"),
        t(/(\.[^\s\+>~\.\[:\)]+)/g, "b"),
        t(/(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi, "c"),
        t(/(:(?!not|global|local)[\w-]+\([^\)]*\))/gi, "b"),
        t(/(:(?!not|global|local)[^\s\+>~\.\[:]+)/g, "b"),
        r = (r = (r = (r = (r = (r = r.replace(/[\*\s\+>~]/g, " ")).replace(/[#\.]/g, " ")).replace(/:not/g, "    ")).replace(/:local/g, "      ")).replace(/:global/g, "       ")).replace(/[\(\)]/g, " "),
        t(/([^\s\+>~\.\[:]+)/g, "c"),
        s.sort((function(e, t) {
            return e.index - t.index
        }
        )),
        {
            selector: e,
            specificity: "0," + o.a.toString() + "," + o.b.toString() + "," + o.c.toString(),
            specificityArray: [0, o.a, o.b, o.c],
            parts: s
        }
    }
      , pm = e=>{
        const t = e.dom.styleSheets;
        return Array.prototype.slice.call(t)
    }
    ;
    const gm = e=>{
        const t = e.selectorText
          , n = e.style.cssText;
        if (void 0 === n)
            throw new Error("WARNING: Browser does not support cssText property");
        return {
            selector: t,
            style: n,
            raw: e.style
        }
    }
      , fm = e=>{
        const t = e.cssRules;
        return U(t, (e=>(e=>e.type === window.CSSRule.IMPORT_RULE)(e) ? fm(e.styleSheet) : (e=>e.type === window.CSSRule.STYLE_RULE)(e) ? [gm(e)] : []))
    }
      , hm = e=>U(e, fm)
      , vm = (e,t,n)=>{
        const r = e=>-1 !== e.selector.indexOf(",")
          , o = U(P(e, r), (e=>{
            const t = e.selector.split(",");
            return C(t, (t=>({
                selector: t.trim(),
                raw: e.raw
            })))
        }
        ))
          , s = P(e, (e=>!r(e))).concat(o);
        s.sort(((e,t)=>function(e, t) {
            var n, r, o;
            if ("string" == typeof e) {
                if (-1 !== e.indexOf(","))
                    throw "Invalid CSS selector";
                n = um(e).specificityArray
            } else {
                if (!Array.isArray(e))
                    throw "Invalid CSS selector or specificity array";
                if (4 !== e.filter((function(e) {
                    return "number" == typeof e
                }
                )).length)
                    throw "Invalid specificity array";
                n = e
            }
            if ("string" == typeof t) {
                if (-1 !== t.indexOf(","))
                    throw "Invalid CSS selector";
                r = um(t).specificityArray
            } else {
                if (!Array.isArray(t))
                    throw "Invalid CSS selector or specificity array";
                if (4 !== t.filter((function(e) {
                    return "number" == typeof e
                }
                )).length)
                    throw "Invalid specificity array";
                r = t
            }
            for (o = 0; o < 4; o += 1) {
                if (n[o] < r[o])
                    return -1;
                if (n[o] > r[o])
                    return 1
            }
            return 0
        }(e.selector, t.selector))).reverse(),
        ((e,t,n)=>{
            const r = U(t, (t=>{
                const n = Yt(e, t.selector);
                return _(n, (e=>{
                    const n = ((e,t)=>{
                        const n = {};
                        return _(e, (r=>{
                            if (void 0 !== e[r]) {
                                const o = t.dom.style;
                                D(o, r) || (n[r] = e[r])
                            }
                        }
                        )),
                        n
                    }
                    )(t.raw, e);
                    zn(e, n)
                }
                )),
                n
            }
            ));
            n && _(r, (e=>{
                kn(e, "class")
            }
            ))
        }
        )(t, s, n)
    }
      , ym = (e,t,n,r)=>{
        const o = pm(e)
          , s = hm(o).map((e=>{
            const t = e.selector;
            return {
                selector: n.hasOwnProperty(t) ? n[t] : t,
                raw: e.raw
            }
        }
        ));
        vm(s, t, r)
    }
      , bm = (e,t,n,r)=>{
        const o = pm(e)
          , s = hm(o)
          , a = P(s, (e=>ue(e.selector, n)));
        vm(a, t, r)
    }
      , xm = (e,t,n,r)=>{
        const o = pm(e)
          , s = hm(o)
          , a = P(s, (e=>D(n, e.selector)));
        vm(a, t, r)
    }
    ;
    var wm = {
        inlineStyles: (e,t,n)=>{
            ym(e, t, n, !0)
        }
        ,
        inlineStylesKeepClasses: (e,t,n)=>{
            ym(e, t, n, !1)
        }
        ,
        inlinePrefixedStyles: (e,t,n)=>{
            bm(e, t, n, !0)
        }
        ,
        inlinePrefixedStylesKeepClasses: (e,t,n)=>{
            bm(e, t, n, !1)
        }
        ,
        inlineSelectorsStyles: (e,t,n)=>{
            xm(e, t, n, !0)
        }
        ,
        inlineSelectorsStylesKeepClasses: (e,t,n)=>{
            xm(e, t, n, !1)
        }
    }
      , Tm = {
        inlineStyles: wm.inlineStyles,
        inlineStylesKeepClasses: wm.inlineStylesKeepClasses,
        inlinePrefixedStyles: wm.inlinePrefixedStyles,
        inlinePrefixedStylesKeepClasses: wm.inlinePrefixedStylesKeepClasses,
        inlineSelectorsStyles: wm.inlineSelectorsStyles,
        inlineSelectorsStylesKeepClasses: wm.inlineSelectorsStylesKeepClasses
    };
    const Im = {
        p: "p, li[data-converted-paragraph]"
    }
      , Sm = (e,t)=>{
        const n = Yt(e, "li[data-converted-paragraph]");
        if (_(n, (e=>{
            kn(e, "data-converted-paragraph")
        }
        )),
        t) {
            const t = Yt(e, "li");
            _(t, (t=>{
                const n = (e=>{
                    const t = (()=>{
                        const t = _e.fromTag("span");
                        return dn(e, t),
                        t
                    }
                    )();
                    return {
                        convertToPx: e=>{
                            return Hn(t, "margin-left", e),
                            n = Wn(t, "margin-left"),
                            parseFloat(/-?\d+\.?\d*/.exec(n)[0]);
                            var n
                        }
                        ,
                        destroy: ()=>vn(t)
                    }
                }
                )(e)
                  , r = ((e,t)=>{
                    const n = En(e, "data-tab-interval").getOr("36pt");
                    return t.convertToPx(n)
                }
                )(e, n)
                  , o = Om(t, r, n).getOr({});
                (e=>{
                    kn(e, "data-list-level"),
                    kn(e, "data-text-indent-alt"),
                    kn(e, "data-border-margin"),
                    Vn(e, "margin-left"),
                    Vn(e, "text-indent"),
                    vt(Gn(e), ((t,n)=>{
                        !ue(n, "border") || "border-image" !== n && "none" !== t.trim() && "initial" !== t.trim() || Vn(e, n)
                    }
                    ))
                }
                )(t),
                n.destroy(),
                zn(t, o)
            }
            ));
            const n = Yt(e, "ol,ul");
            _(n, (e=>{
                const t = Yt(e, "li");
                $n(e, "margin-top").isNone() && O.from(t[0]).each((t=>{
                    Hn(e, "margin-top", Wn(t, "margin-top"))
                }
                )),
                $n(e, "margin-bottom").isNone() && O.from(t[t.length - 1]).each((t=>{
                    Hn(e, "margin-bottom", Wn(t, "margin-bottom"))
                }
                ))
            }
            ))
        }
        kn(e, "data-tab-interval")
    }
      , Om = (e,t,n)=>{
        const r = e=>En(e, "data-list-level").map((e=>parseInt(e, 10))).getOr(1);
        return $n(e, "text-indent").bind((o=>$n(e, "margin-left").map((s=>{
            const a = $n(e, "list-style").exists((e=>de(e, "none")))
              , i = En(e, "data-border-margin").getOr("0px")
              , l = a ? r(e) + 1 : r(e)
              , c = n.convertToPx(s) + n.convertToPx(i)
              , m = t * l
              , d = En(e, "data-text-indent-alt").getOr(o)
              , u = n.convertToPx(d)
              , p = {}
              , g = t / 2 * -1 - u;
            g > 0 && (p["text-indent"] = g + "px");
            const f = c - m - g;
            return p["margin-left"] = f > 0 ? f + "px" : "0px",
            p
        }
        ))))
    }
      , Em = e=>{
        const t = (n = _e.fromDom(document.body),
        {
            play: (e,t,r)=>{
                const o = _e.fromTag("div")
                  , s = _e.fromTag("iframe");
                zn(o, {
                    display: "none"
                });
                const a = Nr(s, "load", (()=>{
                    var n;
                    a.unbind(),
                    dm(s, e);
                    const i = null === (n = s.dom.contentWindow) || void 0 === n ? void 0 : n.document;
                    if (void 0 === i)
                        throw new Error("sandbox iframe load event did not fire correctly");
                    const l = _e.fromDom(i)
                      , c = l.dom.body;
                    if (void 0 === c)
                        throw new Error("sandbox iframe does not have a body");
                    const m = _e.fromDom(c)
                      , d = t(l, m);
                    vn(o),
                    setTimeout(x(r, d), 0)
                }
                ));
                un(o, s),
                un(n, o)
            }
        });
        var n;
        return n=>new Promise((r=>{
            t.play(n, ((t,n)=>(((e,t,n)=>{
                const r = n.mergeInline();
                r && (Tm.inlineStyles(e, t, Im),
                (e=>{
                    Ta(e)
                }
                )(t)),
                Sm(t, r)
            }
            )(t, n, {
                mergeInline: v(e)
            }),
            Yn(n))), r)
        }
        ))
    }
      , Nm = (e,t,n,r)=>{
        const o = e.html;
        return n.cleanDocument(o, t, r).then((e=>{
            if (null == (n = e) || 0 === n.length)
                return {
                    response: Rr([], []),
                    bundle: Hr({})
                };
            {
                const n = void 0 === r.sanitizer ? ec(r.intraFlag.isMarked) : r.sanitizer;
                return ((e,t,n,r)=>{
                    const o = e=>({
                        response: e,
                        bundle: Hr({})
                    })
                      , s = r.sanitizeHtml(t, "word");
                    return Em(e)(s).then((e=>{
                        const t = Kn(e)
                          , r = e=>o(Rr(t, e))
                          , s = _e.fromTag("div");
                        fn(s, t);
                        const a = P(Et("img[src]", s), (e=>En(e, "src").exists((e=>ue(e, "blob:") || ue(e, "data:")))))
                          , i = Et("img[data-image-src]", s);
                        if (0 === a.length && 0 === i.length)
                            return r([]);
                        if (n)
                            return _(a, (e=>kn(e, "id"))),
                            (e=>Promise.all(C(e, (e=>{
                                const t = e.dom;
                                return mi(t).then((n=>n.toBlob().then((r=>((n,r)=>{
                                    const o = ue(t.src, "blob:") ? t.src : URL.createObjectURL(r)
                                      , s = wn("image")
                                      , a = kc.blob(s, n, o);
                                    return _c(a, e)
                                }
                                )(n, r)))))
                            }
                            ))))(a).then(r);
                        {
                            _(a, vn),
                            _(i, vn);
                            const e = Wt(s);
                            return o(Fr(e, [], "errors.local.images.disallowed"))
                        }
                    }
                    ))
                }
                )(t, e, r.allowLocalImages, n)
            }
            var n
        }
        ), (e=>(console.error("PowerPaste error code: WIM01"),
        {
            response: Pr("errors.paste.process.failure"),
            bundle: Hr({})
        })))
    }
      , km = ct()
      , Dm = e=>{
        try {
            const t = e()
              , n = null != t && t.length > 0 ? Kn(t) : [];
            return Ir.value(n)
        } catch (e) {
            return console.error("PowerPaste error code: PT01. Message: ", e),
            Ir.error("errors.paste.process.failure")
        }
    }
      , Am = e=>e.fold(zr, (e=>({
        response: Rr(e, []),
        bundle: Hr({})
    })))
      , Cm = (e,t,n,r,o)=>Dm((()=>{
        var s, a, i;
        const l = {
            type: r,
            merge: n,
            cleanFilteredInlineElements: null !== (s = o.cleanFilteredInlineElements) && void 0 !== s ? s : [],
            indentUseMargin: null !== (a = o.indentUseMargin) && void 0 !== a && a,
            preprocessor: {
                defaultProtocol: null !== (i = o.defaultProtocol) && void 0 !== i ? i : "https"
            }
        };
        return ((e,t,n,r)=>{
            Gi(n, r.preprocessor);
            const o = Yn(n)
              , s = ((e,t)=>{
                const n = t.merge
                  , r = ((e,t)=>{
                    const n = t.browser.isFirefox()
                      , r = wo([(s = n ? hs : fs,
                    a = !n,
                    Io(((e,t)=>{
                        const n = ((e,t,n)=>t(_e.fromDom(e.getNode())).fold((()=>[e]), (t=>{
                            const r = e.type() === co
                              , o = [po(t.dom, r)];
                            return !r && n && o.push(po(t.dom, !0)),
                            o
                        }
                        )))(t, s, a);
                        e.emitTokens(n)
                    }
                    ), f))])
                      , o = n ? f : oa;
                    var s, a;
                    return {
                        annotate: [e.type === vs.Word ? r : f],
                        local: [o]
                    }
                }
                )(t, e);
                return j([r.local, Ma(t), ja(t), r.annotate, (o = n ? [] : t.cleanFilteredInlineElements,
                [Oa, Na, pa(o)]), Fa(t), Ha(t, e), [Ls], [ua], [Xs], [Zs], Ra(t), [ya, ba, sa, xa], [aa], [ia], [la], [fa], za(t), [va], [ma], [Ta], Wa(t), [ga], [Js]]);
                var o
            }
            )(t, r);
            return To(e, o, s)
        }
        )(e, km, t, l)
    }
    ))
      , _m = (e,t)=>{
        const n = Dm((()=>((e,t)=>((e,t)=>To(e, t, [Zs, xa]))(e, Yn(t)))(e, t)));
        return Am(n)
    }
      , Lm = (e,t,n,r,o)=>Cm(e, t, r, n, o).fold(Wr, (e=>Promise.resolve({
        response: Rr(e, []),
        bundle: Hr({})
    })))
      , Pm = e=>"\n" === e || "\r" === e
      , Rm = (e,t)=>{
        const n = (e=>{
            const t = _e.fromTag("div");
            return ((e,t)=>{
                e.dom.textContent = t
            }
            )(t, e),
            Yn(t)
        }
        )(e)
          , r = ((e,t)=>{
            const n = ((e,t)=>{
                const n = e.replace(/\t/g, (r = t) <= 0 ? "" : new Array(r + 1).join(" "));
                var r;
                const o = R(n, ((e,t)=>(e=>-1 !== " \f\t\v".indexOf(e))(t) || "\xa0" === t ? e.pcIsSpace || "" === e.str || e.str.length === n.length - 1 || ((e,t)=>t < e.length && t >= 0 && Pm(e[t]))(n, e.str.length + 1) ? {
                    pcIsSpace: !1,
                    str: e.str + "\xa0"
                } : {
                    pcIsSpace: !0,
                    str: e.str + " "
                } : {
                    pcIsSpace: Pm(t),
                    str: e.str + t
                }), {
                    pcIsSpace: !1,
                    str: ""
                });
                return o.str
            }
            )(e, t).replace(/^[\r\n]*|[\r\n]*$/g, "").split(/(?:\r?\n){2}/)
              , r = C(n, (e=>e.split(/\n|\r\n/).join("<br />")));
            return 1 === r.length ? r[0] : C(r, (e=>"<p>" + e + "</p>")).join("")
        }
        )(n, t)
          , o = Kn(r);
        return Rr(o, [])
    }
      , Mm = e=>(t,n)=>((e,t)=>{
        const n = pc(e).getOrDie("Required text input for Text Handler");
        return {
            response: n.text.length > 0 ? Rm(n.text, t) : Mr(),
            bundle: Hr({})
        }
    }
    )(t, e)
      , Fm = e=>(t,n)=>{
        const r = (t,r)=>{
            const o = _e.fromTag("div");
            fn(o, t),
            Gi(o, e);
            const s = Wt(o);
            return {
                response: Rr(s, r),
                bundle: n.bundle
            }
        }
          , o = v(n);
        return Lr(n.response, o, r, o, r)
    }
      , jm = (e,t,n)=>(r,o)=>{
        const s = mc(r).getOrDie("Wrong input type for HTML handler").container
          , a = Rt(t)
          , i = o.bundle;
        return am(i) ? _m(a, s) : (e(s),
        ((e,t,n,r,o)=>{
            const s = Cm(e, t, n, r, o);
            return Am(s)
        }
        )(a, s, nm(i), im(i), n))
    }
      , Um = (e,t,n)=>(r,o)=>{
        const s = o.bundle;
        return (e=>({
            handle: (t,n)=>e.proxyBin.fold((()=>(console.error(t),
            Promise.resolve({
                response: Mr(),
                bundle: Hr({})
            }))), n)
        }))(s).handle("There was no proxy bin setup. Ensure you have run proxyStep first.", (r=>{
            const o = nm(s)
              , a = im(s)
              , i = am(s)
              , l = Rt(e);
            return i ? ((e,t,n,r)=>{
                const o = vs.Html
                  , s = t.findClipboardTags(Wt(n)).getOr([]);
                return _(s, vn),
                Lm(e, n, o, !0, r)
            }
            )(l, t, r, n) : ((e,t,n,r,o)=>Lm(e, t, r, n, o))(l, r, o, a, n)
        }
        ))
    }
      , Hm = (e,t)=>(n,r)=>{
        const o = uc(n).getOrDie("Wrong input type for Word Import handler")
          , s = rm(r.bundle);
        return Nm(o, s, e, t)
    }
      , zm = (e,t)=>Br
      , Wm = e=>(t,n)=>{
        const r = Ur(n.bundle, Hr(e));
        return {
            response: n.response,
            bundle: r
        }
    }
      , Bm = (e,t)=>(e=>{
        const t = e=>({
            response: Rr([e], []),
            bundle: Hr({})
        });
        return (e=>(e=>{
            const t = Yt(e, "img");
            return Promise.all(C(t, vi)).then((()=>e))
        }
        )(e))(e).then(t).catch((()=>t(e)))
    }
    )(mc(e).getOrDie("Wrong input type for HTML handler").container)
      , $m = v(lm("smartpaste-eph-bin"))
      , Gm = ct();
    var Vm = (e,t,n,r)=>(o,s)=>{
        const a = s.response;
        return new Promise(((o,s)=>{
            const i = e(n);
            i.events.after.bind((e=>{
                const n = e.container;
                if (Gm.browser.isSafari() && (i = n,
                l = 'img[src^="webkit-fake-url"]',
                ((e,t)=>{
                    const n = void 0 === t ? document : t.dom;
                    return Ot(n) ? O.none() : O.from(n.querySelector(e)).map(_e.fromDom)
                }
                )(l, i)).isSome()) {
                    const e = Gm.deviceType.isWebView() ? "webview.imagepaste" : "safari.imagepaste";
                    o({
                        response: Pr(e),
                        bundle: Hr({})
                    })
                } else {
                    t(n),
                    _n(n, $m());
                    const e = (s = Yn(n)).indexOf("<o:p>") >= 0 || s.indexOf("mso-list") >= 0 || s.indexOf("p.MsoNormal, li.MsoNormal, div.MsoNormal") >= 0 || s.indexOf("MsoListParagraphCxSpFirst") >= 0 || s.indexOf("<w:WordDocument>") >= 0
                      , i = ((e,t)=>{
                        const n = Yt(t, "*[id]");
                        return A(n, (e=>En(e, "id").exists((e=>ue(e, "docs-internal-guid-")))))
                    }
                    )(0, n)
                      , l = Wt(n)
                      , c = r.findClipboardTags(l).isSome();
                    o({
                        response: a,
                        bundle: Hr({
                            isWord: e,
                            isGoogleDocs: i,
                            isInternal: c,
                            proxyBin: n
                        })
                    })
                }
                var s, i, l
            }
            )),
            i.run()
        }
        ))
    }
    ;
    const qm = Ct([{
        unsupported: ["id", "message", "isEquation", "attrs"]
    }, {
        supported: ["id", "contentType", "blob", "isEquation", "attrs"]
    }])
      , Km = {
        unsupported: qm.unsupported,
        supported: qm.supported,
        cata: (e,t,n)=>e.fold(t, n)
    }
      , Ym = (e,t,n)=>t.indexOf(e, n)
      , Xm = (e,t,n,r,o,s,a)=>-1 === e || -1 === t ? O.none() : O.some({
        start: e,
        end: t,
        bower: n,
        regex: r,
        idRef: o,
        isEquation: s,
        attrs: a
    })
      , Zm = (e,t,n)=>e.substring(t, n)
      , Jm = (e,t)=>{
        if (-1 === t)
            return t;
        let n = 0;
        const r = e.length;
        do {
            const o = e.indexOf("{", t)
              , s = e.indexOf("}", t);
            if (s > o && -1 !== o ? (t = o + 1,
            ++n) : (o > s || o < 0) && -1 !== s && (t = s + 1,
            --n),
            t > r || -1 === s)
                return -1
        } while (n > 0);
        return t
    }
      , Qm = (e,t,n,r,o)=>{
        const s = Zm(e, n, r)
          , a = ((e,t)=>{
            const n = Ym("\\picscalex", e, t)
              , r = Ym("\\bliptag", e, n);
            return n > -1 && n < r ? O.from(e.substring(n, r)) : O.none()
        }
        )(e, n);
        return Xm(n, r, s, /[^a-fA-F0-9]([a-fA-F0-9]+)\}$/, "i", o, a)
    }
      , ed = (e,t,n,r,o)=>{
        const s = Zm(e, n, r);
        return Xm(n, r, s, /([a-fA-F0-9]{64,})(?:\}.*)/, "s", o, O.none())
    }
      , td = (e,t)=>((e,t)=>{
        const n = Ym("{\\pict{", e, t)
          , r = Jm(e, n)
          , o = Ym("{\\shp{", e, t)
          , s = Jm(e, o)
          , a = Ym("{\\mmathPict{", e, t)
          , i = Jm(e, a)
          , l = -1 !== a && (a < n && i > r || a < o && i > s)
          , c = x(ed, e, t, o, s, l)
          , m = x(Qm, e, t, n, r, l);
        return -1 === n && -1 === o ? O.none() : -1 === n ? c() : -1 === o || o < n && s > r ? m() : n < o && r > s ? c() : n < o ? m() : o < n ? c() : O.none()
    }
    )(e, t)
      , nd = e=>{
        let t = [];
        const n = ()=>e.length
          , r = e=>{
            const n = (e=>{
                const t = e.bower
                  , n = e.regex
                  , r = e.isEquation
                  , o = e.attrs;
                return (e=>{
                    const t = /\\shplid(\d+)/.exec(e);
                    return null !== t ? O.some(t[1]) : O.none()
                }
                )(t).map((s=>{
                    const a = e.idRef + s;
                    return (e=>e.indexOf("\\pngblip") >= 0 ? Ir.value("image/png") : e.indexOf("\\jpegblip") >= 0 ? Ir.value("image/jpeg") : Ir.error("errors.imageimport.unsupported"))(t).fold((e=>Km.unsupported(a, e, r, o)), (e=>((e,t)=>{
                        const n = e.match(t);
                        return n && n[1] && n[1].length % 2 == 0 ? Ir.value(n[1]) : Ir.error("errors.imageimport.invalid")
                    }
                    )(t, n).fold((e=>Km.unsupported(a, e, r, o)), (t=>Km.supported(a, e, ((e,t)=>{
                        if (0 === e.length)
                            throw new Error("Zero length content passed to Hex conversion");
                        const n = (e=>{
                            const t = new Array(e.length / 2);
                            for (let n = 0; n < e.length; n += 2) {
                                const r = e.substr(n, 2);
                                t[Math.floor(n / 2)] = parseInt(r, 16)
                            }
                            return t
                        }
                        )(e)
                          , r = new Uint8Array(n);
                        return new Blob([r],{
                            type: t
                        })
                    }
                    )(t, e), r, o)))))
                }
                ))
            }
            )(e);
            return t = t.concat(n.toArray()),
            e.end
        }
        ;
        let o = 0;
        for (; o < e.length; )
            o = td(e, o).fold(n, r);
        return t
    }
      , rd = e=>Km.cata(e, ((e,t,n)=>e), ((e,t,n,r,o)=>e))
      , od = e=>Km.cata(e, ((e,t,n)=>n), ((e,t,n,r,o)=>r))
      , sd = e=>Km.cata(e, ((e,t,n)=>Ir.error(t)), ((e,t,n,r,o)=>Ir.value(n)))
      , ad = (e,t)=>{
        const n = new RegExp("\\\\pic" + t + "(\\-?\\d+)\\\\").exec(e)[1];
        return parseInt(n, 10)
    }
      , id = (e,t,n,r,o)=>{
        const s = []
          , a = [];
        let i = !1;
        return {
            blobs: U(e, ((e,l)=>{
                const c = On(e, "data-image-id");
                return kn(e, "rtf-data-image"),
                kn(e, "data-image-id"),
                kn(e, "data-ms-equation"),
                o || kn(e, "data-image-src"),
                "unsupported" === c ? (i = !0,
                In(e, "alt", n("errors.imageimport.unsupported")),
                []) : M(t, ((e,t)=>r(e, t, c, l))).fold((()=>(console.log("WARNING: unable to find data for image ", e.dom),
                i = !0,
                In(e, "alt", n("errors.imageimport.unsupported")),
                [])), (t=>sd(t).fold((t=>(i = !0,
                console.error("PowerPaste error code: RTF04"),
                In(e, "alt", n(t)),
                [])), (n=>{
                    var r;
                    return s.push(e),
                    a.push((r = t,
                    Km.cata(r, ((e,t,n)=>O.none()), ((e,t,n,r,o)=>o)))),
                    o && kn(e, "data-image-src"),
                    [n]
                }
                ))))
            }
            )),
            filteredImages: s,
            imageAttrs: a,
            failedImage: i
        }
    }
      , ld = (e,t,n,r,o)=>{
        const s = (e=>R(e, ((e,t)=>{
            const n = rd(t)
              , r = od(t);
            return F(e, (e=>!(r || od(e)) && rd(e) === n)).fold((()=>e.concat([t])), (n=>sd(e[n]).isValue() ? e : e.slice(0, n).concat(e.slice(n + 1)).concat([t])))
        }
        ), []))(t)
          , a = o.keepSrc || !1
          , {pass: i, fail: l} = L(s, (e=>!od(e)))
          , {pass: c, fail: m} = L(e, (e=>!(e=>"true" === On(e, "data-ms-equation"))(e)))
          , d = id(c, i, r, ((e,t,n,r)=>rd(e) === n), a)
          , u = id(m, l, r, ((e,t,n,r)=>t === r), a)
          , p = d.filteredImages.concat(u.filteredImages)
          , g = d.imageAttrs.concat(u.imageAttrs)
          , f = d.blobs.concat(u.blobs)
          , h = d.failedImage || u.failedImage;
        Cc(f).get((e=>{
            ((e,t)=>e.length === t.length ? Promise.all(C(e, ((e,n)=>((e,t)=>t.fold((()=>Promise.resolve(e)), (t=>kc.cata(e, ((n,r,o)=>r.toCanvas().then((s=>{
                const a = _e.fromDom(s)
                  , i = En(a, "width").map((e=>parseInt(e, 10))).getOr(1)
                  , l = En(a, "height").map((e=>parseInt(e, 10))).getOr(1)
                  , c = ((e,t,n)=>{
                    const r = x(ad, e)
                      , o = r("wgoal")
                      , s = r("hgoal")
                      , a = o / t
                      , i = s / n
                      , l = r("cropl")
                      , c = r("cropt");
                    return {
                        cropl: l / a,
                        cropt: c / i,
                        cropw: (o - l - r("cropr")) / a,
                        croph: (s - c - r("cropb")) / i
                    }
                }
                )(t, i, l);
                return i === c.cropw && l === c.croph && 0 === c.cropl && 0 === c.cropt ? Promise.resolve(e) : ii(r, c.cropl, c.cropt, c.cropw, c.croph).then((e=>e.toBlob().then((t=>{
                    URL.revokeObjectURL(o);
                    const r = URL.createObjectURL(t);
                    return kc.blob(n, e, r)
                }
                ))))
            }
            ))), ((t,n,r)=>Promise.resolve(e))))))(e, t[n])))) : Promise.resolve(e))(e, g).then((e=>{
                const t = Pc(e, p);
                n(t, h)
            }
            ))
        }
        ))
    }
      , cd = e=>Yt(e, "[rtf-data-image]")
      , md = e=>{
        const t = e.translations
          , n = It({
            insert: gt(["elements", "correlated"]),
            incomplete: gt(["elements", "correlated", "message"])
        });
        return {
            events: n.registry,
            processRtf: (e,r,o,s)=>{
                const a = (e=>{
                    const t = e.replace(/\r/g, "").replace(/\n/g, "");
                    return nd(t)
                }
                )(o)
                  , i = cd(e);
                ld(i, a, ((t,o)=>{
                    const s = Wt(e)
                      , a = t.concat(r);
                    o ? (console.error("PowerPaste error code: RTF01"),
                    n.trigger.incomplete(s, a, "errors.imageimport.failed")) : n.trigger.insert(s, a)
                }
                ), t, s)
            }
        }
    }
    ;
    const dd = e=>{
        const t = ()=>Promise.resolve(e);
        return kc.cata(e.asset, ((n,r,o)=>/(tiff|pdf)$/.test(r.getType()) ? (e=>((e,t,n)=>e.toAdjustedBlob(t, n))(e, "image/png").then((e=>Dc(e).toPromise())).then(O.some).catch((e=>(console.warn(e),
        O.none()))))(r).then((t=>t.map((t=>{
            const n = e.image;
            return URL.revokeObjectURL(o),
            Lc(t, n),
            _c(t, n)
        }
        )).getOr(e))) : t()), t)
    }
    ;
    var ud = (e,t)=>{
        const n = (e,n)=>Promise.all(C(e, dd)).then((e=>({
            response: n(e),
            bundle: t.bundle
        })));
        return Lr(t.response, Wr, ((e,t)=>n(t, (t=>Rr(e, t)))), (()=>Promise.resolve(t)), ((e,t,r)=>n(t, (t=>(console.error("PowerPaste error code:  IMG01"),
        Fr(e, t, r))))))
    }
    ;
    const pd = (e,t)=>e.isSupported ? t.getWordData() : O.none()
      , gd = e=>e.getNative()
      , fd = e=>e.getImage()
      , hd = e=>e.getHtml()
      , vd = e=>e.getText()
      , yd = e=>e.getOnlyText()
      , bd = e=>e.getGoogleDocsData()
      , xd = e=>e.getVoid()
      , wd = (e,t,n,r)=>({
        label: e,
        getAvailable: t,
        steps: n,
        capture: v(r)
    })
      , Td = (e,t,n,r)=>({
        label: e,
        getAvailable: t,
        steps: n,
        capture: v(r)
    })
      , Id = (e,t,n,r)=>{
        return wd(Sc.native, hd, [(o = t.intraFlag,
        (e,t)=>{
            const n = mc(e).getOrDie("Wrong input type for HTML handler")
              , r = o.findClipboardTags(Wt(n.container));
            r.each((e=>{
                _(e, vn)
            }
            ));
            const s = r.isSome();
            return {
                response: t.response,
                bundle: Hr({
                    isInternal: s
                })
            }
        }
        ), mm(e, t), jm(n, r, t), Bc(t), ud], !0);
        var o
    }
      , Sd = (e,t,n)=>{
        return wd(Sc.msoffice, x(pd, e), [Wm({
            isWord: !0
        }), cm(t, n), Hm(e, n), (r = n,
        (e,t)=>new Promise(((n,o)=>{
            const s = md(r)
              , a = e=>n({
                response: e,
                bundle: Hr({})
            });
            s.events.insert.bind((e=>{
                a(Rr(e.elements, e.correlated))
            }
            )),
            s.events.incomplete.bind((e=>{
                console.error("PowerPaste error code: RTF02"),
                a(Fr(e.elements, e.correlated, e.message))
            }
            ));
            const i = uc(e).getOrDie("Word input required for rtf data")
              , l = e=>{
                const n = ()=>Promise.resolve(t)
                  , o = (t,n)=>{
                    const o = _e.fromTag("div");
                    return fn(o, t),
                    e.fold((()=>{
                        const e = cd(o);
                        return e.length > 0 ? (e=>{
                            _(e, vn);
                            const t = Wt(o);
                            return console.error("PowerPaste error code: RTF03"),
                            a(Fr(t, n, "errors.imageimport.failed"))
                        }
                        )(e) : (()=>{
                            const e = Wt(o);
                            return a(Rr(e, n))
                        }
                        )()
                    }
                    ), (e=>{
                        s.processRtf(o, n, e, r)
                    }
                    ))
                }
                ;
                return Lr(t.response, n, o, n, o)
            }
            ;
            ((e,t)=>{
                const n = ft(t);
                if (n.length !== qi.length)
                    throw new Error("Partial match");
                B(n, (n=>Mn(e.discriminator === n, t[n]))).getOrDie("Must find branch for constructor: " + e.discriminator)(e.data)
            }
            )(i.rtf, {
                disabled: ()=>{
                    l(O.none())
                }
                ,
                fromClipboard: e=>{
                    l(!0 === r.allowLocalImages ? O.some(e.rtf) : O.none())
                }
            })
        }
        ))), ud], !0);
        var r
    }
      , Od = (e,t,n,r)=>wd(Sc.googledocs, bd, [Wm({
        isGoogleDocs: !0
    }), cm(e, t), Bm, jm(n, r, t), tm, Bc(t), ud], !0)
      , Ed = e=>{
        var t;
        const n = O.from(e.tabSpaces).getOr(4)
          , r = null !== (t = e.defaultProtocol) && void 0 !== t ? t : "https";
        return wd(Sc.plaintext, yd, [Mm(n), Fm({
            defaultProtocol: r
        })], !0)
    }
      , Nd = (e=4,t="https")=>wd(Sc.text, vd, [Mm(e), Fm({
        defaultProtocol: t
    })], !0)
      , kd = (e,t,n,r,o=Cr)=>{
        const s = pt(o, r.baseUrl, r.cacheSuffix)
          , a = pr(void 0 !== r.pasteBinAttrs ? r.pasteBinAttrs : {})
          , i = void 0 === r.sanitizer ? ec(r.intraFlag.isMarked) : r.sanitizer
          , l = [Ed(r), Sd(s, t, r), Od(t, r, n, e), Id(t, r, n, e), (c = r,
        wd(Sc.image, fd, [!1 === c.allowLocalImages ? (e,t)=>Wr("errors.local.images.disallowed") : (e,t)=>(e=>{
            const t = P(e, (e=>"file" === e.kind && /image/.test(e.type)))
              , n = R(t, ((e,t)=>{
                const n = t.getAsFile();
                return (e=>null !== e)(n) ? e.concat(n) : e
            }
            ), []);
            return Cc(n).toPromise().then((e=>({
                response: (e=>{
                    const t = []
                      , n = [];
                    return _(e, (e=>kc.cata(e, ((r,o,s)=>{
                        const a = _e.fromTag("img");
                        In(a, "src", s),
                        t.push(a),
                        n.push(_c(e, a))
                    }
                    ), ((e,t,n)=>{
                        console.error("Internal error: Paste operation produced an image URL instead of a Data URI: ", t)
                    }
                    )))),
                    Rr(t, n)
                }
                )(e),
                bundle: Hr({})
            })))
        }
        )(dc(e).getOrDie("Must have image data for images handler").images), ud], !0)), Nd(r.tabSpaces, r.defaultProtocol)];
        var c;
        const m = ((e,t,n,r,o)=>Td(Sc.fallback, gd, [Vm(r, n, o, t.intraFlag), mm(e, t), Um(o, t.intraFlag, t), Bc(t), ud], !1))(t, r, n, a, e);
        return Ec(l, m, i)
    }
    ;
    var Dd = Object.freeze({
        __proto__: null,
        loadScript: (e,t)=>tinymce.Resource.load(e, t)
    });
    const Ad = {
        "cement.dialog.paste.title": "Paste Formatting Options",
        "cement.dialog.paste.instructions": "Choose to keep or remove formatting in the pasted content.",
        "cement.dialog.paste.merge": "Keep formatting",
        "cement.dialog.paste.clean": "Remove formatting",
        "safari.imagepaste": 'Safari does not support direct paste of images. <a href="https://support.ephox.com/entries/88543243-Safari-Direct-paste-of-images-does-not-work" style="text-decoration: underline">More information on image pasting for Safari</a>',
        "webview.imagepaste": 'Safari does not support direct paste of images. <a href="https://support.ephox.com/entries/88543243-Safari-Direct-paste-of-images-does-not-work" style="text-decoration: underline">More information on image pasting for Safari</a>',
        "error.code.images.not.found": "The images service was not found: (",
        "error.imageupload": "Image failed to upload: (",
        "error.full.stop": ").",
        "errors.local.images.disallowed": "Local image paste has been disabled. Local images have been removed from pasted content.",
        "errors.imageimport.failed": "Some images failed to import.",
        "errors.imageimport.unsupported": "Unsupported image type.",
        "errors.imageimport.invalid": "Image is invalid."
    }
      , Cd = e=>tinymce.translate((e=>Ad[e])(e))
      , _d = e=>{
        const t = document.createElement("div");
        return t.appendChild(e.cloneNode(!0)),
        t.innerHTML
    }
      , Ld = v("x-tinymce/html")
      , Pd = "\x3c!-- x-tinymce/html --\x3e"
      , Rd = e=>-1 !== e.indexOf(Pd)
      , Md = e=>/^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e)
      , Fd = e=>{
        const t = /^<a href="([^"]+)">([^<]+)<\/a>$/.exec(e);
        return O.from(t).bind((t=>{
            const n = {
                url: t[1],
                html: e
            };
            return Mn(t[1] === t[2], n)
        }
        ))
    }
      , jd = (e,t,n)=>(e=>"extra"in e.undoManager)(e) ? (e.undoManager.extra((()=>{
        zd(e, t)
    }
    ), n),
    O.some(!0)) : O.none()
      , Ud = (e,t)=>Fd(t).bind((t=>!1 === e.selection.isCollapsed() && Md(t.url) ? ((e,t)=>jd(e, t.html, (()=>{
        e.execCommand("mceInsertLink", !1, t.url)
    }
    )))(e, t) : O.none()))
      , Hd = (e,t)=>Fd(t).bind((t=>((e,t)=>{
        const n = e.toLowerCase();
        return Md(n) && A(t, (e=>pe(n, `.${e.toLowerCase()}`)))
    }
    )(t.url, ae(e)) ? ((e,t)=>jd(e, t.html, (()=>{
        e.insertContent('<img src="' + t.url + '">')
    }
    )))(e, t) : O.none()))
      , zd = (e,t)=>(e.insertContent(t, {
        merge: V(e),
        paste: !0
    }),
    O.some(!0))
      , Wd = (e,t)=>e.hasEventListeners(t)
      , Bd = (e,t,n,r,o)=>{
        const s = (e=>e.replace(Pd, ""))(t);
        return ((e,t,n,r,o)=>Wd(e, "PastePostProcess") ? ((e,t,n,r,o)=>{
            const s = e.dom.add(e.getBody(), "div", {
                style: "display:none"
            }, t)
              , a = ((e,t)=>e.dispatch("PastePostProcess", t))(e, {
                internal: n,
                node: s,
                source: r,
                mode: o
            }).node.innerHTML;
            return e.dom.remove(s),
            a
        }
        )(e, t, n, r, o) : t)(e, ((e,t,n,r,o)=>Wd(e, "PastePreProcess") ? ((e,t,n,r,o)=>((e,t)=>e.dispatch("PastePreProcess", t))(e, {
            internal: n,
            content: t,
            source: r,
            mode: o
        }).content)(e, t, n, r, o) : t)(e, s, n, r, o), n, r, o)
    }
      , $d = (e,t,n,r,o,s)=>{
        const a = le()
          , i = ("/js",
        (r ? r.jsUrl : n).replace(/\/$/, "") + "/" + "/js".replace(/^\//, ""));
        const l = (e,t)=>(e.undoManager.transact((()=>{
            var n;
            zd(e, t),
            n = e.getBody(),
            _(C(n.getElementsByTagName("*"), _e.fromDom), (e=>{
                Nn(e, "data-mce-style") && !Nn(e, "style") && En(e, "data-mce-style").each((t=>In(e, "style", t)))
            }
            ))
        }
        )),
        O.some(!0))
          , c = ()=>{
            a.on((t=>e.selection.moveToBookmark(t))),
            a.clear()
        }
          , m = q(e)
          , d = {
            baseUrl: i,
            cacheSuffix: Y(e),
            officeStyles: te(e),
            htmlStyles: re(e),
            gdocsStyles: ne(e),
            translations: Cd,
            allowLocalImages: ee(e),
            pasteBinAttrs: {
                "data-mce-bogus": "all",
                class: "mce-pastebin"
            },
            intraFlag: {
                isMarked: Rd,
                findClipboardTags: e=>{
                    const t = P(e, (e=>Ie(e) && de(Ae(e), Ld())));
                    return t.length ? O.some(t) : O.none()
                }
            },
            keepSrc: Q(e),
            cleanFilteredInlineElements: oe(e),
            indentUseMargin: Z(e),
            sanitizer: o,
            tabSpaces: m,
            defaultProtocol: se(e)
        }
          , u = kd(_e.fromDom(e.getBody()), (e=>({
            createDialog: ()=>{
                let t = "";
                const n = le()
                  , r = (()=>{
                    const e = ie([{
                        text: "Close",
                        name: "close",
                        type: "custom",
                        primary: !0
                    }])
                      , t = ie({});
                    return {
                        setButtons: n=>{
                            const r = {}
                              , o = C(n, (e=>{
                                const t = e.text;
                                return r[t.toLowerCase()] = e.click,
                                {
                                    text: t,
                                    name: t.toLowerCase(),
                                    type: "custom"
                                }
                            }
                            ));
                            t.set(r),
                            e.set(o)
                        }
                        ,
                        getButtons: e.get,
                        getAction: e=>{
                            const n = t.get();
                            return Tt(n, e) ? O.some(n[e]) : O.none()
                        }
                    }
                }
                )()
                  , o = It({
                    close: gt([])
                })
                  , s = ()=>{
                    o.trigger.close()
                }
                ;
                return {
                    events: o.registry,
                    setTitle: e=>t = e,
                    setContent: e=>n.set(e),
                    setButtons: e=>{
                        r.setButtons(e)
                    }
                    ,
                    show: ()=>{
                        n.on((n=>{
                            const o = _d(n.dom)
                              , a = {
                                title: t,
                                body: {
                                    type: "panel",
                                    items: [{
                                        type: "htmlpanel",
                                        html: o
                                    }]
                                },
                                initialData: {},
                                buttons: r.getButtons(),
                                onCancel: s,
                                onAction: (e,t)=>{
                                    r.getAction(t.name).each(T),
                                    e.close()
                                }
                            };
                            e.windowManager.open(a)
                        }
                        ))
                    }
                    ,
                    hide: f,
                    destroy: ()=>{
                        n.clear()
                    }
                    ,
                    reflow: f
                }
            }
        }))(e).createDialog, f, d, Dd)
          , p = ((e=tc,t)=>Ec([Nd(t)], Td(Sc.discard, xd, [zm], !0), e))(o, m);
        return _([u, p], (t=>{
            t.events.cancel.bind((()=>{
                c()
            }
            )),
            t.events.error.bind((t=>{
                c(),
                e.notificationManager ? e.notificationManager.open({
                    text: Cd(t.message),
                    type: "error"
                }) : ((e,t)=>{
                    const n = {
                        title: "Error",
                        body: {
                            type: "panel",
                            items: [{
                                type: "htmlpanel",
                                html: t
                            }]
                        },
                        initialData: {},
                        buttons: [{
                            text: "OK",
                            type: "cancel",
                            name: "ok",
                            primary: !0
                        }]
                    };
                    e.windowManager.open(n)
                }
                )(e, Cd(t.message))
            }
            )),
            t.events.insert.bind((t=>{
                const n = C(t.elements, (e=>_d(e.dom))).join("");
                e.focus(),
                s.importImages(t.assets).get((()=>{
                    c(),
                    ((e,t)=>{
                        ((e,t,n)=>{
                            B(n, (n=>n(e, t)))
                        }
                        )(e, t, (K(e) ? [Ud, Hd] : []).concat([l]))
                    }
                    )(e, Bd(e, n, t.isInternal, t.source, t.mode)),
                    X(e) && s.uploadImages(t.assets)
                }
                ))
            }
            )),
            t.events.block.bind((t=>{
                e.setProgressState(t.state)
            }
            ))
        }
        )),
        {
            pasteHtml: e=>u.pasteCustom(((e,t=tc)=>({
                getWordData: ()=>O.from(e).filter(fc).map((e=>ic({
                    html: e,
                    rtf: Ki()
                }))),
                getGoogleDocsData: ()=>O.from(e).filter(hc).map((e=>t.sanitizeHtml(e, "googledocs"))).map(Tc),
                getImage: O.none,
                getHtml: ()=>O.some(Tc(t.sanitizeHtml(e))),
                getText: O.none,
                getNative: w("There is no native event"),
                getOnlyText: O.none,
                getVoid: w("There is no paste event")
            }))(e, o)),
            pasteText: e=>p.pasteCustom(((e,t=tc)=>({
                getWordData: O.none,
                getGoogleDocsData: O.none,
                getImage: O.none,
                getHtml: O.none,
                getText: ()=>O.some(lc({
                    text: t.sanitizeText(e)
                })),
                getNative: w("There is no native event"),
                getOnlyText: O.none,
                getVoid: w("There is no paste event")
            }))(e, o)),
            pasteEvent: n=>{
                (e=>{
                    return (t = e,
                    O.from(t.clipboardData).bind((e=>O.from(e.getData("text/html"))))).bind((e=>(e=>de(e, "<google-sheets-html-origin"))(e) ? O.some("googlesheets") : (e=>de(e, " data-ccp-props=") && de(e, " paraid=") && /font-family:.+?_MSFontService(&quot;)?[,;]/.test(e))(e) ? O.some("mswordonline") : (e=>de(e, "<meta name=ProgId content=Excel.Sheet>") && !de(e, '="urn:schemas-microsoft-com:office:'))(e) ? O.some("msexcelonline") : O.none()));
                    var t
                }
                )(n).each((t=>{
                    ((e,t)=>{
                        e.dispatch("PowerPasteTempStats", {
                            source: t
                        })
                    }
                    )(e, t)
                }
                )),
                a.isSet() || a.set(e.selection.getBookmark(1)),
                (t.isText() ? p : u).paste(n),
                t.reset()
            }
        }
    }
      , Gd = (e,t)=>{
        const n = tinymce.html.DomParser({}, e.schema).parse(t, {
            forced_root_block: !1,
            isRootContent: !0
        });
        return tinymce.html.Serializer({
            validate: !0
        }, e.schema).serialize(n)
    }
      , Vd = (e,t)=>{
        e.dom.bind(t, "drop dragstart dragend dragover dragenter dragleave dragdrop draggesture", (e=>{
            e.preventDefault(),
            e.stopImmediatePropagation()
        }
        ))
    }
      , qd = (e,t,n,r)=>{
        const o = tinymce.dom.RangeUtils;
        let s;
        const a = t=>{
            var n, r;
            const s = o.getCaretRangeFromPoint(null !== (n = t.clientX) && void 0 !== n ? n : 0, null !== (r = t.clientY) && void 0 !== r ? r : 0, e.getDoc());
            e.focus(),
            u(s) && e.selection.setRng(s)
        }
        ;
        e.on("dragstart dragend", (e=>{
            s = "dragstart" === e.type
        }
        )),
        e.on("dragover dragend dragleave", (e=>{
            s || (e.preventDefault(),
            a(e))
        }
        ));
        const i = (e,t)=>t in e && e[t].length > 0;
        e.on("drop", (t=>{
            if (!s) {
                a(t);
                const o = (t=>{
                    var n, r, o;
                    const s = null !== (o = null !== (n = t.target.files) && void 0 !== n ? n : null === (r = t.dataTransfer) || void 0 === r ? void 0 : r.files) && void 0 !== o ? o : []
                      , a = ae(e);
                    return P(s, (e=>ue(e.type, "image/") && A(a, (t=>(e=>{
                        const t = e.toLowerCase()
                          , n = {
                            jpg: "jpeg",
                            jpe: "jpeg",
                            jfi: "jpeg",
                            jif: "jpeg",
                            jfif: "jpeg",
                            pjpeg: "jpeg",
                            pjp: "jpeg",
                            svg: "svg+xml"
                        };
                        return Tt(n, t) ? "image/" + n[t] : "image/" + t
                    }
                    )(t) === e.type))))
                }
                )(t);
                if (o.length > 0)
                    return (t=>{
                        Cc(t).get((t=>{
                            const n = (e=>C(e, (e=>{
                                const t = _e.fromTag("img")
                                  , n = kc.cata(e, r.getLocalURL, ((e,t,n)=>t));
                                return In(t, "src", n),
                                t.dom.outerHTML
                            }
                            )).join(""))(t);
                            e.insertContent(Bd(e, n, !1, "imagedrop", "auto"), {
                                merge: V(e)
                            }),
                            X(e) && r.uploadImages(t)
                        }
                        ))
                    }
                    )(o),
                    void t.preventDefault();
                const s = (e=>{
                    const t = {};
                    if (e && e.types)
                        for (let n = 0; n < e.types.length; n++) {
                            const r = e.types[n];
                            t[r] = e.getData(r)
                        }
                    return t
                }
                )(t.dataTransfer);
                i(s, "text/html") ? (n.pasteHtml(s["text/html"]),
                t.preventDefault()) : i(s, "text/plain") && !(e=>{
                    const t = e["text/plain"];
                    return !!t && 0 === t.indexOf("file://")
                }
                )(s) && (n.pasteText(s["text/plain"]),
                t.preventDefault())
            }
        }
        ))
    }
    ;
    tinymce.PluginManager.requireLangPack("powerpaste", "ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW"),
    tinymce.PluginManager.add("powerpaste", (e=>(n,o)=>{
        if (((e,n)=>!!e && -1 === ((e,n)=>{
            const r = t(e.major, n.major);
            if (0 !== r)
                return r;
            const o = t(e.minor, n.minor);
            if (0 !== o)
                return o;
            const s = t(e.patch, n.patch);
            return 0 !== s ? s : 0
        }
        )((e=>r((e=>[e.majorVersion, e.minorVersion].join(".").split(".").slice(0, 3).join("."))(e)))(e), r(n)))(tinymce, "6.0.0"))
            return void console.error('The "powerpaste" plugin requires at least version 6.0.0 of TinyMCE.');
        (e=>{
            const t = e.options.register
              , n = e=>{
                const t = p(e) || (e=>a(e) && D(["clean", "merge", "prompt"], e))(e);
                return t ? {
                    value: e,
                    valid: t
                } : {
                    valid: !1,
                    message: "Must be prompt, clean or merge."
                }
            }
            ;
            t("powerpaste_block_drop", {
                processor: "boolean",
                default: !1
            }),
            t("powerpaste_keep_unsupported_src", {
                processor: "boolean",
                default: !1
            }),
            t("powerpaste_allow_local_images", {
                processor: "boolean",
                default: !0
            }),
            t("powerpaste_word_import", {
                processor: n,
                default: "prompt"
            }),
            t("powerpaste_googledocs_import", {
                processor: n,
                default: "prompt"
            }),
            t("powerpaste_html_import", {
                processor: n,
                default: "clean"
            }),
            t("powerpaste_clean_filtered_inline_elements", {
                processor: "string[]",
                default: []
            }),
            e.options.isRegistered("link_default_protocol") || t("link_default_protocol", {
                processor: "string",
                default: "https"
            })
        }
        )(n),
        (e=>{
            const t = e.options.set;
            t("paste_block_drop", !1),
            t("paste_data_images", !1),
            t("paste_remove_styles_if_webkit", !1)
        }
        )(n);
        const s = (e=>{
            const t = ie(G(e))
              , n = ie(!1);
            return e.on("keydown", (e=>{
                (e=>tinymce.util.VK.metaKeyPressed(e) && 86 === e.keyCode && e.shiftKey)(e) && n.set(!0)
            }
            )),
            e.on("PastePlainTextToggle", (e=>{
                t.set(e.state)
            }
            )),
            {
                reset: ()=>{
                    n.set(!1)
                }
                ,
                isText: ()=>n.get() || t.get()
            }
        }
        )(n)
          , i = (e=>{
            const t = (e,t)=>v(e + "." + (e=>{
                const t = e.toLowerCase()
                  , n = {
                    "image/jpeg": "jpg",
                    "image/jpg": "jpg",
                    "image/gif": "gif",
                    "image/png": "png",
                    "image/apng": "apng",
                    "image/avif": "avif",
                    "image/svg+xml": "svg",
                    "image/webp": "webp",
                    "image/bmp": "bmp",
                    "image/tiff": "tiff"
                };
                return Tt(n, t) ? n[t] : "dat"
            }
            )(t))
              , n = (n,r,o,s)=>yr((a=>{
                di(r).then((r=>{
                    e.editorUpload.blobCache.add({
                        id: v(n),
                        name: v(n),
                        filename: t(n, r.type),
                        blob: v(r),
                        base64: v(o.split(",")[1]),
                        blobUri: v(s),
                        uri: v(void 0)
                    }),
                    a(r)
                }
                ))
            }
            ));
            return {
                importImages: e=>{
                    const t = U(e, (e=>kc.cata(e, ((e,t,r)=>{
                        const o = ui(t);
                        return [n(e, t, o, r)]
                    }
                    ), v([]))));
                    return br(t)
                }
                ,
                uploadImages: ()=>{
                    e.uploadImages()
                }
                ,
                getLocalURL: (e,t,n)=>ui(t)
            }
        }
        )(n)
          , l = (e=>{
            const t = ec(Rd)
              , n = (e=>({
                sanitizeHtml: x(Gd, e),
                sanitizeText: y
            }))(e);
            return {
                sanitizeText: t.sanitizeText,
                sanitizeHtml: (e,r)=>(Rd(e) ? n : t).sanitizeHtml(e, r)
            }
        }
        )(n);
        n.on("PreInit", (()=>{
            if (n.removed)
                return;
            const t = $d(n, s, o, e, l, i);
            ((e,t)=>{
                e.addCommand("mceInsertClipboardContent", ((e,n)=>{
                    a(n.html) ? t.pasteHtml(n.html) : a(n.text) && t.pasteText(n.text)
                }
                ))
            }
            )(n, t),
            ((e,t)=>{
                e.on("paste", (e=>{
                    e.isDefaultPrevented() || (t.pasteEvent(e),
                    e.stopImmediatePropagation())
                }
                ))
            }
            )(n, t),
            J(n) ? (e=>{
                Vd(e, e.getBody()),
                e.inline || Vd(e, e.getDoc())
            }
            )(n) : qd(n, 0, t, i)
        }
        ))
    }
    )(undefined))
}();
