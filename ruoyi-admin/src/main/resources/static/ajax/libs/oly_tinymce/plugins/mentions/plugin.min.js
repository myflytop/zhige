/*!
 * Tiny Mentions plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 3.0.2-25
 */

!function() {
    "use strict";
    const e = e=>parseInt(e, 10)
      , t = (e,t)=>{
        const n = e - t;
        return 0 === n ? 0 : n > 0 ? 1 : -1
    }
      , n = (e,t,n)=>({
        major: e,
        minor: t,
        patch: n
    })
      , o = t=>{
        const o = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(t);
        return o ? n(e(o[1]), e(o[2]), e(o[3])) : n(0, 0, 0)
    }
      , r = e=>t=>typeof t === e
      , s = ("string",
    e=>"string" === (e=>{
        const t = typeof e;
        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && (n = o = e,
        (r = String).prototype.isPrototypeOf(n) || (null === (s = o.constructor) || void 0 === s ? void 0 : s.name) === r.name) ? "string" : t;
        var n, o, r, s
    }
    )(e));
    const i = r("boolean")
      , a = r("function")
      , l = r("number")
      , c = ()=>{}
      , m = (e,t)=>e === t
      , u = ()=>!1;
    class d {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new d(!0,e)
        }
        static none() {
            return d.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? d.some(e(this.value)) : d.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : d.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : d.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return null == e ? d.none() : d.some(e)
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    d.singletonNone = new d(!1);
    const h = (e,t)=>{
        const n = e.length
          , o = new Array(n);
        for (let r = 0; r < n; r++) {
            const n = e[r];
            o[r] = t(n, r)
        }
        return o
    }
      , p = (e,t)=>{
        for (let n = 0, o = e.length; n < o; n++)
            t(e[n], n)
    }
      , v = e=>t=>t.options.get(e)
      , g = v("mentions_menu_hover")
      , f = v("mentions_fetch")
      , y = v("mentions_menu_complete")
      , _ = v("mentions_menu_cancel")
      , b = v("mentions_select")
      , x = v("mentions_selector")
      , w = v("mentions_css_url")
      , T = v("mentions_item_type")
      , E = v("mentions_min_chars")
      , O = Object.hasOwnProperty
      , S = (e,t)=>A(e, t) ? d.from(e[t]) : d.none()
      , A = (e,t)=>O.call(e, t);
    "undefined" != typeof window ? window : Function("return this;")();
    const M = (e,t,n)=>{
        ((e,t,n)=>{
            if (!(s(n) || i(n) || l(n)))
                throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e),
                new Error("Attribute value was not simple");
            e.setAttribute(t, n + "")
        }
        )(e.dom, t, n)
    }
      , C = (e,t)=>{
        e.dom.removeAttribute(t)
    }
      , N = (e,t)=>{
        (e=>void 0 !== e.dom.classList)(e) ? e.dom.classList.add(t) : ((e,t)=>{
            ((e,t,n)=>{
                const o = ((e,t)=>{
                    const n = ((e,t)=>{
                        const n = e.dom.getAttribute("class");
                        return null === n ? void 0 : n
                    }
                    )(e);
                    return void 0 === n || "" === n ? [] : n.split(" ")
                }
                )(e)
                  , r = o.concat([n]);
                M(e, t, r.join(" "))
            }
            )(e, "class", t)
        }
        )(e, t)
    }
      , L = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , j = (e,t)=>{
        const n = (t || document).createElement(e);
        return L(n)
    }
      , P = L
      , D = (e,t)=>{
        const n = e.dom;
        if (1 !== n.nodeType)
            return !1;
        {
            const e = n;
            if (void 0 !== e.matches)
                return e.matches(t);
            if (void 0 !== e.msMatchesSelector)
                return e.msMatchesSelector(t);
            if (void 0 !== e.webkitMatchesSelector)
                return e.webkitMatchesSelector(t);
            if (void 0 !== e.mozMatchesSelector)
                return e.mozMatchesSelector(t);
            throw new Error("Browser lacks native selectors")
        }
    }
      , k = (e,t,n)=>((e,n,o)=>{
        let r = e.dom;
        const s = a(o) ? o : u;
        for (; r.parentNode; ) {
            r = r.parentNode;
            const e = P(r);
            if (D(e, t))
                return d.some(e);
            if (s(e))
                break
        }
        return d.none()
    }
    )(e, 0, n)
      , R = (e,t,n)=>((e,t,n,o,r)=>e(n, o) ? d.some(n) : a(r) && r(n) ? d.none() : t(n, o, r))(((e,t)=>D(e, t)), k, e, t, n)
      , V = (e,t)=>e.dom.is(t, z(e))
      , z = x
      , B = "data-mce-mentions-id"
      , H = e=>{
        console.error(e)
    }
      , I = e=>e && "string" == typeof e.id && "string" == typeof e.name
      , W = e=>{
        I(e) || H("mentions_fetch didn't produce a valid list of users.")
    }
      , q = (e,t)=>{
        e.dom.appendChild(t.dom)
    }
      , F = (e,t)=>{
        e.dom.textContent = t
    }
      , K = e=>t=>{
        var n;
        t instanceof window.HTMLElement ? e(t) : (n = t,
        "profile" === n.type ? d.some((e=>{
            var t;
            const n = j("div");
            N(n, "tox"),
            N(n, "tox-mentions__card"),
            d.from(e.image).each((e=>{
                const t = j("img");
                M(t, "src", e),
                N(t, "tox-mentions__avatar"),
                q(n, t)
            }
            ));
            const o = j("div");
            N(o, "tox-mentions__container"),
            q(n, o);
            const r = j("div");
            return N(r, "tox-mentions__username"),
            F(r, null !== (t = e.fullName) && void 0 !== t ? t : e.name),
            q(o, r),
            d.from(e.description).map((e=>{
                const t = j("div");
                N(t, "tox-mentions__description"),
                F(t, e),
                q(o, t)
            }
            )),
            n
        }
        )(n.user)) : d.none()).each((t=>e(t.dom)))
    }
      , U = (e,t)=>({
        left: e,
        top: t,
        translate: (n,o)=>U(e + n, t + o)
    })
      , $ = U
      , G = (e,t)=>{
        let n;
        if (e.inline)
            return t;
        {
            n = tinymce.DOM.getPos(e.getContentAreaContainer());
            const o = (e=>{
                const t = void 0 !== e ? e.dom : document
                  , n = t.body.scrollLeft || t.documentElement.scrollLeft
                  , o = t.body.scrollTop || t.documentElement.scrollTop;
                return $(n, o)
            }
            )(P(e.getDoc()));
            return {
                ...t,
                x: t.x + n.x - o.left,
                y: t.y + n.y - o.top
            }
        }
    }
      , J = e=>{
        const t = tinymce.util.Delay
          , n = tinymce.util.Tools
          , o = {}
          , r = (e=>{
            const t = (e,t)=>a(e) ? e : t
              , n = (e,n)=>{
                let o;
                const r = t(e, n);
                return (...e)=>{
                    let t = {};
                    const n = e.map((e=>{
                        var n;
                        return "function" == typeof e && (n = e,
                        e = (...e)=>{
                            t === o && n(...e)
                        }
                        ),
                        e
                    }
                    ));
                    t = o = {},
                    r(...n)
                }
            }
              , o = n(g(e), c)
              , r = n(f(e), ((e,t)=>{
                t([])
            }
            ))
              , s = t(y(e), ((t,n)=>{
                const o = e.dom.create("span", {
                    class: "mention"
                });
                return o.appendChild(e.dom.doc.createTextNode("@" + n.name)),
                o
            }
            ))
              , i = t(_(e), c);
            return {
                hover: o,
                fetch: r,
                complete: s,
                select: n(b(e), c),
                cancel: i
            }
        }
        )(e);
        let s = null;
        const i = (()=>{
            const e = (e=>{
                const t = (e=>{
                    let t = e;
                    return {
                        get: ()=>t,
                        set: e=>{
                            t = e
                        }
                    }
                }
                )(d.none())
                  , n = ()=>t.get().each(e);
                return {
                    clear: ()=>{
                        n(),
                        t.set(d.none())
                    }
                    ,
                    isSet: ()=>t.get().isSome(),
                    get: ()=>t.get(),
                    set: e=>{
                        n(),
                        t.set(d.some(e))
                    }
                }
            }
            )(c);
            return {
                ...e,
                on: t=>e.get().each(t)
            }
        }
        )()
          , l = E(e)
          , u = T(e);
        let v, x;
        const w = ()=>{
            null !== s && null !== s.parentNode && (s.removeEventListener("mouseover", L),
            s.removeEventListener("mouseout", j),
            s.parentNode.removeChild(s)),
            s = null
        }
          , O = ()=>{
            w()
        }
          , A = n=>{
            clearTimeout(v),
            clearTimeout(x),
            v = t.setEditorTimeout(e, (()=>{
                return t = n,
                void r.select(t, K((n=>{
                    w(),
                    s = n,
                    s.addEventListener("mouseover", L),
                    s.addEventListener("mouseout", j),
                    s.style.position = "absolute",
                    s.style.left = "-10000px",
                    s.style.top = "-10000px",
                    N(P(s), "tox-mentions__card-common"),
                    document.body.appendChild(s),
                    ((e,t,n,o)=>{
                        let r;
                        const s = ((e,t)=>G(e, e.dom.getRect(t)))(e, n);
                        r = tinymce.DOM.getRect(t),
                        r = ((e,t,n)=>{
                            const o = tinymce.DOM.getViewPort()
                              , r = {
                                ...o,
                                w: o.w - 30,
                                h: o.h - 30
                            }
                              , s = tinymce.geom.Rect
                              , i = s.findBestRelativePosition(e, t, r, n);
                            return s.relativePosition(e, t, i || n[0] || "bl-tl")
                        }
                        )(r, s, o),
                        tinymce.DOM.setStyles(t, {
                            position: "absolute",
                            left: r.x,
                            top: r.y
                        })
                    }
                    )(e, s, t, ["bl-tl", "tl-bl", "tl-br", "bl-tr"])
                }
                )));
                var t
            }
            ), 0)
        }
          , L = ()=>{
            clearTimeout(x)
        }
          , j = ()=>{
            clearTimeout(x),
            clearTimeout(v),
            x = t.setEditorTimeout(e, O, 300)
        }
          , D = ()=>i.isSet() || V(e, e.selection.getNode()) && !e.selection.isCollapsed()
          , k = "name" === u ? (e,t)=>({
            type: "autocompleteitem",
            value: e.id,
            text: e.name,
            meta: {
                user: e,
                tooltipWorker: t
            }
        }) : (e,t)=>{
            const n = S(e, "image").map((t=>({
                type: "cardimage",
                src: t,
                classes: ["tox-mentions__avatar"],
                alt: e.name
            }))).toArray()
              , o = S(e, "description").map((e=>({
                type: "cardtext",
                text: e,
                classes: ["tox-mentions__description"]
            }))).toArray();
            return {
                type: "cardmenuitem",
                value: e.id,
                label: e.name,
                items: [...n, {
                    type: "cardcontainer",
                    direction: "vertical",
                    items: [{
                        type: "cardtext",
                        text: e.name,
                        name: "username",
                        classes: ["tox-mentions__username"]
                    }, ...o]
                }],
                meta: {
                    user: e,
                    tooltipWorker: t
                }
            }
        }
        ;
        e.ui.registry.addAutocompleter("mentions", {
            ch: "@",
            minChars: l,
            maxResults: 10,
            highlightOn: ["username"],
            onAction: (t,n,s,i)=>{
                if (((e,t,n=m)=>e.exists((e=>n(e, t))))(S(i, "reload"), !0)) {
                    const {reload: e, ...n} = i;
                    t.reload(n)
                } else
                    ((t,n)=>{
                        const s = r.complete(e, t);
                        ((e,t)=>{
                            const n = V(e, t);
                            return n || H("mentions_complete needs to produce a element that matches selector: " + z(e)),
                            n
                        }
                        )(e, s) && (s.contentEditable = "false",
                        s.setAttribute(B, t.id),
                        o[t.id] = t,
                        e.selection.setRng(n),
                        e.insertContent(s.outerHTML))
                    }
                    )(i.user, n),
                    t.hide()
            }
            ,
            fetch: (e,t,o)=>new Promise((s=>{
                ((e,t,o,i)=>{
                    r.fetch({
                        term: e,
                        meta: o
                    }, ((e,o)=>{
                        n.each(e, W);
                        const i = e.slice(0, t);
                        ((e,t)=>{
                            s(((e,t=[])=>{
                                const n = h(e, (e=>k(e, (t=>{
                                    r.hover(e, K(t))
                                }
                                ))))
                                  , o = h(t, (e=>({
                                    value: void 0 === e.value ? "" : e.value,
                                    text: e.text,
                                    meta: {
                                        ...e.meta,
                                        reload: !0
                                    }
                                })));
                                return [...n, ...o.length > 0 ? [{
                                    type: "separator"
                                }] : [], ...o]
                            }
                            )(e, t))
                        }
                        )(n.grep(i, I), o)
                    }
                    ))
                }
                )(e, t, o)
            }
            )),
            columns: 1
        }),
        (e=>{
            e.on("SetContent", (()=>{
                ((e,t)=>{
                    p(e.dom.select(z(e), void 0), (e=>M(P(e), "contenteditable", "false")))
                }
                )(e)
            }
            )),
            e.on("PreProcess", (t=>{
                ((e,t,n)=>{
                    p(e.dom.select(z(e), t), (e=>{
                        const t = P(e);
                        C(t, "contenteditable"),
                        n || C(t, B)
                    }
                    ))
                }
                )(e, t.node, t.source_view)
            }
            )),
            e.on("ResolveName", (t=>{
                V(e, t.target) && (t.name = "mention")
            }
            ))
        }
        )(e),
        e.on("mouseover", (t=>{
            R(P(t.target), z(e)).each((e=>{
                i.set(!0),
                A(e.dom)
            }
            ))
        }
        )),
        e.on("mouseout", (t=>{
            R(P(t.target), z(e)).each((()=>{
                i.clear(),
                D() || O()
            }
            ))
        }
        )),
        e.on("nodechange", (t=>{
            V(e, t.element) && !e.selection.isCollapsed() ? A(t.element) : D() || j()
        }
        )),
        e.on("remove", w)
    }
    ;
    tinymce.PluginManager.add("mentions", ((e,n)=>{
        ((e,n)=>!!e && -1 === ((e,n)=>{
            const o = t(e.major, n.major);
            if (0 !== o)
                return o;
            const r = t(e.minor, n.minor);
            if (0 !== r)
                return r;
            const s = t(e.patch, n.patch);
            return 0 !== s ? s : 0
        }
        )((e=>o((e=>[e.majorVersion, e.minorVersion].join(".").split(".").slice(0, 3).join("."))(e)))(e), o(n)))(tinymce, "6.0.0") ? console.error("The mentions plugin requires at least version 6.0.0 of TinyMCE.") : (((e,t)=>{
            const n = e.options.register;
            p(["mentions_menu_hover", "mentions_fetch", "mentions_menu_complete", "mentions_menu_cancel", "mentions_select"], (e=>{
                n(e, {
                    processor: "function"
                })
            }
            )),
            n("mentions_selector", {
                processor: "string",
                default: ".mention"
            }),
            n("mentions_css_url", {
                processor: "string",
                default: t + "/css"
            }),
            n("mentions_item_type", {
                processor: "string",
                default: "name"
            }),
            n("mentions_min_chars", {
                processor: "number",
                default: 1
            })
        }
        )(e, n),
        J(e),
        e.on("init", (()=>{
            (e=>{
                var t;
                const n = w(e) + "/";
                d.from(null === (t = e.ui) || void 0 === t ? void 0 : t.styleSheetLoader).getOr(tinymce.DOM.styleSheetLoader).load(n + "mentions.css")
            }
            )(e)
        }
        )))
    }
    ))
}();
