/*!
 * Tiny Link Checker plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 3.0.2-28
 */

!function() {
    "use strict";
    const e = Object.getPrototypeOf
      , t = (e,t,r)=>{
        var n;
        return !!r(e, t.prototype) || (null === (n = e.constructor) || void 0 === n ? void 0 : n.name) === t.name
    }
      , r = e=>r=>(e=>{
        const r = typeof e;
        return null === e ? "null" : "object" === r && Array.isArray(e) ? "array" : "object" === r && t(e, String, ((e,t)=>t.isPrototypeOf(e))) ? "string" : r
    }
    )(r) === e
      , n = e=>t=>typeof t === e
      , o = r("object")
      , s = r=>((r,n)=>o(r) && t(r, n, ((t,r)=>e(t) === r)))(r, Object)
      , a = r("array")
      , c = n("boolean")
      , u = e=>!(e=>null == e)(e)
      , i = n("function");
    class l {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new l(!0,e)
        }
        static none() {
            return l.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? l.some(e(this.value)) : l.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : l.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : l.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return u(e) ? l.some(e) : l.none()
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    l.singletonNone = new l(!1);
    const p = e=>parseInt(e, 10)
      , h = (e,t)=>{
        const r = e - t;
        return 0 === r ? 0 : r > 0 ? 1 : -1
    }
      , d = (e,t,r)=>({
        major: e,
        minor: t,
        patch: r
    })
      , m = e=>{
        const t = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(e);
        return t ? d(p(t[1]), p(t[2]), p(t[3])) : d(0, 0, 0)
    }
      , g = ()=>{}
      , f = (e,t)=>(...r)=>e(t.apply(null, r))
      , k = e=>()=>e
      , v = e=>e
      , y = e=>e()
      , w = k(!1)
      , b = k(!0)
      , T = e=>t=>t.options.get(e)
      , x = T("linkchecker_content_css")
      , O = T("linkchecker_service_url")
      , E = T("linkchecker_preprocess")
      , S = T("contextmenu")
      , j = (e,t)=>{
        let r;
        const n = (...n)=>{
            clearTimeout(r),
            r = setTimeout((function() {
                e.apply(this, n)
            }
            ), t)
        }
        ;
        return n.stop = ()=>{
            clearTimeout(r)
        }
        ,
        n
    }
      , A = Array.prototype.indexOf
      , R = Array.prototype.push
      , _ = (e,t)=>{
        const r = e.length
          , n = new Array(r);
        for (let o = 0; o < r; o++) {
            const r = e[o];
            n[o] = t(r, o)
        }
        return n
    }
      , C = (e,t)=>{
        for (let r = 0, n = e.length; r < n; r++)
            t(e[r], r)
    }
      , N = (e,t,r)=>(C(e, ((e,n)=>{
        r = t(r, e, n)
    }
    )),
    r)
      , D = e=>{
        const t = [];
        for (let r = 0, n = e.length; r < n; ++r) {
            if (!a(e[r]))
                throw new Error("Arr.flatten item " + r + " was not an array, input: " + e);
            R.apply(t, e[r])
        }
        return t
    }
      , M = Object.keys
      , U = Object.hasOwnProperty
      , F = (e,t)=>{
        const r = M(e);
        for (let n = 0, o = r.length; n < o; n++) {
            const o = r[n];
            t(e[o], o)
        }
    }
      , I = (e,t)=>J(e, ((e,r)=>({
        k: r,
        v: t(e, r)
    })))
      , J = (e,t)=>{
        const r = {};
        return F(e, ((e,n)=>{
            const o = t(e, n);
            r[o.k] = o.v
        }
        )),
        r
    }
      , q = (e,t)=>{
        const r = [];
        return F(e, ((e,n)=>{
            r.push(t(e, n))
        }
        )),
        r
    }
      , L = (e,t)=>P(e, t) ? l.from(e[t]) : l.none()
      , P = (e,t)=>U.call(e, t)
      , V = e=>{
        if (!a(e))
            throw new Error("cases must be an array");
        if (0 === e.length)
            throw new Error("there must be at least one case");
        const t = []
          , r = {};
        return C(e, ((n,o)=>{
            const s = M(n);
            if (1 !== s.length)
                throw new Error("one and only one name per case");
            const c = s[0]
              , u = n[c];
            if (void 0 !== r[c])
                throw new Error("duplicate key detected:" + c);
            if ("cata" === c)
                throw new Error("cannot have a case named cata (sorry)");
            if (!a(u))
                throw new Error("case arguments must be an array");
            t.push(c),
            r[c] = (...r)=>{
                const n = r.length;
                if (n !== u.length)
                    throw new Error("Wrong number of arguments to case " + c + ". Expected " + u.length + " (" + u + "), got " + n);
                return {
                    fold: (...t)=>{
                        if (t.length !== e.length)
                            throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                        return t[o].apply(null, r)
                    }
                    ,
                    match: e=>{
                        const n = M(e);
                        if (t.length !== n.length)
                            throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + n.join(","));
                        if (!((e,t)=>{
                            for (let t = 0, o = e.length; t < o; ++t)
                                if (!0 !== (r = e[t],
                                ((e,t)=>{
                                    return r = e,
                                    n = t,
                                    A.call(r, n) > -1;
                                    var r, n
                                }
                                )(n, r)))
                                    return !1;
                            var r;
                            return !0
                        }
                        )(t))
                            throw new Error("Not all branches were specified when using match. Specified: " + n.join(", ") + "\nRequired: " + t.join(", "));
                        return e[c].apply(null, r)
                    }
                    ,
                    log: e=>{
                        console.log(e, {
                            constructors: t,
                            constructor: c,
                            params: r
                        })
                    }
                }
            }
        }
        )),
        r
    }
      , B = V([{
        invalid: ["invalidUrl"]
    }, {
        unknown: ["unknownUrl"]
    }, {
        valid: ["validUrl"]
    }])
      , $ = (e,t,r,n)=>e.fold(t, r, n)
      , H = e=>/^https?:\/\//.test(e)
      , z = e=>(e=>0 === e.indexOf("mailto:"))(e) || (e=>"#" === e.charAt(0))(e)
      , K = tinymce.DOM
      , W = tinymce.util.Tools
      , X = "data-mce-linkchecker-status"
      , Y = "data-mce-linkchecker-focus"
      , G = e=>{
        const t = K.select('a[href]:not([href=""])', e);
        return W.map(t, (e=>K.getAttrib(e, "href")))
    }
      , Q = (e,t)=>{
        K.setAttrib(e, X, t),
        te(e) && K.setAttrib(e, "aria-invalid", !0)
    }
      , Z = (e,t)=>W.map(t, (t=>({
        url: e(K.getAttrib(t, "href")),
        elm: t
    })))
      , ee = (e,t)=>W.grep(e, (e=>e.url === t))
      , te = e=>"invalid" === K.getAttrib(e, X)
      , re = e=>t=>{
        W.each(t, (t=>{
            t.attr(e, null)
        }
        ))
    }
      , ne = e=>t=>{
        const r = t.trim()
          , n = (e=>!H(e) && (e=>/^\w+:/.test(e))(e))(r) ? r : e.documentBaseURI.toAbsolute(r)
          , o = (e=>e.replace(/ /g, "%20"))(0 === n.indexOf("//") ? window.location.protocol + n : n);
        return (e=>{
            const t = document.createElement("a");
            return t.href = e,
            H(e) ? t.href : e
        }
        )(o)
    }
      , oe = e=>()=>{
        e.execCommand("mceLink")
    }
      , se = (e,t)=>()=>{
        (e=>{
            const t = document.createElement("a");
            t.target = "_blank",
            t.href = e,
            t.rel = "noreferrer noopener";
            const r = document.createEvent("MouseEvents");
            r.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null),
            t.dispatchEvent(r)
        }
        )(ne(e)(tinymce.DOM.getAttrib(t, "href")))
    }
      , ae = (e,t)=>()=>{
        e.undoManager.transact((()=>{
            tinymce.DOM.remove(t, !0)
        }
        ))
    }
      , ce = (e,t)=>()=>{
        e.add(t.href),
        (e=>{
            Q(e, "ignored")
        }
        )(t)
    }
      , ue = (e,t,r)=>[{
        text: "Ignore",
        onAction: ce(r, t)
    }]
      , ie = tinymce.util.Tools
      , le = (e,t)=>ie.grep(e, (e=>!t.has(e)))
      , pe = e=>t=>H(t) === e
      , he = (e,t,r,n,o)=>{
        const s = o.getBody();
        ((e,t,r,n,o)=>{
            const s = ie.grep(ie.map(G(o), r), pe(!0));
            e.checkMany(le(s, t)).get((e=>{
                e.fold(n.logError, (e=>((e,t,r)=>{
                    const n = Z(t, K.select("a[href]", e));
                    W.each(r, ((e,t)=>{
                        W.each(ee(n, t), (t=>{
                            $(e.result, (e=>{
                                Q(t.elm, "invalid")
                            }
                            ), (e=>{
                                Q(t.elm, "unknown")
                            }
                            ), (e=>{
                                Q(t.elm, "valid")
                            }
                            ))
                        }
                        ))
                    }
                    ))
                }
                )(o, r, e)))
            }
            ))
        }
        )(e, t, r, n, s),
        ((e,t,r,n,o)=>{
            const s = ie.grep(ie.map(G(o), r), pe(!1));
            var a;
            ((e,t,r)=>{
                const n = Z(t, K.select("a[href]", e));
                W.each(r, (e=>{
                    W.each(ee(n, e), (e=>{
                        Q(e.elm, "unknown")
                    }
                    ))
                }
                ))
            }
            )(o, r, le((a = s,
            ie.grep(a, (e=>!z(e)))), t))
        }
        )(0, t, r, 0, s)
    }
      , de = (e,t,r,n,o)=>{
        const s = j(he, 500);
        var a;
        (a = e.serializer).addTempAttr(X),
        a.addTempAttr(Y),
        a.addAttributeFilter(X, re(X)),
        a.addAttributeFilter(Y, re(X)),
        e.dom.loadCSS(x(e)),
        e.on("change setContent undo redo", (()=>{
            s(n, t, r, o, e)
        }
        )),
        he(n, t, r, o, e),
        ((e,t)=>{
            e.ui.registry.addContextMenu("linkchecker", {
                update: r=>{
                    const n = e.dom.getParent(r, "a[href]");
                    return u(n) && te(n) ? ((e,t,r)=>{
                        const n = ((e,t)=>{
                            const r = [];
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                "" !== n && r.push(n)
                            }
                            return r
                        }
                        )(S(e));
                        if (0 !== n.length && -1 === n.indexOf("link")) {
                            const n = [{
                                text: "Remove link",
                                icon: "unlink",
                                onAction: ae(e, r)
                            }, {
                                text: "Open link",
                                icon: "new-tab",
                                onAction: se(e, r)
                            }, {
                                type: "separator"
                            }];
                            return (e=>e.plugins.link ? [{
                                text: "Link...",
                                icon: "link",
                                onAction: oe(e)
                            }] : [])(e).concat(n).concat(ue(0, r, t))
                        }
                        return ue(0, r, t)
                    }
                    )(e, t, n) : []
                }
            })
        }
        )(e, t)
    }
      , me = (e,t)=>()=>({
        status: e,
        message: t
    })
      , ge = me("invalid", "URL does not seem to be valid")
      , fe = me("none", "")
      , ke = me("valid", "The URL seems to be valid")
      , ve = e=>{
        const t = t=>t(e)
          , r = k(e)
          , n = ()=>o
          , o = {
            tag: !0,
            inner: e,
            fold: (t,r)=>r(e),
            isValue: b,
            isError: w,
            map: t=>we.value(t(e)),
            mapError: n,
            bind: t,
            exists: t,
            forall: t,
            getOr: r,
            or: n,
            getOrThunk: r,
            orThunk: n,
            getOrDie: r,
            each: t=>{
                t(e)
            }
            ,
            toOptional: ()=>l.some(e)
        };
        return o
    }
      , ye = e=>{
        const t = ()=>r
          , r = {
            tag: !1,
            inner: e,
            fold: (t,r)=>t(e),
            isValue: w,
            isError: b,
            map: t,
            mapError: t=>we.error(t(e)),
            bind: t,
            exists: w,
            forall: b,
            getOr: v,
            or: v,
            getOrThunk: y,
            orThunk: y,
            getOrDie: (n = String(e),
            ()=>{
                throw new Error(n)
            }
            ),
            each: g,
            toOptional: l.none
        };
        var n;
        return r
    }
      , we = {
        value: ve,
        error: ye,
        fromOption: (e,t)=>e.fold((()=>ye(t)), ve)
    };
    var be;
    !function(e) {
        e[e.Error = 0] = "Error",
        e[e.Value = 1] = "Value"
    }(be || (be = {}));
    const Te = (e,t,r)=>e.stype === be.Error ? t(e.serror) : r(e.svalue)
      , xe = e=>({
        stype: be.Value,
        svalue: e
    })
      , Oe = e=>({
        stype: be.Error,
        serror: e
    })
      , Ee = Te
      , Se = e=>o(e) && M(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2)
      , je = (e,t)=>Oe([{
        path: e,
        getErrorInfo: t
    }])
      , Ae = e=>(...t)=>{
        if (0 === t.length)
            throw new Error("Can't merge zero objects");
        const r = {};
        for (let n = 0; n < t.length; n++) {
            const o = t[n];
            for (const t in o)
                P(o, t) && (r[t] = e(r[t], o[t]))
        }
        return r
    }
      , Re = Ae(((e,t)=>s(e) && s(t) ? Re(e, t) : t))
      , _e = (Ae(((e,t)=>t)),
    e=>f(Oe, D)(e))
      , Ce = e=>{
        const t = (e=>{
            const t = []
              , r = [];
            return C(e, (e=>{
                Te(e, (e=>r.push(e)), (e=>t.push(e)))
            }
            )),
            {
                values: t,
                errors: r
            }
        }
        )(e);
        return t.errors.length > 0 ? _e(t.errors) : xe(t.values)
    }
      , Ne = (e,t,r)=>{
        switch (e.tag) {
        case "field":
            return t(e.key, e.newKey, e.presence, e.prop);
        case "custom":
            return r(e.newKey, e.instantiator)
        }
    }
      , De = (Me = xe,
    {
        extract: (e,t)=>{
            return r = Me(t),
            n = t=>((e,t)=>je(e, k(t)))(e, t),
            r.stype === be.Error ? n(r.serror) : r;
            var r, n
        }
        ,
        toString: k("val")
    });
    var Me;
    const Ue = (e,t,r,n)=>n(L(e, t).getOrThunk((()=>r(e))))
      , Fe = (e,t,r,n,o)=>{
        const s = e=>o.extract(t.concat([n]), e)
          , a = e=>e.fold((()=>xe(l.none())), (e=>{
            const r = o.extract(t.concat([n]), e);
            return s = r,
            a = l.some,
            s.stype === be.Value ? {
                stype: be.Value,
                svalue: a(s.svalue)
            } : s;
            var s, a
        }
        ));
        switch (e.tag) {
        case "required":
            return ((e,t,r,n)=>L(t, r).fold((()=>((e,t,r)=>je(e, (()=>'Could not find valid *required* value for "' + t + '" in ' + Se(r))))(e, r, t)), n))(t, r, n, s);
        case "defaultedThunk":
            return Ue(r, n, e.process, s);
        case "option":
            return ((e,t,r)=>r(L(e, t)))(r, n, a);
        case "defaultedOptionThunk":
            return ((e,t,r,n)=>n(L(e, t).map((t=>!0 === t ? r(e) : t))))(r, n, e.process, a);
        case "mergeWithThunk":
            return Ue(r, n, k({}), (t=>{
                const n = Re(e.process(r), t);
                return s(n)
            }
            ))
        }
    }
      , Ie = e=>({
        extract: (t,r)=>((e,t,r)=>{
            const n = {}
              , o = [];
            for (const s of r)
                Ne(s, ((r,s,a,c)=>{
                    const u = Fe(a, e, t, r, c);
                    Ee(u, (e=>{
                        o.push(...e)
                    }
                    ), (e=>{
                        n[s] = e
                    }
                    ))
                }
                ), ((e,r)=>{
                    n[e] = r(t)
                }
                ));
            return o.length > 0 ? Oe(o) : xe(n)
        }
        )(t, r, e),
        toString: ()=>{
            const t = _(e, (e=>Ne(e, ((e,t,r,n)=>e + " -> " + n.toString()), ((e,t)=>"state(" + e + ")"))));
            return "obj{\n" + t.join("\n") + "}"
        }
    })
      , Je = f((e=>({
        extract: (t,r)=>{
            const n = _(r, ((r,n)=>e.extract(t.concat(["[" + n + "]"]), r)));
            return Ce(n)
        }
        ,
        toString: ()=>"array(" + e.toString() + ")"
    })), Ie)
      , qe = (e,t,r)=>{
        return n = ((e,t,r)=>((e,t)=>e.stype === be.Error ? {
            stype: be.Error,
            serror: t(e.serror)
        } : e)(t.extract([e], r), (e=>({
            input: r,
            errors: e
        }))))(e, t, r),
        Te(n, we.error, we.value);
        var n
    }
      , Le = (e,t,r)=>qe(e, t, r).fold((e=>{
        throw new Error(Pe(e))
    }
    ), v)
      , Pe = e=>"Errors: \n" + (e=>{
        const t = e.length > 10 ? e.slice(0, 10).concat([{
            path: [],
            getErrorInfo: k("... (only showing first ten failures)")
        }]) : e;
        return _(t, (e=>"Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()))
    }
    )(e.errors).join("\n") + "\n\nInput object: " + Se(e.input)
      , Ve = ()=>(new Date).getTime();
    var Be;
    !function(e) {
        e.JSON = "json",
        e.Blob = "blob",
        e.Text = "text",
        e.FormData = "formdata",
        e.MultipartFormData = "multipart/form-data"
    }(Be || (Be = {}));
    const $e = e=>{
        let t = l.none()
          , r = [];
        const n = e=>{
            o() ? s(e) : r.push(e)
        }
          , o = ()=>t.isSome()
          , s = e=>{
            t.each((t=>{
                setTimeout((()=>{
                    e(t)
                }
                ), 0)
            }
            ))
        }
        ;
        return e((e=>{
            o() || (t = l.some(e),
            C(r, s),
            r = [])
        }
        )),
        {
            get: n,
            map: e=>$e((t=>{
                n((r=>{
                    t(e(r))
                }
                ))
            }
            )),
            isReady: o
        }
    }
      , He = {
        nu: $e,
        pure: e=>$e((t=>{
            t(e)
        }
        ))
    }
      , ze = e=>{
        setTimeout((()=>{
            throw e
        }
        ), 0)
    }
      , Ke = e=>{
        const t = t=>{
            e().then(t, ze)
        }
        ;
        return {
            map: t=>Ke((()=>e().then(t))),
            bind: t=>Ke((()=>e().then((e=>t(e).toPromise())))),
            anonBind: t=>Ke((()=>e().then((()=>t.toPromise())))),
            toLazy: ()=>He.nu(t),
            toCached: ()=>{
                let t = null;
                return Ke((()=>(null === t && (t = e()),
                t)))
            }
            ,
            toPromise: e,
            get: t
        }
    }
      , We = e=>Ke((()=>new Promise(e)))
      , Xe = e=>Ke((()=>Promise.resolve(e)))
      , Ye = e=>({
        ...e,
        toCached: ()=>Ye(e.toCached()),
        bindFuture: t=>Ye(e.bind((e=>e.fold((e=>Xe(we.error(e))), (e=>t(e)))))),
        bindResult: t=>Ye(e.map((e=>e.bind(t)))),
        mapResult: t=>Ye(e.map((e=>e.map(t)))),
        mapError: t=>Ye(e.map((e=>e.mapError(t)))),
        foldResult: (t,r)=>e.map((e=>e.fold(t, r))),
        withTimeout: (t,r)=>Ye(We((n=>{
            let o = !1;
            const s = setTimeout((()=>{
                o = !0,
                n(we.error(r()))
            }
            ), t);
            e.get((e=>{
                o || (clearTimeout(s),
                n(e))
            }
            ))
        }
        )))
    })
      , Ge = e=>Ye(We(e))
      , Qe = e=>Ye(Xe(we.value(e)))
      , Ze = {
        nu: Ge,
        wrap: Ye,
        pure: Qe,
        value: Qe,
        error: e=>Ye(Xe(we.error(e))),
        fromResult: e=>Ye(Xe(e)),
        fromFuture: e=>Ye(e.map(we.value)),
        fromPromise: e=>Ge((t=>{
            e.then((e=>{
                t(we.value(e))
            }
            ), (e=>{
                t(we.error(e))
            }
            ))
        }
        ))
    };
    "undefined" != typeof window ? window : Function("return this;")();
    const et = e=>We((t=>{
        const r = new FileReader;
        r.onload = e=>{
            const r = e.target ? e.target.result : "";
            t(r)
        }
        ,
        r.readAsText(e)
    }
    ))
      , tt = e=>{
        try {
            const t = JSON.parse(e);
            return we.value(t)
        } catch (e) {
            return we.error("Response was not JSON.")
        }
    }
      , rt = e=>Xe(e.response)
      , nt = e=>Ze.nu((t=>{
        const r = new XMLHttpRequest;
        var n;
        r.open(e.method, (n = e.url,
        l.from(e.query).map((e=>{
            const t = q(e, ((e,t)=>encodeURIComponent(t) + "=" + encodeURIComponent(e)))
              , r = ("?",
            -1 !== n.indexOf("?") ? "&" : "?");
            return t.length > 0 ? n + r + t.join("&") : n
        }
        )).getOr(n)), !0);
        const o = (e=>{
            const t = (r = e.body,
            l.from(r).bind((e=>{
                switch (e.type) {
                case Be.JSON:
                    return l.some("application/json");
                case Be.FormData:
                    return l.some("application/x-www-form-urlencoded; charset=UTF-8");
                case Be.MultipartFormData:
                    return l.none();
                case Be.Text:
                default:
                    return l.some("text/plain")
                }
            }
            )));
            var r;
            const n = !0 === e.credentials ? l.some(!0) : l.none()
              , o = (e=>{
                switch (e) {
                case Be.Blob:
                    return "application/octet-stream";
                case Be.JSON:
                    return "application/json, text/javascript";
                case Be.Text:
                    return "text/plain";
                default:
                    return ""
                }
            }
            )(e.responseType) + ", */*; q=0.01"
              , s = void 0 !== e.headers ? e.headers : {};
            return {
                contentType: t,
                responseType: (e=>{
                    switch (e) {
                    case Be.JSON:
                        return l.none();
                    case Be.Blob:
                        return l.some("blob");
                    case Be.Text:
                        return l.some("text");
                    default:
                        return l.none()
                    }
                }
                )(e.responseType),
                credentials: n,
                accept: o,
                headers: s,
                progress: i(e.progress) ? l.some(e.progress) : l.none()
            }
        }
        )(e);
        ((e,t)=>{
            t.contentType.each((t=>e.setRequestHeader("Content-Type", t))),
            e.setRequestHeader("Accept", t.accept),
            t.credentials.each((t=>e.withCredentials = t)),
            t.responseType.each((t=>e.responseType = t)),
            t.progress.each((t=>e.upload.addEventListener("progress", (e=>t(e.loaded, e.total))))),
            F(t.headers, ((t,r)=>e.setRequestHeader(r, t)))
        }
        )(r, o);
        const s = ()=>{
            ((e,t,r)=>((e,t)=>{
                switch (e) {
                case Be.JSON:
                    return tt(t.response).fold((()=>rt(t)), Xe);
                case Be.Blob:
                    return (e=>l.from(e.response).map(et).getOr(Xe("no response content")))(t);
                case Be.Text:
                default:
                    return rt(t)
                }
            }
            )(t, r).map((t=>({
                message: 0 === r.status ? "Unknown HTTP error (possible cross-domain request)" : `Could not load url ${e}: ${r.statusText}`,
                status: r.status,
                responseText: t
            }))))(e.url, e.responseType, r).get((e=>t(we.error(e))))
        }
        ;
        var a;
        r.onerror = s,
        r.onload = ()=>{
            var n, o;
            0 !== r.status || (n = e.url,
            o = "file:",
            n.length >= o.length && n.substr(0, 0 + o.length) === o) ? r.status < 100 || r.status >= 400 ? s() : ((e,t)=>{
                const r = e=>Ze.error({
                    message: e,
                    status: t.status,
                    responseText: t.responseText
                });
                switch (e) {
                case Be.JSON:
                    return tt(t.response).fold(r, Ze.pure);
                case Be.Blob:
                case Be.Text:
                    return Ze.pure(t.response);
                default:
                    return r("unknown data type")
                }
            }
            )(e.responseType, r).get(t) : s()
        }
        ,
        (a = e.body,
        l.from(a).map((e=>e.type === Be.JSON ? JSON.stringify(e.data) : e.type === Be.FormData || e.type === Be.MultipartFormData ? (e=>{
            const t = new FormData;
            return F(e, ((e,r)=>{
                t.append(r, e)
            }
            )),
            t
        }
        )(e.data) : e.data))).fold((()=>r.send()), (e=>{
            r.send(e)
        }
        ))
    }
    ))
      , ot = (e,t)=>{
        const r = -1 === e.indexOf("?") ? "?" : "&";
        return t ? e + r + "apiKey=" + encodeURIComponent(t) : e
    }
      , st = e=>L(e, "tiny-api-key").orThunk((()=>L(e, "tinymce-api-key"))).orThunk((()=>L(e, "textbox-api-key"))).getOrUndefined()
      , at = e=>{
        const t = e.responseText;
        return o(t) ? t : e.message
    }
    ;
    V([{
        bothErrors: ["error1", "error2"]
    }, {
        firstError: ["error1", "value2"]
    }, {
        secondError: ["value1", "error2"]
    }, {
        bothValues: ["value1", "value2"]
    }]);
    const ct = k(De)
      , ut = (e,t,r,n)=>({
        tag: "field",
        key: e,
        newKey: t,
        presence: r,
        prop: n
    })
      , it = [("url",
    ut("url", "url", {
        tag: "required",
        process: {}
    }, ct())), ((e,t)=>ut(e, e, {
        tag: "defaultedThunk",
        process: k(!1)
    }, ct()))("fresh")];
    const lt = Ie(it)
      , pt = Ie([ut("urls", "urls", {
        tag: "required",
        process: {}
    }, Je(it))])
      , ht = (e,t,r)=>{
        const n = ((e,t=36e5)=>{
            const r = {}
              , n = (e,t,n)=>{
                r[e] = {
                    result: t,
                    timestamp: n
                }
            }
              , s = (e,r)=>e - r < t
              , a = k(r);
            return o(e) && (e=>{
                const t = Ve();
                F(e, ((e,r)=>{
                    s(t, e.timestamp) && n(r, e.result, e.timestamp)
                }
                ))
            }
            )(e),
            {
                set: n,
                get: (e,t)=>l.from(r[t]).filter((t=>s(e, t.timestamp))).map((e=>e.result)),
                dump: a
            }
        }
        )(r)
          , s = ((e,t,r=at)=>{
            const n = st(t);
            return {
                execute: o=>{
                    const s = I(o, (e=>c(e) ? String(e) : e))
                      , a = ot((u = s,
                    e.replace(/\$\{([^{}]*)\}/g, ((e,t)=>{
                        const r = u[t];
                        return (e=>{
                            const t = typeof e;
                            return "string" === t || "number" === t
                        }
                        )(r) ? r.toString() : e
                    }
                    ))), n);
                    var u;
                    const i = (l = {
                        url: a,
                        responseType: Be.JSON,
                        credentials: !0,
                        headers: t
                    },
                    nt({
                        ...l,
                        method: "get",
                        body: {
                            type: Be.Text,
                            data: ""
                        }
                    })).mapError(r);
                    var l;
                    return Ze.wrap(i)
                }
                ,
                cancelCurrent: g
            }
        }
        )(e + "/1/check?url=${url}&fresh=${fresh}", t)
          , a = ((e,t,r=at)=>{
            const n = st(t);
            return {
                execute: o=>{
                    const s = (a = {
                        url: ot(e, n),
                        body: (c = o,
                        {
                            type: Be.JSON,
                            data: c
                        }),
                        responseType: Be.JSON,
                        credentials: !0,
                        headers: t
                    },
                    nt({
                        ...a,
                        method: "post"
                    })).mapError(r);
                    var a, c;
                    return Ze.wrap(s)
                }
                ,
                cancelCurrent: g
            }
        }
        )(e + "/1/check", t)
          , u = e=>{
            return {
                url: e.url,
                result: (t = e.url,
                r = e.result,
                "VALID" === r ? B.valid(t) : "INVALID" === r ? B.invalid(t) : B.unknown(t))
            };
            var t, r
        }
        ;
        return {
            checkOne: (e,t=!1)=>{
                const r = Ve()
                  , o = ((t,r,n,o,a)=>(a ? l.none() : r.get(o, n)).fold((()=>((t,r)=>{
                    const n = {
                        url: encodeURIComponent(e),
                        fresh: r
                    }
                      , o = Le("ephox.link.service.one.ajax.service.get", lt, n);
                    return s.execute(o)
                }
                )(0, a).mapResult((e=>(r.set(n, e, o),
                e)))), (e=>Ze.pure(e))))(0, n, e, r, t);
                return o.mapResult(u)
            }
            ,
            checkMany: (e,t=!1)=>{
                const r = Ve();
                return ((e,t,r,n,o,s)=>{
                    const a = ((e,t,r,n,o)=>o ? {
                        known: {},
                        unknown: r
                    } : N(r, ((r,o)=>{
                        const s = n(o);
                        return e(t, s).fold((()=>({
                            known: r.known,
                            unknown: r.unknown.concat([o])
                        })), (e=>{
                            const t = ((e,t)=>((e,t)=>({
                                [e]: t
                            }))(e, t))(s, e);
                            return {
                                known: {
                                    ...r.known,
                                    ...t
                                },
                                unknown: r.unknown
                            }
                        }
                        ))
                    }
                    ), {
                        known: {},
                        unknown: []
                    }))(t.get, o, r, n, s);
                    return 0 === a.unknown.length ? Ze.value(a.known) : ((e,t,r,n,o,s)=>e(n, s).mapResult((e=>(F(e, ((e,r)=>{
                        t.set(r, e, o)
                    }
                    )),
                    {
                        ...r,
                        ...e
                    }))))(e, t, a.known, a.unknown, o, s)
                }
                )(((e,t)=>{
                    const r = Le("ephox.link.service.many.ajax.service.post", pt, {
                        urls: e
                    });
                    return a.execute(r).mapResult((e=>N(e.results, ((e,t)=>(e[t.url] = t,
                    e)), {})))
                }
                ), n, e, (e=>e.url), r, t).mapResult((e=>I(e, u)))
            }
            ,
            dumpCache: n.dump
        }
    }
      , dt = e=>{
        const t = (r = O(e),
        n = (e=>{
            var t;
            return null !== (t = e.options.get("api_key")) && void 0 !== t ? t : e.options.get("linkchecker_api_key")
        }
        )(e),
        ht(r, n ? {
            "tinymce-api-key": n
        } : {}));
        var r, n;
        const o = t=>E(e)(t);
        return {
            checkOne: e=>{
                const r = o({
                    url: e
                });
                return t.checkOne(r.url)
            }
            ,
            checkMany: e=>((e,t,r)=>{
                const n = ((e,t)=>N(e, ((e,r)=>{
                    const n = {
                        ...t({
                            url: r
                        }),
                        origUrl: r
                    }
                      , o = n.url;
                    return {
                        ...e,
                        [o]: P(e, o) ? e[o].concat([n]) : [n]
                    }
                }
                ), {}))(e, t);
                return r(_(q(n, v), (e=>e[0]))).mapResult((e=>((e,t)=>{
                    const r = {};
                    return F(e, ((e,n)=>{
                        const o = t[n];
                        C(o, (t=>{
                            r[t.origUrl] = e
                        }
                        ))
                    }
                    )),
                    r
                }
                )(e, n)))
            }
            )(e, o, (e=>t.checkMany(e)))
        }
    }
    ;
    tinymce.PluginManager.add("linkchecker", ((e,t)=>{
        if (((e,t)=>!!e && -1 === ((e,t)=>{
            const r = h(e.major, t.major);
            if (0 !== r)
                return r;
            const n = h(e.minor, t.minor);
            if (0 !== n)
                return n;
            const o = h(e.patch, t.patch);
            return 0 !== o ? o : 0
        }
        )((e=>m((e=>[e.majorVersion, e.minorVersion].join(".").split(".").slice(0, 3).join("."))(e)))(e), m(t)))(tinymce, "6.0.0"))
            return void console.error('The "linkchecker" plugin requires at least version 6.0.0 of TinyMCE.');
        const r = (e=>{
            let t = 0;
            return {
                get: ()=>t,
                set: e=>{
                    t = e
                }
            }
        }
        )();
        ((e,t)=>{
            const r = e.options.register;
            r("linkchecker_content_css", {
                processor: "string",
                default: t + "/content.min.css"
            }),
            r("linkchecker_api_key", {
                processor: "string"
            }),
            r("linkchecker_preprocess", {
                processor: "function",
                default: v
            }),
            r("linkchecker_service_url", {
                processor: "string",
                default: ""
            })
        }
        )(e, t);
        const n = dt(e)
          , o = (()=>{
            const e = {};
            return {
                add: t=>{
                    e[t] = !0
                }
                ,
                has: t=>t in e
            }
        }
        )()
          , s = ne(e)
          , a = ((e,t)=>({
            logError: r=>{
                const n = (e=>"string" == typeof e ? {
                    message: e
                } : e)(r);
                ((e,t)=>{
                    e.dispatch("LinkCheckerError", t)
                }
                )(e, n),
                t.set(t.get() + 1),
                t.get() < 5 && !e.removed && console.error(`Link checker error: ${n.message}`)
            }
        }))(e, r);
        e.on("SkinLoaded", (()=>{
            O(e).length > 0 ? (de(e, o, s, n, a),
            ((e,t,r,n)=>{
                e.options.isSet("file_picker_validator_handler") || e.options.set("file_picker_validator_handler", ((e,t,r)=>{
                    const n = j(((e,t)=>(e,r)=>{
                        t.checkOne(e).get((e=>{
                            e.fold((()=>{
                                r({
                                    status: "none",
                                    message: ""
                                })
                            }
                            ), (e=>{
                                $(e.result, (e=>{
                                    r(ge())
                                }
                                ), (e=>{
                                    r(fe())
                                }
                                ), (e=>{
                                    r(ke())
                                }
                                ))
                            }
                            ))
                        }
                        ))
                    }
                    )(0, r), 500);
                    return (e,r)=>{
                        const o = t(e.url);
                        0 === e.url.length || !H(o) && z(o) ? r(ke()) : H(o) ? n(o, r) : r(fe())
                    }
                }
                )(0, r, n))
            }
            )(e, 0, s, n)) : a.logError("You need to specify the linkchecker_service_url setting")
        }
        ))
    }
    ))
}();
