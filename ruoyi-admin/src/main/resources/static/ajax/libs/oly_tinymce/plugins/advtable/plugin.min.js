/*!
 * Tiny Advanced Tables plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 2.0.1-51
 */

!function() {
    "use strict";
    const e = e=>parseInt(e, 10)
      , t = (e,t)=>{
        const o = e - t;
        return 0 === o ? 0 : o > 0 ? 1 : -1
    }
      , o = (e,t,o)=>({
        major: e,
        minor: t,
        patch: o
    })
      , n = t=>{
        const n = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(t);
        return n ? o(e(n[1]), e(n[2]), e(n[3])) : o(0, 0, 0)
    }
      , r = e=>t=>(e=>{
        const t = typeof e;
        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && (o = n = e,
        (r = String).prototype.isPrototypeOf(o) || (null === (s = n.constructor) || void 0 === s ? void 0 : s.name) === r.name) ? "string" : t;
        var o, n, r, s
    }
    )(t) === e
      , s = e=>t=>typeof t === e
      , l = r("string")
      , c = r("object")
      , a = r("array")
      , i = (null,
    e=>null === e);
    const m = s("boolean")
      , u = e=>null == e
      , d = e=>!u(e)
      , h = s("function")
      , p = s("number");
    class g {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new g(!0,e)
        }
        static none() {
            return g.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? g.some(e(this.value)) : g.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : g.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : g.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return d(e) ? g.some(e) : g.none()
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    g.singletonNone = new g(!1);
    const f = ()=>{}
      , w = e=>()=>e
      , b = e=>e
      , v = (e,t)=>e === t;
    function y(e, ...t) {
        return (...o)=>{
            const n = t.concat(o);
            return e.apply(null, n)
        }
    }
    const C = w(!1)
      , x = w(!0)
      , S = Array.prototype.slice
      , T = Array.prototype.indexOf
      , R = Array.prototype.push
      , D = (e,t)=>((e,t)=>T.call(e, t))(e, t) > -1
      , O = (e,t)=>{
        for (let o = 0, n = e.length; o < n; o++)
            if (t(e[o], o))
                return !0;
        return !1
    }
      , A = (e,t)=>{
        const o = [];
        for (let n = 0; n < e; n++)
            o.push(t(n));
        return o
    }
      , k = (e,t)=>{
        const o = e.length
          , n = new Array(o);
        for (let r = 0; r < o; r++) {
            const o = e[r];
            n[r] = t(o, r)
        }
        return n
    }
      , E = (e,t)=>{
        for (let o = 0, n = e.length; o < n; o++)
            t(e[o], o)
    }
      , N = (e,t)=>{
        const o = []
          , n = [];
        for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r];
            (t(s, r) ? o : n).push(s)
        }
        return {
            pass: o,
            fail: n
        }
    }
      , W = (e,t)=>{
        const o = [];
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            t(r, n) && o.push(r)
        }
        return o
    }
      , L = (e,t)=>{
        if (0 === e.length)
            return [];
        {
            let o = t(e[0]);
            const n = [];
            let r = [];
            for (let s = 0, l = e.length; s < l; s++) {
                const l = e[s]
                  , c = t(l);
                c !== o && (n.push(r),
                r = []),
                o = c,
                r.push(l)
            }
            return 0 !== r.length && n.push(r),
            n
        }
    }
      , M = (e,t,o)=>(((e,t)=>{
        for (let o = e.length - 1; o >= 0; o--)
            t(e[o], o)
    }
    )(e, ((e,n)=>{
        o = t(o, e, n)
    }
    )),
    o)
      , j = (e,t,o)=>(E(e, ((e,n)=>{
        o = t(o, e, n)
    }
    )),
    o)
      , B = (e,t)=>((e,t,o)=>{
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (t(r, n))
                return g.some(r);
            if (o(r, n))
                break
        }
        return g.none()
    }
    )(e, t, C)
      , I = (e,t)=>(e=>{
        const t = [];
        for (let o = 0, n = e.length; o < n; ++o) {
            if (!a(e[o]))
                throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
            R.apply(t, e[o])
        }
        return t
    }
    )(k(e, t))
      , z = (e,t)=>{
        for (let o = 0, n = e.length; o < n; ++o)
            if (!0 !== t(e[o], o))
                return !1;
        return !0
    }
      , _ = (e,t)=>{
        const o = S.call(e, 0);
        return o.sort(t),
        o
    }
      , P = (e,t)=>t >= 0 && t < e.length ? g.some(e[t]) : g.none()
      , F = e=>P(e, 0)
      , V = e=>P(e, e.length - 1)
      , $ = (e,t)=>{
        for (let o = 0; o < e.length; o++) {
            const n = t(e[o], o);
            if (n.isSome())
                return n
        }
        return g.none()
    }
      , G = (e,t,o=v)=>e.exists((e=>o(e, t)))
      , q = (e,t,o)=>e.isSome() && t.isSome() ? g.some(o(e.getOrDie(), t.getOrDie())) : g.none()
      , H = e=>e.bind(b)
      , U = (e,t)=>e ? g.some(t) : g.none()
      , K = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , Q = {
        fromHtml: (e,t)=>{
            const o = (t || document).createElement("div");
            if (o.innerHTML = e,
            !o.hasChildNodes() || o.childNodes.length > 1) {
                const t = "HTML does not have a single root node";
                throw console.error(t, e),
                new Error(t)
            }
            return K(o.childNodes[0])
        }
        ,
        fromTag: (e,t)=>{
            const o = (t || document).createElement(e);
            return K(o)
        }
        ,
        fromText: (e,t)=>{
            const o = (t || document).createTextNode(e);
            return K(o)
        }
        ,
        fromDom: K,
        fromPoint: (e,t,o)=>g.from(e.dom.elementFromPoint(t, o)).map(K)
    };
    "undefined" != typeof window ? window : Function("return this;")();
    const X = e=>e.dom.nodeName.toLowerCase()
      , Y = e=>e.dom.nodeType
      , J = e=>t=>Y(t) === e
      , Z = e=>8 === Y(e) || "#comment" === X(e)
      , ee = J(1)
      , te = J(3)
      , oe = J(9)
      , ne = J(11)
      , re = e=>t=>ee(t) && X(t) === e
      , se = (e,t)=>{
        const o = e.dom;
        if (1 !== o.nodeType)
            return !1;
        {
            const e = o;
            if (void 0 !== e.matches)
                return e.matches(t);
            if (void 0 !== e.msMatchesSelector)
                return e.msMatchesSelector(t);
            if (void 0 !== e.webkitMatchesSelector)
                return e.webkitMatchesSelector(t);
            if (void 0 !== e.mozMatchesSelector)
                return e.mozMatchesSelector(t);
            throw new Error("Browser lacks native selectors")
        }
    }
      , le = e=>1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount
      , ce = (e,t)=>e.dom === t.dom
      , ae = se
      , ie = e=>Q.fromDom(e.dom.ownerDocument)
      , me = e=>oe(e) ? e : ie(e)
      , ue = e=>g.from(e.dom.parentNode).map(Q.fromDom)
      , de = (e,t)=>{
        const o = h(t) ? t : C;
        let n = e.dom;
        const r = [];
        for (; null !== n.parentNode && void 0 !== n.parentNode; ) {
            const e = n.parentNode
              , t = Q.fromDom(e);
            if (r.push(t),
            !0 === o(t))
                break;
            n = e
        }
        return r
    }
      , he = e=>g.from(e.dom.previousSibling).map(Q.fromDom)
      , pe = e=>g.from(e.dom.nextSibling).map(Q.fromDom)
      , ge = e=>k(e.dom.childNodes, Q.fromDom)
      , fe = h(Element.prototype.attachShadow) && h(Node.prototype.getRootNode) ? e=>Q.fromDom(e.dom.getRootNode()) : me
      , we = e=>Q.fromDom(e.dom.host)
      , be = e=>{
        const t = te(e) ? e.dom.parentNode : e.dom;
        if (null == t || null === t.ownerDocument)
            return !1;
        const o = t.ownerDocument;
        return (e=>{
            const t = fe(e);
            return ne(o = t) && d(o.dom.host) ? g.some(t) : g.none();
            var o
        }
        )(Q.fromDom(t)).fold((()=>o.body.contains(t)), (n = be,
        r = we,
        e=>n(r(e))));
        var n, r
    }
      , ve = (e,t)=>{
        let o = [];
        return E(ge(e), (e=>{
            t(e) && (o = o.concat([e])),
            o = o.concat(ve(e, t))
        }
        )),
        o
    }
      , ye = (e,t,o)=>((e,o,n)=>W(de(e, n), (e=>se(e, t))))(e, 0, o)
      , Ce = (e,t)=>((e,o)=>W(ge(e), (e=>se(e, t))))(e)
      , xe = (e,t)=>((e,t)=>{
        const o = void 0 === t ? document : t.dom;
        return le(o) ? [] : k(o.querySelectorAll(e), Q.fromDom)
    }
    )(t, e)
      , Se = (e,t,o)=>{
        let n = e.dom;
        const r = h(o) ? o : C;
        for (; n.parentNode; ) {
            n = n.parentNode;
            const e = Q.fromDom(n);
            if (t(e))
                return g.some(e);
            if (r(e))
                break
        }
        return g.none()
    }
      , Te = (e,t,o)=>Se(e, (e=>se(e, t)), o)
      , Re = (e,t)=>((e,o)=>B(e.dom.childNodes, (e=>{
        return o = Q.fromDom(e),
        se(o, t);
        var o
    }
    )).map(Q.fromDom))(e)
      , De = (e,t)=>((e,t)=>{
        const o = void 0 === t ? document : t.dom;
        return le(o) ? g.none() : g.from(o.querySelector(e)).map(Q.fromDom)
    }
    )(t, e)
      , Oe = (e,t,o)=>((e,t,o,n,r)=>((e,t)=>se(e, t))(o, n) ? g.some(o) : h(r) && r(o) ? g.none() : t(o, n, r))(0, Te, e, t, o)
      , Ae = Object.keys
      , ke = Object.hasOwnProperty
      , Ee = (e,t)=>{
        const o = Ae(e);
        for (let n = 0, r = o.length; n < r; n++) {
            const r = o[n];
            t(e[r], r)
        }
    }
      , Ne = (e,t)=>{
        const o = [];
        return Ee(e, ((e,n)=>{
            o.push(t(e, n))
        }
        )),
        o
    }
      , We = e=>Ne(e, b)
      , Le = e=>Ae(e).length
      , Me = (e,t)=>je(e, t) ? g.from(e[t]) : g.none()
      , je = (e,t)=>ke.call(e, t)
      , Be = e=>{
        for (const t in e)
            if (ke.call(e, t))
                return !1;
        return !0
    }
      , Ie = (e,t,o)=>{
        if (!(l(o) || m(o) || p(o)))
            throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e),
            new Error("Attribute value was not simple");
        e.setAttribute(t, o + "")
    }
      , ze = (e,t,o)=>{
        Ie(e.dom, t, o)
    }
      , _e = (e,t)=>{
        const o = e.dom;
        Ee(t, ((e,t)=>{
            Ie(o, t, e)
        }
        ))
    }
      , Pe = (e,t)=>{
        const o = e.dom.getAttribute(t);
        return null === o ? void 0 : o
    }
      , Fe = (e,t)=>g.from(Pe(e, t))
      , Ve = (e,t)=>{
        e.dom.removeAttribute(t)
    }
      , $e = e=>j(e.dom.attributes, ((e,t)=>(e[t.name] = t.value,
    e)), {})
      , Ge = (e,t)=>-1 !== e.indexOf(t)
      , qe = (e=>t=>t.replace(e, ""))(/^\s+|\s+$/g)
      , He = e=>!(e=>e.length > 0)(e)
      , Ue = e=>void 0 !== e.style && h(e.style.getPropertyValue)
      , Ke = (e,t,o)=>{
        ((e,t,o)=>{
            if (!l(o))
                throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", o, ":: Element ", e),
                new Error("CSS value must be a string: " + o);
            Ue(e) && e.style.setProperty(t, o)
        }
        )(e.dom, t, o)
    }
      , Qe = (e,t)=>{
        const o = e.dom
          , n = window.getComputedStyle(o).getPropertyValue(t);
        return "" !== n || be(e) ? n : Xe(o, t)
    }
      , Xe = (e,t)=>Ue(e) ? e.style.getPropertyValue(t) : ""
      , Ye = (e,t)=>{
        const o = e.dom
          , n = Xe(o, t);
        return g.from(n).filter((e=>e.length > 0))
    }
      , Je = (e,t)=>{
        ((e,t)=>{
            Ue(e) && e.style.removeProperty(t)
        }
        )(e.dom, t),
        G(Fe(e, "style").map(qe), "") && Ve(e, "style")
    }
      , Ze = (e,t,o=0)=>Fe(e, t).map((e=>parseInt(e, 10))).getOr(o)
      , et = e=>re("col")(e) ? Ze(e, "span", 1) > 1 : ((e,t)=>Ze(e, "colspan", 1))(e) > 1
      , tt = w(10)
      , ot = (e,t)=>nt(e, t, x)
      , nt = (e,t,o)=>I(ge(e), (e=>se(e, t) ? o(e) ? [e] : [] : nt(e, t, o)))
      , rt = ["tfoot", "thead", "tbody", "colgroup"]
      , st = (e,t,o)=>({
        element: e,
        rowspan: t,
        colspan: o
    })
      , lt = (e,t,o)=>({
        element: e,
        cells: t,
        section: o
    })
      , ct = (e,t,o)=>({
        element: e,
        isNew: t,
        isLocked: o
    })
      , at = (e,t,o,n)=>({
        element: e,
        cells: t,
        section: o,
        isNew: n
    })
      , it = (e,t)=>((e,t,o=C)=>o(t) ? g.none() : D(e, X(t)) ? g.some(t) : Te(t, e.join(","), (e=>se(e, "table") || o(e))))(["td", "th"], e, t)
      , mt = e=>ot(e, "th,td")
      , ut = e=>se(e, "colgroup") ? Ce(e, "col") : I(pt(e), (e=>Ce(e, "col")))
      , dt = (e,t)=>Oe(e, "table", t)
      , ht = e=>ot(e, "tr")
      , pt = e=>dt(e).fold(w([]), (e=>Ce(e, "colgroup")))
      , gt = e=>ue(e).map((e=>{
        const t = X(e);
        return (e=>D(rt, e))(t) ? t : "tbody"
    }
    )).getOr("tbody")
      , ft = (e,t)=>at(e.element, t, e.section, e.isNew)
      , wt = (e,t)=>e.cells[t]
      , bt = (e,t)=>wt(e, t).element
      , vt = e=>{
        const t = N(e, (e=>"colgroup" === e.section));
        return {
            rows: t.fail,
            cols: t.pass
        }
    }
      , yt = "data-snooker-locked-cols"
      , Ct = e=>Fe(e, yt).bind((e=>g.from(e.match(/\d+/g)))).map((e=>((e,t)=>{
        const o = {};
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            o[String(r)] = t(r, n)
        }
        return o
    }
    )(e, x)))
      , xt = (e,t)=>e + "," + t
      , St = e=>{
        const t = {}
          , o = []
          , n = F(e).map((e=>e.element)).bind(dt).bind(Ct).getOr({});
        let r = 0
          , s = 0
          , l = 0;
        const {pass: c, fail: a} = N(e, (e=>"colgroup" === e.section));
        E(a, (e=>{
            const c = [];
            E(e.cells, (e=>{
                let o = 0;
                for (; void 0 !== t[xt(l, o)]; )
                    o++;
                const r = ((e,t)=>je(e, t) && void 0 !== e[t] && null !== e[t])(n, o.toString())
                  , a = ((e,t,o,n,r,s)=>({
                    element: e,
                    rowspan: t,
                    colspan: o,
                    row: n,
                    column: r,
                    isLocked: s
                }))(e.element, e.rowspan, e.colspan, l, o, r);
                for (let n = 0; n < e.colspan; n++)
                    for (let r = 0; r < e.rowspan; r++) {
                        const e = o + n
                          , c = xt(l + r, e);
                        t[c] = a,
                        s = Math.max(s, e + 1)
                    }
                c.push(a)
            }
            )),
            r++,
            o.push(lt(e.element, c, e.section)),
            l++
        }
        ));
        const {columns: i, colgroups: m} = V(c).map((e=>{
            const t = (e=>{
                const t = {};
                let o = 0;
                return E(e.cells, (e=>{
                    const n = e.colspan;
                    A(n, (r=>{
                        const s = o + r;
                        t[s] = ((e,t,o)=>({
                            element: e,
                            colspan: t,
                            column: o
                        }))(e.element, n, s)
                    }
                    )),
                    o += n
                }
                )),
                t
            }
            )(e)
              , o = ((e,t)=>({
                element: e,
                columns: t
            }))(e.element, We(t));
            return {
                colgroups: [o],
                columns: t
            }
        }
        )).getOrThunk((()=>({
            colgroups: [],
            columns: {}
        })))
          , u = ((e,t)=>({
            rows: e,
            columns: t
        }))(r, s);
        return {
            grid: u,
            access: t,
            all: o,
            columns: i,
            colgroups: m
        }
    }
      , Tt = e=>{
        const t = (e=>{
            const t = ht(e);
            return o = [...pt(e), ...t],
            n = gt,
            k(o, (e=>{
                if ("colgroup" === X(e)) {
                    const t = k(ut(e), (e=>{
                        const t = Ze(e, "span", 1);
                        return st(e, 1, t)
                    }
                    ));
                    return lt(e, t, "colgroup")
                }
                {
                    const t = k(mt(e), (e=>{
                        const t = Ze(e, "rowspan", 1)
                          , o = Ze(e, "colspan", 1);
                        return st(e, t, o)
                    }
                    ));
                    return lt(e, t, n(e))
                }
            }
            ));
            var o, n
        }
        )(e);
        return St(t)
    }
      , Rt = St
      , Dt = (e,t,o)=>g.from(e.access[xt(t, o)])
      , Ot = (e,t,o)=>{
        const n = ((e,t)=>{
            const o = I(e.all, (e=>e.cells));
            return W(o, t)
        }
        )(e, (e=>o(t, e.element)));
        return n.length > 0 ? g.some(n[0]) : g.none()
    }
      , At = e=>We(e.columns)
      , kt = e=>Ae(e.columns).length > 0
      , Et = (e,t)=>g.from(e.columns[t])
      , Nt = e=>Q.fromDom(e.getBody())
      , Wt = e=>t=>ce(t, Nt(e))
      , Lt = e=>Q.fromDom(e.selection.getStart())
      , Mt = (e,t)=>t.column >= e.startCol && t.column + t.colspan - 1 <= e.finishCol && t.row >= e.startRow && t.row + t.rowspan - 1 <= e.finishRow
      , jt = (e,t,o)=>((e,t,o)=>{
        const n = Ot(e, t, ce)
          , r = Ot(e, o, ce);
        return n.bind((e=>r.map((t=>{
            return o = e,
            n = t,
            {
                startRow: Math.min(o.row, n.row),
                startCol: Math.min(o.column, n.column),
                finishRow: Math.max(o.row + o.rowspan - 1, n.row + n.rowspan - 1),
                finishCol: Math.max(o.column + o.colspan - 1, n.column + n.colspan - 1)
            };
            var o, n
        }
        ))))
    }
    )(e, t, o).bind((t=>((e,t)=>{
        let o = !0;
        const n = y(Mt, t);
        for (let r = t.startRow; r <= t.finishRow; r++)
            for (let s = t.startCol; s <= t.finishCol; s++)
                o = o && Dt(e, r, s).exists(n);
        return o ? g.some(t) : g.none()
    }
    )(e, t)))
      , Bt = (e,t,o)=>{
        const n = It(e);
        return jt(n, t, o)
    }
      , It = Tt
      , zt = (e,t)=>{
        ue(e).each((o=>{
            o.dom.insertBefore(t.dom, e.dom)
        }
        ))
    }
      , _t = (e,t)=>{
        pe(e).fold((()=>{
            ue(e).each((e=>{
                Ft(e, t)
            }
            ))
        }
        ), (e=>{
            zt(e, t)
        }
        ))
    }
      , Pt = (e,t)=>{
        (e=>((e,t)=>{
            const o = e.dom.childNodes;
            return g.from(o[0]).map(Q.fromDom)
        }
        )(e))(e).fold((()=>{
            Ft(e, t)
        }
        ), (o=>{
            e.dom.insertBefore(t.dom, o.dom)
        }
        ))
    }
      , Ft = (e,t)=>{
        e.dom.appendChild(t.dom)
    }
      , Vt = (e,t)=>{
        zt(e, t),
        Ft(t, e)
    }
      , $t = (e,t)=>{
        E(t, ((o,n)=>{
            const r = 0 === n ? e : t[n - 1];
            _t(r, o)
        }
        ))
    }
      , Gt = (e,t)=>{
        E(t, (t=>{
            Ft(e, t)
        }
        ))
    }
      , qt = e=>{
        e.dom.textContent = "",
        E(ge(e), (e=>{
            Ht(e)
        }
        ))
    }
      , Ht = e=>{
        const t = e.dom;
        null !== t.parentNode && t.parentNode.removeChild(t)
    }
      , Ut = e=>{
        const t = ge(e);
        t.length > 0 && $t(e, t),
        Ht(e)
    }
      , Kt = ((e,t)=>{
        const o = t=>e(t) ? g.from(t.dom.nodeValue) : g.none();
        return {
            get: t=>{
                if (!e(t))
                    throw new Error("Can only get text value of a text node");
                return o(t).getOr("")
            }
            ,
            getOption: o,
            set: (t,o)=>{
                if (!e(t))
                    throw new Error("Can only set raw text value of a text node");
                t.dom.nodeValue = o
            }
        }
    }
    )(te)
      , Qt = e=>Kt.get(e)
      , Xt = (e,t)=>Kt.set(e, t);
    var Yt = ["body", "p", "div", "article", "aside", "figcaption", "figure", "footer", "header", "nav", "section", "ol", "ul", "li", "table", "thead", "tbody", "tfoot", "caption", "tr", "td", "th", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "pre", "address"]
      , Jt = ()=>({
        up: w({
            selector: Te,
            closest: Oe,
            predicate: Se,
            all: de
        }),
        down: w({
            selector: xe,
            predicate: ve
        }),
        styles: w({
            get: Qe,
            getRaw: Ye,
            set: Ke,
            remove: Je
        }),
        attrs: w({
            get: Pe,
            set: ze,
            remove: Ve,
            copyTo: (e,t)=>{
                const o = $e(e);
                _e(t, o)
            }
        }),
        insert: w({
            before: zt,
            after: _t,
            afterAll: $t,
            append: Ft,
            appendAll: Gt,
            prepend: Pt,
            wrap: Vt
        }),
        remove: w({
            unwrap: Ut,
            remove: Ht
        }),
        create: w({
            nu: Q.fromTag,
            clone: e=>Q.fromDom(e.dom.cloneNode(!1)),
            text: Q.fromText
        }),
        query: w({
            comparePosition: (e,t)=>e.dom.compareDocumentPosition(t.dom),
            prevSibling: he,
            nextSibling: pe
        }),
        property: w({
            children: ge,
            name: X,
            parent: ue,
            document: e=>me(e).dom,
            isText: te,
            isComment: Z,
            isElement: ee,
            isSpecial: e=>{
                const t = X(e);
                return D(["script", "noscript", "iframe", "noframes", "noembed", "title", "style", "textarea", "xmp"], t)
            }
            ,
            getLanguage: e=>ee(e) ? Fe(e, "lang") : g.none(),
            getText: Qt,
            setText: Xt,
            isBoundary: e=>!!ee(e) && ("body" === X(e) || D(Yt, X(e))),
            isEmptyTag: e=>!!ee(e) && D(["br", "img", "hr", "input"], X(e)),
            isNonEditable: e=>ee(e) && "false" === Pe(e, "contenteditable")
        }),
        eq: ce,
        is: ae
    });
    const Zt = (e,t,o,n)=>{
        const r = t(e, o);
        return M(n, ((o,n)=>{
            const r = t(e, n);
            return eo(e, o, r)
        }
        ), r)
    }
      , eo = (e,t,o)=>t.bind((t=>o.filter(y(e.eq, t))))
      , to = Jt()
      , oo = e=>Te(e, "table")
      , no = (e,t,o)=>De(e, t).bind((t=>De(e, o).bind((e=>{
        return (o = oo,
        n = [t, e],
        ((e,t,o)=>o.length > 0 ? ((e,t,o,n)=>n(e, t, o[0], o.slice(1)))(e, t, o, Zt) : g.none())(to, ((e,t)=>o(t)), n)).map((o=>({
            first: t,
            last: e,
            table: o
        })));
        var o, n
    }
    ))))
      , ro = b
      , so = e=>{
        const t = (e,t)=>Fe(e, t).exists((e=>parseInt(e, 10) > 1));
        return e.length > 0 && z(e, (e=>t(e, "rowspan") || t(e, "colspan"))) ? g.some(e) : g.none()
    }
      , lo = (e,t,o)=>{
        return t.length <= 1 ? g.none() : (n = e,
        r = o.firstSelectedSelector,
        s = o.lastSelectedSelector,
        no(n, r, s).bind((e=>{
            const t = e=>ce(n, e)
              , o = "thead,tfoot,tbody,table"
              , r = Te(e.first, o, t)
              , s = Te(e.last, o, t);
            return r.bind((t=>s.bind((o=>ce(t, o) ? Bt(e.table, e.first, e.last) : g.none()))))
        }
        ))).map((e=>({
            bounds: e,
            cells: t
        })));
        var n, r, s
    }
      , co = {
        selected: "data-mce-selected",
        selectedSelector: "td[data-mce-selected],th[data-mce-selected]",
        firstSelected: "data-mce-first-selected",
        firstSelectedSelector: "td[data-mce-first-selected],th[data-mce-first-selected]",
        lastSelected: "data-mce-last-selected",
        lastSelectedSelector: "td[data-mce-last-selected],th[data-mce-last-selected]"
    }
      , ao = e=>({
        element: e,
        mergable: g.none(),
        unmergable: g.none(),
        selection: [e]
    })
      , io = (e,t,o)=>({
        element: o,
        mergable: lo(t, e, co),
        unmergable: so(e),
        selection: ro(e)
    })
      , mo = e=>(t,o)=>{
        const n = X(t)
          , r = "col" === n || "colgroup" === n ? dt(s = t).bind((e=>((e,t)=>((e,t)=>{
            const o = xe(e, t);
            return o.length > 0 ? g.some(o) : g.none()
        }
        )(e, t))(e, co.firstSelectedSelector))).fold(w(s), (e=>e[0])) : t;
        var s;
        return Oe(r, e, o)
    }
      , uo = mo("th,td,caption")
      , ho = mo("th,td")
      , po = e=>{
        return t = e.model.table.getSelectedCells(),
        k(t, Q.fromDom);
        var t
    }
      , go = e=>{
        let t, o = !1;
        return (...n)=>(o || (o = !0,
        t = e.apply(null, n)),
        t)
    }
      , fo = (e,t)=>({
        element: e,
        offset: t
    })
      , wo = (e,t,o)=>e.property().isText(t) && 0 === e.property().getText(t).trim().length || e.property().isComment(t) ? o(t).bind((t=>wo(e, t, o).orThunk((()=>g.some(t))))) : g.none()
      , bo = (e,t)=>e.property().isText(t) ? e.property().getText(t).length : e.property().children(t).length
      , vo = (e,t)=>{
        const o = wo(e, t, e.query().prevSibling).getOr(t);
        if (e.property().isText(o))
            return fo(o, bo(e, o));
        const n = e.property().children(o);
        return n.length > 0 ? vo(e, n[n.length - 1]) : fo(o, bo(e, o))
    }
      , yo = vo
      , Co = Jt()
      , xo = {
        unsupportedLength: ["em", "ex", "cap", "ch", "ic", "rem", "lh", "rlh", "vw", "vh", "vi", "vb", "vmin", "vmax", "cm", "mm", "Q", "in", "pc", "pt", "px"],
        fixed: ["px", "pt"],
        relative: ["%"],
        empty: [""]
    }
      , So = (()=>{
        const e = "[0-9]+"
          , t = "[eE][+-]?[0-9]+"
          , o = e=>`(?:${e})?`
          , n = ["Infinity", "[0-9]+\\." + o(e) + o(t), "\\.[0-9]+" + o(t), e + o(t)].join("|");
        return new RegExp(`^([+-]?(?:${n}))(.*)$`)
    }
    )()
      , To = (e,t)=>g.from(So.exec(e)).bind((e=>{
        const o = Number(e[1])
          , n = e[2];
        return ((e,t)=>O(t, (t=>O(xo[t], (t=>e === t)))))(n, t) ? g.some({
            value: o,
            unit: n
        }) : g.none()
    }
    ))
      , Ro = (e,t,o)=>((e,t)=>(e=>{
        const t = parseFloat(e);
        return isNaN(t) ? g.none() : g.some(t)
    }
    )(e).getOr(t))(Qe(e, t), o)
      , Do = ((e,t)=>{
        const o = t=>{
            const o = (e=>e.dom.offsetWidth)(t);
            if (o <= 0 || null === o) {
                const o = Qe(t, e);
                return parseFloat(o) || 0
            }
            return o
        }
          , n = (e,t)=>j(t, ((t,o)=>{
            const n = Qe(e, o)
              , r = void 0 === n ? 0 : parseInt(n, 10);
            return isNaN(r) ? t : t + r
        }
        ), 0);
        return {
            set: (e,t)=>{
                if (!p(t) && !t.match(/^[0-9]+$/))
                    throw new Error("width.set accepts only positive integer values. Value was " + t);
                const o = e.dom;
                Ue(o) && (o.style.width = t + "px")
            }
            ,
            get: o,
            getOuter: o,
            aggregate: n,
            max: (e,t,o)=>{
                const r = n(e, o);
                return t > r ? t - r : 0
            }
        }
    }
    )("width")
      , Oo = e=>Do.get(e)
      , Ao = e=>Do.getOuter(e)
      , ko = e=>((e,t)=>{
        const o = e.dom
          , n = o.getBoundingClientRect().width || o.offsetWidth;
        return "border-box" === t ? n : ((e,t,o,n)=>t - Ro(e, "padding-left", 0) - Ro(e, "padding-right", 0) - Ro(e, "border-left-width", 0) - Ro(e, "border-right-width", 0))(e, n)
    }
    )(e, "content-box")
      , Eo = re("col")
      , No = (e,t,o)=>{
        const n = (r = e,
        g.from(r.dom.parentElement).map(Q.fromDom)).getOrThunk((()=>(e=>{
            const t = e.dom.body;
            if (null == t)
                throw new Error("Body is not available yet");
            return Q.fromDom(t)
        }
        )(ie(e))));
        var r;
        return t(e) / o(n) * 100
    }
      , Wo = (e,t)=>{
        Ke(e, "width", t + "px")
    }
      , Lo = (e,t)=>{
        Ke(e, "width", t + "%")
    }
      , Mo = e=>((e,t)=>Ye(e, t).orThunk((()=>Fe(e, t).map((e=>e + "px")))))(e, "width")
      , jo = e=>No(e, Oo, ko)
      , Bo = e=>{
        return Eo(e) ? Oo(e) : Ro(t = e, "width", t.dom.offsetWidth);
        var t
    }
      , Io = (e,t,o)=>{
        Ke(e, "width", t + o)
    }
      , zo = w(/(\d+(\.\d+)?)%/)
      , _o = (e,t)=>{
        if (!et(e)) {
            const o = (e=>Mo(e).bind((e=>To(e, ["fixed", "relative", "empty"]))))(e);
            o.each((o=>{
                const n = o.value / 2;
                Io(e, n, o.unit),
                Io(t, n, o.unit)
            }
            ))
        }
    }
      , Po = re("col")
      , Fo = re("colgroup")
      , Vo = e=>({
        element: e,
        colspan: Ze(e, "colspan", 1),
        rowspan: Ze(e, "rowspan", 1)
    })
      , $o = (e,t=Vo)=>{
        const o = o=>{
            if ((e=>"tr" === X(e) || Fo(e))(o))
                return Fo((r = {
                    element: o
                }).element) ? e.colgroup(r) : e.row(r);
            {
                const r = o
                  , s = (t=>Po(t.element) ? e.col(t) : e.cell(t))(t(r));
                return n = g.some({
                    item: r,
                    replacement: s
                }),
                s
            }
            var r
        }
        ;
        let n = g.none();
        return {
            getOrInit: (e,t)=>n.fold((()=>o(e)), (n=>t(e, n.item) ? n.replacement : o(e)))
        }
    }
      , Go = e=>k(e, w(0))
      , qo = e=>(t,o,n,r)=>{
        if (e(n)) {
            const e = Math.max(r, t[o] - Math.abs(n))
              , s = Math.abs(e - t[o]);
            return n >= 0 ? s : -s
        }
        return n
    }
      , Ho = qo((e=>e < 0))
      , Uo = qo(x)
      , Ko = ()=>{
        const e = (e,t,o,n,r)=>{
            const s = Uo(e, n >= 0 ? o : t, n, r);
            return ((e,t,o,n,r)=>r(e.slice(0, t)).concat(n).concat(r(e.slice(o))))(e, t, o + 1, [s, -s], Go)
        }
        ;
        return {
            resizeTable: (e,t,o)=>{
                o && e(t)
            }
            ,
            clampTableDelta: (e,t,o,n,r)=>{
                if (r) {
                    if (o >= 0)
                        return o;
                    {
                        const t = j(e, ((e,t)=>e + t - n), 0);
                        return Math.max(-t, o)
                    }
                }
                return Ho(e, t, o, n)
            }
            ,
            calcLeftEdgeDeltas: e,
            calcMiddleDeltas: (t,o,n,r,s,l)=>e(t, n, r, s, l),
            calcRightEdgeDeltas: (e,t,o,n,r,s)=>{
                if (s)
                    return Go(e);
                {
                    const t = n / e.length;
                    return k(e, w(t))
                }
            }
            ,
            calcRedestributedWidths: (e,t,o,n)=>({
                delta: 0,
                newSizes: e
            })
        }
    }
      , Qo = (e,t)=>Q.fromDom(e.dom.cloneNode(t))
      , Xo = (e,t)=>{
        const o = ((e,t)=>{
            const o = Q.fromTag(t)
              , n = $e(e);
            return _e(o, n),
            o
        }
        )(e, t)
          , n = ge((e=>Qo(e, !0))(e));
        return Gt(o, n),
        o
    }
      , Yo = (re("th"),
    (e,t,o)=>ct(o(e.element, t), !0, e.isLocked))
      , Jo = ()=>({
        transformRow: b,
        transformCell: Yo
    })
      , Zo = ()=>en(0, 0)
      , en = (e,t)=>({
        major: e,
        minor: t
    })
      , tn = {
        nu: en,
        detect: (e,t)=>{
            const o = String(t).toLowerCase();
            return 0 === e.length ? Zo() : ((e,t)=>{
                const o = ((e,t)=>{
                    for (let o = 0; o < e.length; o++) {
                        const n = e[o];
                        if (n.test(t))
                            return n
                    }
                }
                )(e, t);
                if (!o)
                    return {
                        major: 0,
                        minor: 0
                    };
                const n = e=>Number(t.replace(o, "$" + e));
                return en(n(1), n(2))
            }
            )(e, o)
        }
        ,
        unknown: Zo
    }
      , on = (e,t)=>{
        const o = String(t).toLowerCase();
        return B(e, (e=>e.search(o)))
    }
      , nn = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/
      , rn = e=>t=>Ge(t, e)
      , sn = [{
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: e=>Ge(e, "edge/") && Ge(e, "chrome") && Ge(e, "safari") && Ge(e, "applewebkit")
    }, {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, nn],
        search: e=>Ge(e, "chrome") && !Ge(e, "chromeframe")
    }, {
        name: "IE",
        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
        search: e=>Ge(e, "msie") || Ge(e, "trident")
    }, {
        name: "Opera",
        versionRegexes: [nn, /.*?opera\/([0-9]+)\.([0-9]+).*/],
        search: rn("opera")
    }, {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: rn("firefox")
    }, {
        name: "Safari",
        versionRegexes: [nn, /.*?cpu os ([0-9]+)_([0-9]+).*/],
        search: e=>(Ge(e, "safari") || Ge(e, "mobile/")) && Ge(e, "applewebkit")
    }]
      , ln = [{
        name: "Windows",
        search: rn("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "iOS",
        search: e=>Ge(e, "iphone") || Ge(e, "ipad"),
        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
    }, {
        name: "Android",
        search: rn("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "macOS",
        search: rn("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    }, {
        name: "Linux",
        search: rn("linux"),
        versionRegexes: []
    }, {
        name: "Solaris",
        search: rn("sunos"),
        versionRegexes: []
    }, {
        name: "FreeBSD",
        search: rn("freebsd"),
        versionRegexes: []
    }, {
        name: "ChromeOS",
        search: rn("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }]
      , cn = {
        browsers: w(sn),
        oses: w(ln)
    }
      , an = "Edge"
      , mn = "Chromium"
      , un = "Opera"
      , dn = "Firefox"
      , hn = "Safari"
      , pn = e=>{
        const t = e.current
          , o = e.version
          , n = e=>()=>t === e;
        return {
            current: t,
            version: o,
            isEdge: n(an),
            isChromium: n(mn),
            isIE: n("IE"),
            isOpera: n(un),
            isFirefox: n(dn),
            isSafari: n(hn)
        }
    }
      , gn = ()=>pn({
        current: void 0,
        version: tn.unknown()
    })
      , fn = pn
      , wn = (w(an),
    w(mn),
    w("IE"),
    w(un),
    w(dn),
    w(hn),
    "Windows")
      , bn = "Android"
      , vn = "Linux"
      , yn = "macOS"
      , Cn = "Solaris"
      , xn = "FreeBSD"
      , Sn = "ChromeOS"
      , Tn = e=>{
        const t = e.current
          , o = e.version
          , n = e=>()=>t === e;
        return {
            current: t,
            version: o,
            isWindows: n(wn),
            isiOS: n("iOS"),
            isAndroid: n(bn),
            isMacOS: n(yn),
            isLinux: n(vn),
            isSolaris: n(Cn),
            isFreeBSD: n(xn),
            isChromeOS: n(Sn)
        }
    }
      , Rn = ()=>Tn({
        current: void 0,
        version: tn.unknown()
    })
      , Dn = Tn
      , On = (w(wn),
    w("iOS"),
    w(bn),
    w(vn),
    w(yn),
    w(Cn),
    w(xn),
    w(Sn),
    e=>window.matchMedia(e).matches);
    let An = go((()=>((e,t,o)=>{
        const n = cn.browsers()
          , r = cn.oses()
          , s = t.bind((e=>((e,t)=>$(t.brands, (t=>{
            const o = t.brand.toLowerCase();
            return B(e, (e=>{
                var t;
                return o === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
            }
            )).map((e=>({
                current: e.name,
                version: tn.nu(parseInt(t.version, 10), 0)
            })))
        }
        )))(n, e))).orThunk((()=>((e,t)=>on(e, t).map((e=>{
            const o = tn.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: o
            }
        }
        )))(n, e))).fold(gn, fn)
          , l = ((e,t)=>on(e, t).map((e=>{
            const o = tn.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: o
            }
        }
        )))(r, e).fold(Rn, Dn)
          , c = ((e,t,o,n)=>{
            const r = e.isiOS() && !0 === /ipad/i.test(o)
              , s = e.isiOS() && !r
              , l = e.isiOS() || e.isAndroid()
              , c = l || n("(pointer:coarse)")
              , a = r || !s && l && n("(min-device-width:768px)")
              , i = s || l && !a
              , m = t.isSafari() && e.isiOS() && !1 === /safari/i.test(o)
              , u = !i && !a && !m;
            return {
                isiPad: w(r),
                isiPhone: w(s),
                isTablet: w(a),
                isPhone: w(i),
                isTouch: w(c),
                isAndroid: e.isAndroid,
                isiOS: e.isiOS,
                isWebView: w(m),
                isDesktop: w(u)
            }
        }
        )(l, s, e, o);
        return {
            browser: s,
            os: l,
            deviceType: c
        }
    }
    )(navigator.userAgent, g.from(navigator.userAgentData), On)));
    const kn = (e,t=x)=>{
        const o = e.grid
          , n = A(o.columns, b)
          , r = A(o.rows, b);
        return k(n, (o=>En((()=>I(r, (t=>Dt(e, t, o).filter((e=>e.column === o)).toArray()))), (e=>1 === e.colspan && t(e.element)), (()=>Dt(e, 0, o)))))
    }
      , En = (e,t,o)=>{
        const n = e();
        return B(n, t).orThunk((()=>g.from(n[0]).orThunk(o))).map((e=>e.element))
    }
      , Nn = (e,t)=>({
        left: e,
        top: t,
        translate: (o,n)=>Nn(e + o, t + n)
    })
      , Wn = Nn
      , Ln = (e,t)=>void 0 !== e ? e : void 0 !== t ? t : 0
      , Mn = e=>{
        const t = e.dom.ownerDocument
          , o = t.body
          , n = t.defaultView
          , r = t.documentElement;
        if (o === e.dom)
            return Wn(o.offsetLeft, o.offsetTop);
        const s = Ln(null == n ? void 0 : n.pageYOffset, r.scrollTop)
          , l = Ln(null == n ? void 0 : n.pageXOffset, r.scrollLeft)
          , c = Ln(r.clientTop, o.clientTop)
          , a = Ln(r.clientLeft, o.clientLeft);
        return jn(e).translate(l - a, s - c)
    }
      , jn = e=>{
        const t = e.dom
          , o = t.ownerDocument.body;
        return o === t ? Wn(o.offsetLeft, o.offsetTop) : be(e) ? (e=>{
            const t = e.getBoundingClientRect();
            return Wn(t.left, t.top)
        }
        )(t) : Wn(0, 0)
    }
      , Bn = (e,t)=>({
        col: e,
        x: t
    })
      , In = e=>Mn(e).left + Ao(e)
      , zn = e=>Mn(e).left
      , _n = (e,t)=>Bn(e, zn(t))
      , Pn = (e,t)=>Bn(e, In(t))
      , Fn = (e,t,o)=>{
        if (0 === o.length)
            return [];
        const n = k(o.slice(1), ((t,o)=>t.map((t=>e(o, t)))))
          , r = o[o.length - 1].map((e=>t(o.length - 1, e)));
        return n.concat([r])
    }
      , Vn = ($n = {
        delta: b,
        edge: zn,
        positions: e=>Fn(_n, Pn, e)
    },
    Gn = {
        delta: e=>-e,
        edge: In,
        positions: e=>Fn(Pn, _n, e)
    },
    e=>"rtl" === (e=>"rtl" === Qe(e, "direction") ? "rtl" : "ltr")(e) ? Gn : $n);
    var $n, Gn;
    const qn = e=>Vn(e).edge(e)
      , Hn = re("col")
      , Un = (e,t,o,n,r,s)=>e.filter(n).fold((()=>s(((e,t)=>{
        if (t < 0 || t >= e.length - 1)
            return g.none();
        const o = e[t].fold((()=>{
            const o = (e=>{
                const t = S.call(e, 0);
                return t.reverse(),
                t
            }
            )(e.slice(0, t));
            return $(o, ((e,t)=>e.map((e=>({
                value: e,
                delta: t + 1
            })))))
        }
        ), (e=>g.some({
            value: e,
            delta: 0
        })))
          , n = e[t + 1].fold((()=>{
            const o = e.slice(t + 1);
            return $(o, ((e,t)=>e.map((e=>({
                value: e,
                delta: t + 1
            })))))
        }
        ), (e=>g.some({
            value: e,
            delta: 1
        })));
        return o.bind((e=>n.map((t=>{
            const o = t.delta + e.delta;
            return Math.abs(t.value - e.value) / o
        }
        ))))
    }
    )(o, t))), (e=>r(e)))
      , Kn = (e,t,o,n)=>{
        const r = kn(e)
          , s = kt(e) ? (e=>k(At(e), (e=>g.from(e.element))))(e) : r
          , l = [g.some(qn(t))].concat(k(((e,t)=>Vn(t).positions(e, t))(r, t), (e=>e.map((e=>e.x)))))
          , c = (a = et,
        e=>!a(e));
        var a;
        return k(s, ((e,t)=>Un(e, t, l, c, (e=>{
            if ((e=>{
                const t = An().browser
                  , o = t.isChromium() || t.isFirefox();
                return !Hn(e) || o
            }
            )(e))
                return o(e);
            {
                const e = ((e,t)=>null != e ? t(e) : g.none())(r[t], b);
                return Un(e, t, l, c, (e=>n(g.some(Oo(e)))), n)
            }
        }
        ), n)))
    }
      , Qn = (e,t,o)=>Kn(e, t, Bo, (e=>e.getOrThunk(o.minCellWidth)))
      , Xn = (e,t)=>()=>be(e) ? t(e) : parseFloat(Ye(e, "width").getOr("0"))
      , Yn = e=>Mo(e).fold((()=>(e=>{
        const t = Xn(e, Oo)
          , o = w(0);
        return {
            width: t,
            pixelWidth: t,
            getWidths: (t,o)=>Qn(t, e, o),
            getCellDelta: o,
            singleColumnWidth: w([0]),
            minCellWidth: o,
            setElementWidth: f,
            adjustTableWidth: f,
            isRelative: !0,
            label: "none"
        }
    }
    )(e)), (t=>{
        return o = e,
        n = t,
        null !== zo().exec(n) ? (e=>{
            const t = Xn(e, (e=>parseFloat((e=>No(e, Oo, ko) + "%")(e))))
              , o = Xn(e, Oo);
            return {
                width: t,
                pixelWidth: o,
                getWidths: (t,o)=>((e,t,o)=>Kn(e, t, jo, (e=>e.fold((()=>o.minCellWidth()), (e=>e / o.pixelWidth() * 100)))))(t, e, o),
                getCellDelta: e=>e / o() * 100,
                singleColumnWidth: (e,t)=>[100 - e],
                minCellWidth: ()=>tt() / o() * 100,
                setElementWidth: Lo,
                adjustTableWidth: o=>{
                    const n = t();
                    Lo(e, n + o / 100 * n)
                }
                ,
                isRelative: !0,
                label: "percent"
            }
        }
        )(o) : (e=>{
            const t = Xn(e, Oo);
            return {
                width: t,
                pixelWidth: t,
                getWidths: (t,o)=>Qn(t, e, o),
                getCellDelta: b,
                singleColumnWidth: (e,t)=>[Math.max(tt(), e + t) - e],
                minCellWidth: tt,
                setElementWidth: Wo,
                adjustTableWidth: o=>{
                    const n = t() + o;
                    Wo(e, n)
                }
                ,
                isRelative: !1,
                label: "pixel"
            }
        }
        )(o);
        var o, n
    }
    ))
      , Jn = (e,t,o,n)=>{
        o === n ? Ve(e, t) : ze(e, t, o)
    }
      , Zn = (e,t,o)=>{
        V(Ce(e, t)).fold((()=>Pt(e, o)), (e=>_t(e, o)))
    }
      , er = (e,t)=>{
        const o = []
          , n = []
          , r = e=>k(e, (e=>{
            e.isNew && o.push(e.element);
            const t = e.element;
            return qt(t),
            E(e.cells, (e=>{
                e.isNew && n.push(e.element),
                Jn(e.element, "colspan", e.colspan, 1),
                Jn(e.element, "rowspan", e.rowspan, 1),
                Ft(t, e.element)
            }
            )),
            t
        }
        ))
          , s = e=>I(e, (e=>k(e.cells, (e=>(Jn(e.element, "span", e.colspan, 1),
        e.element)))))
          , l = (t,o)=>{
            const n = ((e,t)=>{
                const o = Re(e, t).getOrThunk((()=>{
                    const o = Q.fromTag(t, ie(e).dom);
                    return "thead" === t ? Zn(e, "caption,colgroup", o) : "colgroup" === t ? Zn(e, "caption", o) : Ft(e, o),
                    o
                }
                ));
                return qt(o),
                o
            }
            )(e, o)
              , l = ("colgroup" === o ? s : r)(t);
            Gt(n, l)
        }
          , c = (t,o)=>{
            t.length > 0 ? l(t, o) : (t=>{
                Re(e, t).each(Ht)
            }
            )(o)
        }
          , a = []
          , i = []
          , m = []
          , u = [];
        return E(t, (e=>{
            switch (e.section) {
            case "thead":
                a.push(e);
                break;
            case "tbody":
                i.push(e);
                break;
            case "tfoot":
                m.push(e);
                break;
            case "colgroup":
                u.push(e)
            }
        }
        )),
        c(u, "colgroup"),
        c(a, "thead"),
        c(i, "tbody"),
        c(m, "tfoot"),
        {
            newRows: o,
            newCells: n
        }
    }
      , tr = (e,t)=>{
        if (0 === e.length)
            return 0;
        const o = e[0]
          , n = ((e,n)=>{
            for (let n = 0, s = e.length; n < s; n++)
                if (r = e[n],
                !t(o.element, r.element))
                    return g.some(n);
            var r;
            return g.none()
        }
        )(e);
        return n.getOr(e.length)
    }
      , or = (e,t)=>{
        const o = k(e, (e=>k(e.cells, C)));
        return k(e, ((n,r)=>{
            const s = I(n.cells, ((n,s)=>{
                if (!1 === o[r][s]) {
                    const m = ((e,t,o,n)=>{
                        const r = ((e,t)=>e[t])(e, t)
                          , s = "colgroup" === r.section
                          , l = tr(r.cells.slice(o), n)
                          , c = s ? 1 : tr(((e,t)=>k(e, (e=>wt(e, t))))(e.slice(t), o), n);
                        return {
                            colspan: l,
                            rowspan: c
                        }
                    }
                    )(e, r, s, t);
                    return ((e,t,n,r)=>{
                        for (let s = e; s < e + n; s++)
                            for (let e = t; e < t + r; e++)
                                o[s][e] = !0
                    }
                    )(r, s, m.rowspan, m.colspan),
                    [(l = n.element,
                    c = m.rowspan,
                    a = m.colspan,
                    i = n.isNew,
                    {
                        element: l,
                        rowspan: c,
                        colspan: a,
                        isNew: i
                    })]
                }
                return [];
                var l, c, a, i
            }
            ));
            return l = n.element,
            c = s,
            a = n.section,
            i = n.isNew,
            {
                element: l,
                cells: c,
                section: a,
                isNew: i
            };
            var l, c, a, i
        }
        ))
    }
      , nr = (e,t)=>$(e.all, (e=>B(e.cells, (e=>ce(t, e.element)))))
      , rr = (e,t,o)=>{
        const n = (e=>{
            const t = []
              , o = e=>{
                t.push(e)
            }
            ;
            for (let t = 0; t < e.length; t++)
                e[t].each(o);
            return t
        }
        )(k(t.selection, (t=>it(t).bind((t=>nr(e, t))).filter(o))));
        return U(n.length > 0, n)
    }
      , sr = (e,t,o,n,r)=>(s,l,c,a)=>{
        const i = Tt(s)
          , m = g.from(null == a ? void 0 : a.section).getOrThunk(Jo)
          , u = t(i, l).map((t=>{
            const o = ((e,t)=>((e,t,o)=>{
                const n = [];
                E(e.colgroups, (r=>{
                    const s = [];
                    for (let n = 0; n < e.grid.columns; n++) {
                        const r = Et(e, n).map((e=>ct(e.element, o, !1))).getOrThunk((()=>ct(t.colGap(), !0, !1)));
                        s.push(r)
                    }
                    n.push(at(r.element, s, "colgroup", o))
                }
                ));
                for (let r = 0; r < e.grid.rows; r++) {
                    const s = [];
                    for (let n = 0; n < e.grid.columns; n++) {
                        const l = Dt(e, r, n).map((e=>ct(e.element, o, e.isLocked))).getOrThunk((()=>ct(t.gap(), !0, !1)));
                        s.push(l)
                    }
                    const l = e.all[r]
                      , c = at(l.element, s, l.section, o);
                    n.push(c)
                }
                return n
            }
            )(e, t, !1))(i, c)
              , n = e(o, t, ce, r(c), m)
              , s = (e=>{
                const t = j(vt(e).rows, ((e,t)=>(E(t.cells, ((t,o)=>{
                    t.isLocked && (e[o] = !0)
                }
                )),
                e)), {})
                  , o = Ne(t, ((e,t)=>parseInt(t, 10)));
                return _(o)
            }
            )(n.grid);
            return {
                info: t,
                grid: (l = n.grid,
                or(l, ce)),
                cursor: n.cursor,
                lockedColumns: s
            };
            var l
        }
        ));
        return u.bind((e=>{
            const t = er(s, e.grid)
              , r = g.from(null == a ? void 0 : a.sizing).getOrThunk((()=>Yn(s)))
              , l = g.from(null == a ? void 0 : a.resize).getOrThunk(Ko);
            return o(s, e.grid, e.info, {
                sizing: r,
                resize: l,
                section: m
            }),
            n(s),
            Ve(s, yt),
            e.lockedColumns.length > 0 && ze(s, yt, e.lockedColumns.join(",")),
            g.some({
                cursor: e.cursor,
                newRows: t.newRows,
                newCells: t.newCells
            })
        }
        ))
    }
      , lr = (e,t)=>it(t.element).bind((t=>nr(e, t)))
      , cr = (e,t)=>rr(e, t, x)
      , ar = (e,t)=>z(t, (t=>((e,t)=>nr(e, t).exists((e=>!e.isLocked)))(e, t)))
      , ir = (e,t)=>((e,t)=>t.mergable)(0, t).filter((t=>ar(e, t.cells)))
      , mr = (e,t)=>((e,t)=>t.unmergable)(0, t).filter((t=>ar(e, t)))
      , ur = ["img", "br"]
      , dr = e=>{
        return (t = e,
        Kt.getOption(t)).filter((e=>0 !== e.trim().length || e.indexOf("\xa0") > -1)).isSome() || D(ur, X(e));
        var t
    }
      , hr = {
        scope: ["row", "col"]
    }
      , pr = e=>()=>{
        const t = Q.fromTag("td", e.dom);
        return Ft(t, Q.fromTag("br", e.dom)),
        t
    }
      , gr = e=>()=>Q.fromTag("col", e.dom)
      , fr = e=>()=>Q.fromTag("colgroup", e.dom)
      , wr = e=>()=>Q.fromTag("tr", e.dom)
      , br = (e,t,o)=>{
        const n = Xo(e, t);
        return Ee(o, ((e,t)=>{
            null === e ? Ve(n, t) : ze(n, t, e)
        }
        )),
        n
    }
      , vr = (e,t,o)=>{
        return (n = e,
        ((e,t)=>{
            const o = e=>{
                for (let n = 0; n < e.childNodes.length; n++) {
                    const r = Q.fromDom(e.childNodes[n]);
                    if (t(r))
                        return g.some(r);
                    const s = o(e.childNodes[n]);
                    if (s.isSome())
                        return s
                }
                return g.none()
            }
            ;
            return o(e.dom)
        }
        )(n, dr)).map((n=>{
            const r = o.join(",")
              , s = ye(n, r, (t=>ce(t, e)));
            return M(s, ((e,t)=>{
                const o = Qo(t, !1);
                return Ve(o, "contenteditable"),
                Ft(e, o),
                o
            }
            ), t)
        }
        )).getOr(t);
        var n
    }
      , yr = (e,t,o)=>{
        const n = (e,t)=>{
            ((e,t)=>{
                const o = e.dom
                  , n = t.dom;
                Ue(o) && Ue(n) && (n.style.cssText = o.style.cssText)
            }
            )(e.element, t),
            Je(t, "height"),
            1 !== e.colspan && Je(t, "width")
        }
        ;
        return {
            col: o=>{
                const r = Q.fromTag(X(o.element), t.dom);
                return n(o, r),
                e(o.element, r),
                r
            }
            ,
            colgroup: fr(t),
            row: wr(t),
            cell: r=>{
                const s = Q.fromTag(X(r.element), t.dom)
                  , l = o.getOr(["strong", "em", "b", "i", "span", "font", "h1", "h2", "h3", "h4", "h5", "h6", "p", "div"])
                  , c = l.length > 0 ? vr(r.element, s, l) : s;
                return Ft(c, Q.fromTag("br")),
                n(r, s),
                ((e,t)=>{
                    Ee(hr, ((o,n)=>Fe(e, n).filter((e=>D(o, e))).each((e=>ze(t, n, e)))))
                }
                )(r.element, s),
                e(r.element, s),
                s
            }
            ,
            replace: br,
            colGap: gr(t),
            gap: pr(t)
        }
    }
      , Cr = e=>Tt(e).grid
      , xr = (e,t=!1)=>{
        return be(e) ? e.dom.isContentEditable : (o = e,
        Oe(o, "[contenteditable]")).fold(w(t), (e=>"true" === Sr(e)));
        var o
    }
      , Sr = e=>e.dom.contentEditable
      , Tr = (e,t,o,n,r)=>k(e, (e=>{
        const s = t > 0 && t < e.cells.length && n(bt(e, t - 1), bt(e, t))
          , l = ((e,t,o,n,r,s,l)=>{
            if ("colgroup" !== o && n)
                return wt(e, t);
            {
                const t = wt(e, r);
                return ct(l(t.element, s), !0, !1)
            }
        }
        )(e, t, e.section, s, o, n, r);
        return ((e,t,o)=>((e,t,o)=>{
            const n = e.cells
              , r = n.slice(0, t)
              , s = n.slice(t)
              , l = r.concat(o).concat(s);
            return ft(e, l)
        }
        )(e, t, [o]))(e, t, l)
    }
    ))
      , Rr = {
        ...(e=>{
            if (!a(e))
                throw new Error("cases must be an array");
            if (0 === e.length)
                throw new Error("there must be at least one case");
            const t = []
              , o = {};
            return E(e, ((n,r)=>{
                const s = Ae(n);
                if (1 !== s.length)
                    throw new Error("one and only one name per case");
                const l = s[0]
                  , c = n[l];
                if (void 0 !== o[l])
                    throw new Error("duplicate key detected:" + l);
                if ("cata" === l)
                    throw new Error("cannot have a case named cata (sorry)");
                if (!a(c))
                    throw new Error("case arguments must be an array");
                t.push(l),
                o[l] = (...o)=>{
                    const n = o.length;
                    if (n !== c.length)
                        throw new Error("Wrong number of arguments to case " + l + ". Expected " + c.length + " (" + c + "), got " + n);
                    return {
                        fold: (...t)=>{
                            if (t.length !== e.length)
                                throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                            return t[r].apply(null, o)
                        }
                        ,
                        match: e=>{
                            const n = Ae(e);
                            if (t.length !== n.length)
                                throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + n.join(","));
                            if (!z(t, (e=>D(n, e))))
                                throw new Error("Not all branches were specified when using match. Specified: " + n.join(", ") + "\nRequired: " + t.join(", "));
                            return e[l].apply(null, o)
                        }
                        ,
                        log: e=>{
                            console.log(e, {
                                constructors: t,
                                constructor: l,
                                params: o
                            })
                        }
                    }
                }
            }
            )),
            o
        }
        )([{
            none: []
        }, {
            only: ["index"]
        }, {
            left: ["index", "next"]
        }, {
            middle: ["prev", "index", "next"]
        }, {
            right: ["prev", "index"]
        }])
    }
      , Dr = (e,t)=>kt(e) ? ((e,t)=>{
        const o = At(e);
        return k(o, ((e,o)=>({
            element: e.element,
            width: t[o],
            colspan: e.colspan
        })))
    }
    )(e, t) : ((e,t)=>{
        const o = (e=>I(e.all, (e=>e.cells)))(e);
        return k(o, (e=>{
            const o = ((e,t,o)=>{
                let n = 0;
                for (let r = e; r < t; r++)
                    n += void 0 !== o[r] ? o[r] : 0;
                return n
            }
            )(e.column, e.column + e.colspan, t);
            return {
                element: e.element,
                width: o,
                colspan: e.colspan
            }
        }
        ))
    }
    )(e, t)
      , Or = (e,t,o)=>{
        const n = Dr(e, t);
        E(n, (e=>{
            o.setElementWidth(e.element, e.width)
        }
        ))
    }
      , Ar = e=>j(e, ((e,t)=>O(e, (e=>e.column === t.column)) ? e : e.concat([t])), []).sort(((e,t)=>e.column - t.column))
      , kr = e=>xr(e, !0)
      , Er = (e,t,o)=>((e,t)=>({
        grid: e,
        cursor: t
    }))(e, ((e,t,o)=>{
        var n, r;
        const s = vt(e).rows;
        return g.from(null === (r = null === (n = s[t]) || void 0 === n ? void 0 : n.cells[o]) || void 0 === r ? void 0 : r.element).filter(kr).orThunk((()=>(e=>$(e, (e=>$(e.cells, (e=>{
            const t = e.element;
            return U(kr(t), t)
        }
        )))))(s)))
    }
    )(e, t, o))
      , Nr = (e,t,o,n)=>((e,t,o,n,r)=>{
        const s = Rt(t)
          , l = n.getWidths(s, n)
          , c = n.pixelWidth()
          , {newSizes: a, delta: i} = r.calcRedestributedWidths(l, c, o.pixelDelta, n.isRelative);
        Or(s, a, n),
        n.adjustTableWidth(i)
    }
    )(0, t, o, n.sizing, n.resize)
      , Wr = (e,t)=>{
        const o = kn(e)
          , n = Ar(t);
        return j(n, ((e,t)=>e + o[t.column].map(Ao).getOr(0)), 0)
    }
      , Lr = sr(((e,t,o,n)=>{
        const r = t.detail
          , s = r.column
          , l = r.column
          , c = Tr(e, l, s, o, n.getOrInit);
        return Er(c, r.row, l)
    }
    ), ((e,t)=>lr(e, t).filter((e=>!O([e], (e=>0 === e.column && e.isLocked)))).map((t=>({
        detail: t,
        pixelDelta: Wr(e, [t])
    })))), Nr, f, $o)
      , Mr = sr(((e,t,o,n)=>{
        const r = Ar(t.details)
          , s = ((e,t)=>I(e, (e=>{
            const o = e.cells
              , n = M(t, ((e,t)=>t >= 0 && t < e.length ? e.slice(0, t).concat(e.slice(t + 1)) : e), o);
            return n.length > 0 ? [at(e.element, n, e.section, e.isNew)] : []
        }
        )))(e, k(r, (e=>e.column)))
          , l = s.length > 0 ? s[0].cells.length - 1 : 0;
        return Er(s, r[0].row, Math.min(r[0].column, l))
    }
    ), ((e,t)=>((e,t)=>rr(e, t, (e=>!e.isLocked)))(e, t).map((t=>({
        details: t,
        pixelDelta: -Wr(e, t)
    })))), Nr, (e=>{
        0 === mt(e).length && Ht(e)
    }
    ), $o)
      , jr = (e,t)=>{
        const o = Pe(e, t);
        return void 0 === o || "" === o ? [] : o.split(" ")
    }
      , Br = e=>void 0 !== e.dom.classList
      , Ir = e=>e.dom.textContent
      , zr = re("th")
      , _r = (e,t)=>e && t ? "sectionCells" : e ? "section" : "cells"
      , Pr = e=>{
        const t = W(e, (e=>zr(e.element)));
        return 0 === t.length ? g.some("td") : t.length === e.length ? g.some("th") : g.none()
    }
      , Fr = e=>{
        const t = k(e, (e=>(e=>{
            const t = "thead" === e.section
              , o = G(Pr(e.cells), "th");
            return "tfoot" === e.section ? {
                type: "footer"
            } : t || o ? {
                type: "header",
                subType: _r(t, o)
            } : {
                type: "body"
            }
        }
        )(e).type))
          , o = D(t, "header")
          , n = D(t, "footer");
        if (o || n) {
            const e = D(t, "body");
            return !o || e || n ? o || e || !n ? g.none() : g.some("footer") : g.some("header")
        }
        return g.some("body")
    }
      , Vr = {
        structure: !1,
        style: !0
    }
      , $r = {
        structure: !0,
        style: !1
    }
      , Gr = (e,t,o)=>({
        value: t + 1
    })
      , qr = (e,t,o)=>{
        const n = "A".charCodeAt(0)
          , r = [];
        let s = t;
        for (; s >= 0; )
            r.push(String.fromCharCode(n + s % 26)),
            s = Math.floor(s / 26) - 1;
        return {
            value: r.reverse().join("")
        }
    }
      , Hr = e=>e.options.get("advtable_value_series")
      , Ur = e=>{
        const t = parseFloat(e);
        return isNaN(t) ? g.none() : g.some(t)
    }
      , Kr = (e,t)=>e < t ? -1 : e > t ? 1 : 0
      , Qr = (e,t)=>q(Ur(e), Ur(t), Kr).getOrThunk((()=>((e,t)=>e.localeCompare(t))(e, t)))
      , Xr = e=>{
        const t = (e=>g.from(e.options.get("table_clone_elements")))(e)
          , o = (o,r,s,l)=>(c,a,i,m,u=!1)=>{
            const d = Q.fromDom(e.getDoc())
              , h = yr(s, d, t);
            return r(c) ? o(c, a, h).bind((t=>{
                E(t.newRows, (t=>{
                    ((e,t)=>{
                        e.dispatch("NewRow", {
                            node: t
                        })
                    }
                    )(e, t.dom)
                }
                )),
                E(t.newCells, (t=>{
                    ((e,t)=>{
                        e.dispatch("NewCell", {
                            node: t
                        })
                    }
                    )(e, t.dom)
                }
                ));
                const o = ((t,o,r,s)=>{
                    const l = r.filter((e=>be(e) && n(e))).or(o.cursor);
                    return l.fold((()=>{
                        const o = mt(t);
                        return F(o).filter(be).map((o=>{
                            const n = e.dom.createRng();
                            return n.selectNode(o.dom),
                            s && (e.model.table.clearSelectedCells(t.dom),
                            e.selection.setRng(n),
                            ze(o, "data-mce-selected", "1")),
                            n
                        }
                        ))
                    }
                    ), (o=>{
                        const n = e.dom.createRng()
                          , r = yo(Co, o);
                        return n.setStart(r.element.dom, r.offset),
                        n.setEnd(r.element.dom, r.offset),
                        s && (e.model.table.clearSelectedCells(t.dom),
                        e.selection.setRng(n)),
                        g.some(n)
                    }
                    ))
                }
                )(c, t, i, m);
                return be(c) && ((e=>{
                    Ve(e, "data-mce-style");
                    const t = e=>Ve(e, "data-mce-style");
                    E(mt(e), t),
                    E(ut(e), t),
                    E(ht(e), t)
                }
                )(c),
                u || ((e,t,o)=>{
                    e.dispatch("TableModified", {
                        ...o,
                        table: t
                    })
                }
                )(e, c.dom, l)),
                o.map((e=>({
                    rng: e,
                    effect: l
                })))
            }
            )) : g.none()
        }
          , n = e=>xr(e, !0)
          , r = (e,t,o)=>((e,t)=>({
            grid: e,
            cursor: t
        }))(e, ((e,t,o)=>{
            var r, s;
            const l = vt(e).rows;
            return g.from(null === (s = null === (r = l[t]) || void 0 === r ? void 0 : r.cells[o]) || void 0 === s ? void 0 : s.element).filter(n).orThunk((()=>(e=>$(e, (e=>$(e.cells, (e=>{
                const t = e.element;
                return U(n(t), t)
            }
            )))))(l)))
        }
        )(e, t, o))
          , s = (e,t,o,n)=>{
            const {cols: r, rows: s} = vt(e)
              , l = L(s, (e=>e.section))
              , c = k(l, (e=>L(e, (e=>{
                const o = wt(e, t).element;
                return X(o)
            }
            ))))
              , a = I(c, (e=>I(e, (e=>{
                const r = wt(e[0], t).element;
                return "th" === X(r) ? e : (e=>{
                    const r = k(e, (e=>{
                        const o = wt(e, t).element;
                        return {
                            row: e,
                            text: g.from(Ir(o)).getOr("")
                        }
                    }
                    ))
                      , s = _(r, ((e,t)=>{
                        const r = o(e.text, t.text);
                        return n ? r : -1 * r
                    }
                    ));
                    return k(s, (e=>e.row))
                }
                )(e)
            }
            ))));
            return [...r, ...a]
        }
          , m = (e,t,o,n)=>{
            const {cols: r, rows: s} = vt(e)
              , l = s[t].cells
              , c = k(l, (e=>{
                const t = e.element;
                return g.from(Ir(t)).getOr("")
            }
            ))
              , a = re("th")
              , i = k(s, (e=>{
                const t = k(e.cells, ((e,t)=>({
                    cell: e,
                    column: t,
                    reference: l[t],
                    referenceText: c[t]
                })));
                return {
                    ...e,
                    zippedCells: t
                }
            }
            ))
              , m = k(i, (e=>{
                const t = L(e.zippedCells, (e=>{
                    const t = e.reference.element;
                    return X(t)
                }
                ))
                  , r = I(t, (e=>{
                    const t = e[0].reference.element;
                    if (a(t))
                        return k(e, (e=>e.cell));
                    {
                        const {pass: t, fail: r} = N(e, (e=>e.cell.isLocked))
                          , s = _(r, ((e,t)=>{
                            const r = o(e.referenceText, t.referenceText);
                            return n ? r : -1 * r
                        }
                        ))
                          , l = j(t, ((e,t)=>{
                            const o = t.column
                              , n = e.slice(0, o)
                              , r = e.slice(o);
                            return n.concat([t]).concat(r)
                        }
                        ), s);
                        return k(l, (e=>e.cell))
                    }
                }
                ));
                return at(e.element, r, e.section, e.isNew)
            }
            ));
            return [...r, ...m]
        }
          , u = s
          , d = m
          , h = (e,t,o,n,r)=>{
            const {cols: s, rows: l} = vt(e)
              , c = l.slice(0, t)
              , a = [...s, ...l.slice(t, o + 1)];
            return {
                beforeRows: c,
                afterRows: l.slice(o + 1, e.length),
                selectionGridBefore: a.map((e=>({
                    ...e,
                    cells: e.cells.slice(0, n)
                }))),
                selectionGrid: a.map((e=>({
                    ...e,
                    cells: e.cells.slice(n, r + 1)
                }))),
                selectionGridAfter: a.map((e=>({
                    ...e,
                    cells: e.cells.slice(r + 1, e.cells.length)
                })))
            }
        }
          , v = (e,t)=>{
            const o = k(t, ((t,o)=>{
                const n = e.selectionGridBefore[o].cells
                  , r = e.selectionGridAfter[o].cells;
                return {
                    ...t,
                    cells: n.concat(t.cells).concat(r)
                }
            }
            ))
              , {cols: n, rows: r} = vt(o);
            return [...n, ...e.beforeRows, ...r, ...e.afterRows]
        }
          , y = (e,t,o,n,r,l,c,a)=>{
            const i = h(e, o, n, r, l)
              , m = s(i.selectionGrid, t - r, c, a);
            return v(i, m)
        }
          , C = (e,t,o,n,r,s,l,c)=>{
            const a = h(e, o, n, r, s)
              , i = m(a.selectionGrid, t - o, l, c);
            return v(a, i)
        }
          , S = e=>j(e, ((e,t)=>O(e, (e=>e.row === t.row)) ? e : e.concat([t])), []).sort(((e,t)=>e.row - t.row))
          , T = e=>j(e, ((e,t)=>O(e, (e=>e.column === t.column)) ? e : e.concat([t])), []).sort(((e,t)=>e.column - t.column))
          , R = e=>j(e, ((e,t)=>O(e, (e=>ce(e.element, t.element))) ? e : e.concat([t])), [])
          , D = e=>{
            const t = c(e.attributes) ? Ne(e.attributes, ((e,t)=>i(e) ? e=>Ve(e, t) : o=>ze(o, t, e))) : [];
            return [...t, ...((e,t)=>{
                if (a(e)) {
                    for (let o = 0, n = e.length; o < n; ++o)
                        if (!t(e[o]))
                            return !1;
                    return !0
                }
                return !1
            }
            )(e.classes, l) ? k(e.classes, (e=>t=>((e,t)=>{
                Br(e) ? e.dom.classList.add(t) : ((e,t)=>{
                    ((e,t,o)=>{
                        const n = jr(e, t).concat([o]);
                        ze(e, t, n.join(" "))
                    }
                    )(e, "class", t)
                }
                )(e, t)
            }
            )(t, e))) : [], t=>{
                const o = Ir(t) || ""
                  , n = (r = e.value,
                p(r) ? String(r) : l(r) ? r : void 0);
                var r;
                const s = l(n) ? n : o;
                He(s) ? ((e,t)=>{
                    const o = ie(e).dom
                      , n = Q.fromDom(o.createDocumentFragment())
                      , r = ((e,t)=>{
                        const o = (t || document).createElement("div");
                        return o.innerHTML = e,
                        ge(Q.fromDom(o))
                    }
                    )(t, o);
                    Gt(n, r),
                    qt(e),
                    Ft(e, n)
                }
                )(t, "<br>") : ((e,t)=>{
                    e.dom.textContent = t
                }
                )(t, s)
            }
            ]
        }
          , A = (e,t,o,n,r,s,l,c)=>{
            let a;
            E(t, ((t,i)=>{
                const m = t.element
                  , u = {
                    sectionType: s(i),
                    cellType: X(m),
                    getRowType: l(i),
                    getColType: c(i),
                    classes: (p = m,
                    Br(p) ? (e=>{
                        const t = e.dom.classList
                          , o = new Array(t.length);
                        for (let e = 0; e < t.length; e++) {
                            const n = t.item(e);
                            null !== n && (o[e] = n)
                        }
                        return o
                    }
                    )(p) : (e=>jr(e, "class"))(p)),
                    prev: null == a ? void 0 : a.raw,
                    direction: o
                }
                  , d = e(u, n(i), r(i))
                  , h = D(d);
                var p;
                E(h, (e=>e(m))),
                a = d
            }
            ))
        }
          , W = (e,t,o,n,s)=>{
            const l = y(e, s, 0, e.length, s, s, o, n);
            return r(l, t[0].row, t[0].column)
        }
          , M = (e,t,o,n,s)=>{
            const l = S(t)
              , c = T(t)
              , a = y(e, s, l[0].row, l[l.length - 1].row, c[0].column, c[c.length - 1].column, o, n);
            return r(a, t[0].row, t[0].column)
        }
          , B = (e,t,o,n,s)=>{
            const l = u(e, s, o, n);
            return r(l, t.row, t.column)
        }
          , z = (e,t,o,n,s)=>{
            const l = C(e, s, s, s, 0, e[t[0].row].cells.length, o, n);
            return r(l, t[0].row, t[0].column)
        }
          , P = (e,t,o,n,s)=>{
            const l = S(t)
              , c = T(t)
              , a = C(e, s, l[0].row, l[l.length - 1].row, c[0].column, c[c.length - 1].column, o, n);
            return r(a, t[0].row, t[0].column)
        }
          , V = (e,t,o,n,s)=>{
            const l = d(e, s, o, n);
            return r(l, t.row, t.column)
        }
          , G = (e,t,o,n)=>{
            const s = vt(e).rows
              , l = k(s, (e=>wt(e, n)))
              , c = R(l)
              , a = go((()=>Pr(c).getOr("")));
            return A(o, c, "column", b, w(n), (e=>s[e].section), (e=>go((()=>{
                const t = s[e];
                return Fr([{
                    cells: t.cells,
                    section: t.section
                }]).getOr("")
            }
            ))), (e=>a)),
            r(e, t.row, t.column)
        }
          , q = (e,t,o,n)=>{
            const s = vt(e).rows
              , l = s[n]
              , c = R(l.cells)
              , a = go((()=>Fr([{
                cells: l.cells,
                section: l.section
            }]).getOr("")));
            return A(o, c, "row", w(n), b, (e=>l.section), (e=>a), (e=>go((()=>{
                const t = k(s, (t=>wt(t, e)));
                return Pr(t).getOr("")
            }
            )))),
            r(e, t.row, t.column)
        }
          , H = (e,t,o,n,r)=>(s,l,c)=>{
            const a = sr(((r,s)=>e(r, s, t, o, n)), r, f, f, $o);
            return a(s, l, c)
        }
          , K = (e,t,o,n)=>(r,s,l)=>{
            const c = sr(((n,r)=>e(n, r, t, o)), n, f, f, $o);
            return c(r, s, l)
        }
          , Y = o(Lr, x, _o, $r)
          , J = o(Mr, (t=>0 == ("table" === X(Nt(e))) || Cr(t).columns > 1), f, $r);
        return {
            sortColumnRowsAsc: e=>o(H(W, Qr, !0, e, cr), x, f, $r),
            sortColumnRowsDesc: e=>o(H(W, Qr, !1, e, cr), x, f, $r),
            sortSelectionRowsAsc: e=>o(H(M, Qr, !0, e, cr), x, f, $r),
            sortSelectionRowsDesc: e=>o(H(M, Qr, !1, e, cr), x, f, $r),
            sortTableRowsAsc: e=>o(H(B, Qr, !0, e, lr), x, f, $r),
            sortTableRowsDesc: e=>o(H(B, Qr, !1, e, lr), x, f, $r),
            sortRowColumnsAsc: e=>o(H(z, Qr, !0, e, cr), x, f, $r),
            sortRowColumnsDesc: e=>o(H(z, Qr, !1, e, cr), x, f, $r),
            sortSelectionColumnsAsc: e=>o(H(P, Qr, !0, e, cr), x, f, $r),
            sortSelectionColumnsDesc: e=>o(H(P, Qr, !1, e, cr), x, f, $r),
            sortTableColumnsAsc: e=>o(H(V, Qr, !0, e, lr), x, f, $r),
            sortTableColumnsDesc: e=>o(H(V, Qr, !1, e, lr), x, f, $r),
            insertColumnBefore: Y,
            deleteColumn: J,
            populateColumn: (e,t)=>o(K(G, t, e, lr), x, f, Vr),
            populateRow: (e,t)=>o(K(q, t, e, lr), x, f, Vr)
        }
    }
      , Yr = "data-snooker-locked-cols"
      , Jr = e=>Fe(e, Yr).map((e=>I(e.split(","), (e=>{
        const t = parseInt(e, 10);
        return isNaN(t) ? [] : [t]
    }
    )))).getOr([])
      , Zr = (e,t)=>ze(e, Yr, _(t).join(","))
      , es = (e,t)=>{
        const o = Jr(e);
        D(o, t) || Zr(e, o.concat([t]))
    }
      , ts = (e,t)=>{
        const o = Jr(e);
        Zr(e, W(o, (e=>t !== e)))
    }
      , os = "data-snooker-col-series"
      , ns = e=>Fe(e, os)
      , rs = (e,t)=>G(ns(e).map((e=>e.toLowerCase())), t.toLowerCase())
      , ss = e=>((e,t)=>{
        const o = e.dom;
        return !(!o || !o.hasAttribute) && o.hasAttribute("data-snooker-col-series")
    }
    )(e)
      , ls = e=>{
        const t = Yn(e)
          , o = Tt(e)
          , n = Dt(o, 0, 0).bind((e=>{
            const t = e.element;
            return To(Qe(t, "width"), ["fixed"])
        }
        )).map((e=>28 - e.value)).getOr(0);
        ((e,t,o,n,r)=>{
            const s = Tt(e)
              , l = r.getCellDelta(t)
              , c = r.getWidths(s, r)
              , a = 0 == s.grid.columns - 1
              , i = n.clampTableDelta(c, 0, l, r.minCellWidth(), a)
              , m = ((e,t,o,n,r)=>{
                const s = e.slice(0)
                  , l = ((e,t)=>0 === e.length ? Rr.none() : 1 === e.length ? Rr.only(0) : 0 === t ? Rr.left(0, 1) : t === e.length - 1 ? Rr.right(t - 1, t) : t > 0 && t < e.length - 1 ? Rr.middle(t - 1, t, t + 1) : Rr.none())(e, t)
                  , c = w(k(s, w(0)));
                return l.fold(c, (e=>n.singleColumnWidth(s[e], o)), ((e,t)=>r.calcLeftEdgeDeltas(s, e, t, o, n.minCellWidth(), n.isRelative)), ((e,t,l)=>r.calcMiddleDeltas(s, e, t, l, o, n.minCellWidth(), n.isRelative)), ((e,t)=>r.calcRightEdgeDeltas(s, e, t, o, n.minCellWidth(), n.isRelative)))
            }
            )(c, 0, i, r, n)
              , u = k(m, ((e,t)=>e + c[t]));
            Or(s, u, r),
            n.resizeTable(r.adjustTableWidth, i, a)
        }
        )(e, n, 0, Ko(), t)
    }
      , cs = (e,t,o,n,r)=>{
        ((e,t)=>{
            const o = O(Jr(e), (e=>0 === e));
            o && ts(e, 0),
            t(),
            o && es(e, 1)
        }
        )(e, (()=>{
            o.column(0, t.insertColumnBefore, !0, !0),
            ls(e),
            as(e, t, o, n, r)
        }
        ))
    }
      , as = (e,t,o,n,r)=>{
        o.table(e, 0, 0, t.populateColumn(0, ((e,t,o)=>{
            const n = r.generator(e, t, o);
            return {
                raw: n,
                value: n.value,
                classes: n.classes,
                attributes: {
                    contenteditable: "false",
                    ...n.attributes,
                    "data-mce-resize": !1 === r.resizable ? "false" : null
                }
            }
        }
        )), !0, !0),
        ((e,t)=>{
            ze(e, os, t)
        }
        )(e, n),
        es(e, 0)
    }
      , is = e=>{
        let t = e;
        return {
            get: ()=>t,
            set: e=>{
                t = e
            }
        }
    }
      , ms = e=>t=>{
        const o = t.getData();
        t.close(),
        e.undoManager.transact((()=>{
            e.execCommand("mceSortTableAdvanced", !1, o),
            e.focus(),
            e.addVisual()
        }
        ))
    }
      , us = e=>{
        const t = {
            type: "selectbox",
            name: "sortby",
            label: "Sort by",
            items: [{
                text: "Column",
                value: "column"
            }, {
                text: "Row",
                value: "row"
            }]
        }
          , o = is(g.none())
          , n = t=>({
            type: "selectbox",
            name: "roworcol",
            label: "column" === t ? "Column" : "Row",
            items: "column" === t ? (()=>{
                const t = o.get().getOrDie("state must be present")
                  , n = t.limit ? t.finishCol + 1 - t.startCol : t.columns;
                return A(n, (o=>{
                    const n = t.limit ? t.startCol : 0
                      , r = (e=>{
                        let t = e
                          , o = "";
                        for (; Math.floor(t) > 0; )
                            --t,
                            o += String.fromCharCode("A".charCodeAt(0) + t % 26),
                            t /= 26;
                        return o.split("").reverse().join("")
                    }
                    )(o + n + 1);
                    return {
                        text: e.translate(["Column {0}", r]),
                        value: `${o + n}`
                    }
                }
                ))
            }
            )() : (()=>{
                const t = o.get().getOrDie("state must be present")
                  , n = t.limit ? t.finishRow + 1 - t.startRow : t.rows;
                return A(n, (o=>{
                    const n = t.limit ? t.startRow : 0
                      , r = (o + n + 1).toString();
                    return {
                        text: e.translate(["Row {0}", r]),
                        value: `${o + n}`
                    }
                }
                ))
            }
            )()
        })
          , r = e=>({
            type: "selectbox",
            name: "sort",
            label: "Sort",
            items: ["column" === e ? {
                text: "Column",
                value: "column"
            } : {
                text: "Row",
                value: "row"
            }, {
                text: "Selection",
                value: "selection"
            }, {
                text: "Table",
                value: "table"
            }]
        })
          , s = {
            type: "selectbox",
            name: "order",
            label: "Order",
            items: [{
                text: "Ascending",
                value: "ascending"
            }, {
                text: "Descending",
                value: "descending"
            }]
        }
          , l = e=>({
            type: "panel",
            items: [{
                type: "grid",
                columns: 2,
                items: [t, n(e), r(e), s]
            }]
        })
          , c = e=>({
            title: "Advanced Sort",
            size: "normal",
            body: l(e),
            buttons: [{
                type: "cancel",
                name: "cancel",
                text: "Cancel"
            }, {
                type: "submit",
                name: "sort",
                text: "Sort",
                primary: !0
            }]
        })
          , a = ()=>{
            o.set(g.none())
        }
          , i = (t,n)=>{
            if ("sortby" === n.name) {
                const n = t.getData()
                  , r = o.get().getOrDie("state must be present")
                  , s = {
                    roworcol: "column" === n.sortby ? `${r.startCol}` : `${r.startRow}`
                }
                  , l = {
                    ...n,
                    ...s
                }
                  , m = {
                    ...c(n.sortby),
                    onChange: i,
                    onClose: a,
                    onSubmit: ms(e),
                    initialData: l
                };
                t.redial(m),
                t.focus("sortby")
            }
        }
        ;
        ho(Lt(e)).each((t=>{
            dt(t, Wt(e)).each((n=>{
                const r = io(po(e), n, t)
                  , s = t=>{
                    o.set(g.some(t));
                    const n = {
                        sortby: "column",
                        roworcol: `${t.startCol}`,
                        sort: "column",
                        order: "ascending"
                    }
                      , r = {
                        ...c("column"),
                        onChange: i,
                        onClose: a,
                        onSubmit: ms(e),
                        initialData: n
                    };
                    e.windowManager.open(r)
                }
                  , l = Cr(n);
                r.mergable.fold((()=>{
                    Bt(n, t, t).each((e=>{
                        const t = {
                            ...e,
                            ...l,
                            limit: !1
                        };
                        s(t)
                    }
                    ))
                }
                ), (e=>{
                    const t = {
                        ...e.bounds,
                        ...l,
                        limit: !0
                    };
                    s(t)
                }
                ))
            }
            ))
        }
        ))
    }
      , ds = (e,t,o,n)=>{
        const r = e=>"selection" === e
          , s = e=>"ascending" === e
          , c = t=>dt(t, Wt(e))
          , a = ()=>ho(Lt(e), Wt(e)).bind((e=>c(e).bind((t=>Bt(t, e, e)))))
          , i = ()=>a().map((e=>e.startCol))
          , m = ()=>a().map((e=>e.startRow));
        e.addCommand("mceSortTableByColumnAsc", (()=>{
            i().each((e=>{
                o.selection(t.sortTableRowsAsc(e))
            }
            ))
        }
        )),
        e.addCommand("mceSortTableByColumnDesc", (()=>{
            i().each((e=>{
                o.selection(t.sortTableRowsDesc(e))
            }
            ))
        }
        )),
        e.addCommand("mceSortTableByRowAsc", (()=>{
            m().each((e=>{
                o.selection(t.sortTableColumnsAsc(e))
            }
            ))
        }
        )),
        e.addCommand("mceSortTableByRowDesc", (()=>{
            m().each((e=>{
                o.selection(t.sortTableColumnsDesc(e))
            }
            ))
        }
        )),
        e.addCommand("mceSortTableAdvanced", ((e,n)=>(e=>{
            const n = parseInt(e.roworcol, 10);
            "column" === e.sortby ? ((e,n)=>{
                (e=>"column" === e)(e.sort) ? s(e.order) ? o.selection(t.sortColumnRowsAsc(n)) : o.selection(t.sortColumnRowsDesc(n)) : r(e.sort) ? s(e.order) ? o.selection(t.sortSelectionRowsAsc(n)) : o.selection(t.sortSelectionRowsDesc(n)) : s(e.order) ? o.selection(t.sortTableRowsAsc(n)) : o.selection(t.sortTableRowsDesc(n))
            }
            )(e, n) : ((e,n)=>{
                (e=>"row" === e)(e.sort) ? s(e.order) ? o.selection(t.sortRowColumnsAsc(n)) : o.selection(t.sortRowColumnsDesc(n)) : r(e.sort) ? s(e.order) ? o.selection(t.sortSelectionColumnsAsc(n)) : o.selection(t.sortSelectionColumnsDesc(n)) : s(e.order) ? o.selection(t.sortTableColumnsAsc(n)) : o.selection(t.sortTableColumnsDesc(n))
            }
            )(e, n)
        }
        )(n))),
        e.addCommand("mceAdvancedTableSort", (()=>us(e))),
        e.addCommand("mceTableToggleSeries", ((r,s)=>{
            const a = g.from(s.name).filter(l)
              , i = c(Lt(e));
            q(a, i, ((e,r)=>{
                rs(r, e) ? ((e,t,o)=>{
                    ts(e, 0),
                    (e=>{
                        Ve(e, os)
                    }
                    )(e),
                    o.column(0, t.deleteColumn, !0, !0)
                }
                )(r, t, o) : Me(n, e).each((n=>{
                    (ss(r) ? as : cs)(r, t, o, e, n)
                }
                ))
            }
            ))
        }
        ))
    }
      , hs = e=>{
        const t = is(g.none())
          , o = is([]);
        let n = g.none();
        const r = re("caption")
          , s = ()=>uo(Lt(e), Wt(e)).bind((t=>H(q(dt(t), uo((e=>Q.fromDom(e.selection.getEnd()))(e), Wt(e)).bind(dt), ((o,n)=>ce(o, n) ? r(t) ? g.some(ao(t)) : g.some(io(po(e), o, t)) : g.none())))))
          , l = e=>dt(e.element).map((t=>{
            const o = Tt(t)
              , n = cr(o, e).getOr([])
              , r = j(n, ((e,t)=>(t.isLocked && (e.onAny = !0,
            0 === t.column ? e.onFirst = !0 : t.column + t.colspan >= o.grid.columns && (e.onLast = !0)),
            e)), {
                onAny: !1,
                onFirst: !1,
                onLast: !1
            });
            return {
                mergeable: ir(o, e).isSome(),
                unmergeable: mr(o, e).isSome(),
                locked: r
            }
        }
        ))
          , c = ()=>{
            t.set(go(s)()),
            n = t.get().bind(l),
            E(o.get(), (e=>e()))
        }
          , a = e=>(e(),
        o.set(o.get().concat([e])),
        ()=>{
            o.set(W(o.get(), (t=>t !== e)))
        }
        )
          , i = (e,o)=>a((()=>t.get().fold((()=>{
            e.setEnabled(!1)
        }
        ), (t=>{
            e.setEnabled(!o(t))
        }
        ))));
        return e.on("NodeChange ExecCommand TableSelectorChange", c),
        {
            onSetupTable: e=>i(e, (e=>!1)),
            onSetupCellOrRow: e=>i(e, (e=>r(e.element))),
            onSetupColumn: e=>t=>i(t, (t=>r(t.element) || (e=>n.exists((t=>t.locked[e])))(e))),
            onSetupCellOrRowToggle: e=>o=>((e,o,n)=>a((()=>t.get().fold((()=>{
                e.setEnabled(!1),
                e.setActive(!1)
            }
            ), (t=>{
                e.setEnabled(!(e=>r(e.element))(t)),
                e.setActive(n(t))
            }
            )))))(o, 0, e),
            resetTargets: c,
            targets: ()=>t.get()
        }
    }
      , ps = e=>dt(Lt(e), Wt(e))
      , gs = (e,t)=>{
        e.execCommand("mceTableToggleSeries", !1, t)
    }
      , fs = (e,t,o)=>t.onSetupCellOrRowToggle((()=>((e,t)=>ps(e).exists((e=>He(t) ? !ss(e) : rs(e, t))))(e, o)))
      , ws = (e,t)=>({
        type: "togglemenuitem",
        text: "None",
        onAction: ()=>{
            (e=>ps(e).bind(ns))(e).each((t=>{
                gs(e, {
                    name: t
                })
            }
            ))
        }
        ,
        onSetup: fs(e, t, "")
    })
      , bs = (e,t,o,n,r)=>({
        type: "togglemenuitem",
        text: o,
        value: n,
        icon: r,
        onAction: ()=>gs(e, {
            name: n
        }),
        onSetup: fs(e, t, n)
    })
      , vs = (e,t,o)=>Ne(o, ((o,n)=>{
        const r = g.from(o.title).getOrThunk((()=>{
            return "" === (e = n) ? "" : e.charAt(0).toUpperCase() + e.substring(1);
            var e
        }
        ));
        return bs(e, t, r, n)
    }
    ));
    tinymce.PluginManager.requireLangPack("advtable", "ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW"),
    tinymce.PluginManager.add("advtable", (e=>{
        if (((e,o)=>!!e && -1 === ((e,o)=>{
            const n = t(e.major, o.major);
            if (0 !== n)
                return n;
            const r = t(e.minor, o.minor);
            if (0 !== r)
                return r;
            const s = t(e.patch, o.patch);
            return 0 !== s ? s : 0
        }
        )((e=>n((e=>[e.majorVersion, e.minorVersion].join(".").split(".").slice(0, 3).join("."))(e)))(e), n(o)))(tinymce, "6.0.0"))
            return console.error("Please use Advanced Tables with TinyMCE 6.0.0 or later."),
            {};
        (e=>{
            (0,
            e.options.register)("advtable_value_series", {
                processor: "object",
                default: {
                    numeric: {
                        title: "Numeric",
                        update: !0,
                        resizable: !1,
                        generator: Gr
                    },
                    alpha: {
                        title: "Alpha",
                        update: !0,
                        resizable: !1,
                        generator: qr
                    }
                }
            })
        }
        )(e);
        const o = Xr(e)
          , r = hs(e)
          , s = (e=>{
            const t = t=>{
                e.focus()
            }
              , o = t=>dt(t, Wt(e))
              , n = (n,r,s,l,c)=>{
                ho(Lt(e)).each((e=>{
                    o(e).each((o=>{
                        const a = Tt(o)
                          , i = (e,t)=>Ot(a, e, ce).map((e=>e[t]))
                          , m = n.orThunk((()=>i(e, "row")))
                          , u = r.orThunk((()=>i(e, "column")))
                          , d = H(q(m, u, ((e,t)=>Dt(a, e, t).map((e=>e.element)))));
                        d.bind((t=>{
                            const n = ao(t);
                            return s(o, n, U(l, e), !0, c)
                        }
                        )).each(t)
                    }
                    ))
                }
                ))
            }
            ;
            return {
                selection: (n,r)=>{
                    ho(Lt(e)).each((s=>{
                        o(s).each((o=>{
                            const l = io(po(e), o, s);
                            n(o, l, g.none(), !0, r).each(t)
                        }
                        ))
                    }
                    ))
                }
                ,
                row: (e,t,o,r)=>n(g.some(e), g.none(), t, o, r),
                column: (e,t,o,r)=>n(g.none(), g.some(e), t, o, r),
                table: (o,n,r,s,l,c)=>{
                    const a = Tt(o)
                      , i = Dt(a, n, r).map((e=>e.element))
                      , m = ho(Lt(e))
                      , u = m.bind((e=>Ot(a, e, ce))).isSome()
                      , d = i.bind((e=>{
                        const t = ao(e)
                          , n = u && l ? m : g.none();
                        return s(o, t, n, u, c)
                    }
                    ));
                    d.each(t)
                }
            }
        }
        )(e)
          , l = Hr(e);
        return ds(e, o, s, l),
        ((e,t,o,n)=>{
            const r = ()=>dt(Lt(e), Wt(e))
              , s = (s,l=x)=>{
                const c = ns(s)
                  , a = c.bind((e=>Me(n, e)));
                q(c, a, ((n,c)=>{
                    1 === Tt(s).grid.columns ? r().exists((e=>ce(s, e))) ? e.execCommand("mceTableDelete") : e.undoManager.transact((()=>{
                        Ht(s)
                    }
                    )) : !0 === c.update && l() && as(s, t, o, n, c)
                }
                ))
            }
            ;
            e.on("TableModified", (e=>{
                const t = Q.fromDom(e.table);
                s(t, (()=>!1 !== e.structure))
            }
            )),
            e.on("PreInit", (()=>{
                ((e,t)=>{
                    const o = e=>{
                        const t = [];
                        return u(e) ? t : ((e=>"thead" === e.name || "tbody" === e.name || "tfoot" === e.name)(e) ? t.push(...o(e.firstChild)) : "tr" === e.name && t.push(e),
                        t.concat(o(e.next)))
                    }
                      , n = e=>o(e.firstChild);
                    e.parser.addAttributeFilter(os, (e=>{
                        var o;
                        for (const r of e)
                            if ("table" === r.name) {
                                const e = r.attr(os);
                                if (!1 === (null === (o = t[e]) || void 0 === o ? void 0 : o.resizable)) {
                                    const e = n(r);
                                    for (const t of e)
                                        d(t.firstChild) && t.firstChild.attr("data-mce-resize", "false")
                                }
                            }
                    }
                    ))
                }
                )(e, n)
            }
            )),
            e.on("init", (()=>{
                const t = ()=>{
                    const t = ho(Lt(e), Wt(e));
                    return e.selection.isCollapsed() && t.exists((t=>e.dom.isEmpty(t.dom)))
                }
                ;
                e.on("ExecCommand", (e=>{
                    const o = e.command.toLowerCase();
                    "delete" !== o && "forwarddelete" !== o || !t() || r().each(s)
                }
                ), !0),
                e.on("keyup", (e=>{
                    const o = e.keyCode;
                    8 !== o && 46 !== o || !t() || r().each(s)
                }
                ))
            }
            ))
        }
        )(e, o, s, l),
        e.hasPlugin("table") && (((e,t)=>{
            const o = (t,o)=>()=>e.execCommand(t, !1, o)
              , n = t.onSetupCellOrRow
              , r = [{
                type: "menuitem",
                text: "Sort table by column ascending",
                onAction: o("mceSortTableByColumnAsc"),
                onSetup: n
            }, {
                type: "menuitem",
                text: "Sort table by column descending",
                onAction: o("mceSortTableByColumnDesc"),
                onSetup: n
            }, {
                type: "separator"
            }, {
                type: "menuitem",
                text: "Advanced sort...",
                onAction: ()=>us(e),
                onSetup: n
            }];
            e.ui.registry.addNestedMenuItem("advtablesort", {
                type: "nestedmenuitem",
                text: "Sort",
                getSubmenuItems: w(r)
            });
            const s = Hr(e);
            if (1 === Le(s)) {
                const o = Ae(s)[0];
                e.ui.registry.addToggleMenuItem("advtablerownumbering", bs(e, t, "Row numbering", o, "table-row-numbering"))
            } else
                Be(s) || e.ui.registry.addNestedMenuItem("advtablerownumbering", {
                    type: "nestedmenuitem",
                    text: "Row numbering",
                    icon: "table-row-numbering",
                    getSubmenuItems: ()=>{
                        const o = ws(e, t)
                          , n = vs(e, t, s);
                        return [o].concat(n)
                    }
                })
        }
        )(e, r),
        ((e,t)=>{
            const o = Hr(e);
            if (1 === Le(o)) {
                const n = Ae(o)[0];
                e.ui.registry.addToggleButton("advtablerownumbering", {
                    type: "togglebutton",
                    tooltip: "Row numbering",
                    icon: "table-row-numbering",
                    onAction: ()=>gs(e, {
                        name: n
                    }),
                    onSetup: fs(e, t, n)
                })
            } else
                Be(o) || e.ui.registry.addMenuButton("advtablerownumbering", {
                    type: "menubutton",
                    icon: "table-row-numbering",
                    tooltip: "Row numbering",
                    fetch: n=>{
                        const r = ws(e, t)
                          , s = vs(e, t, o);
                        return n([r].concat(s))
                    }
                    ,
                    onSetup: t.onSetupCellOrRow
                })
        }
        )(e, r)),
        {}
    }
    ))
}();
