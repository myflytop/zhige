/*!
 * Tiny Table of Contents plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 1.1.0-28
 */

!function() {
    "use strict";
    const t = ("string",
    t=>"string" === (t=>{
        const e = typeof t;
        return null === t ? "null" : "object" === e && Array.isArray(t) ? "array" : "object" === e && (n = o = t,
        (l = String).prototype.isPrototypeOf(n) || (null === (s = o.constructor) || void 0 === s ? void 0 : s.name) === l.name) ? "string" : e;
        var n, o, l, s
    }
    )(t));
    const e = t=>!(t=>null == t)(t)
      , n = t=>"number" == typeof t
      , o = t=>e=>e.options.get(t)
      , l = o("tableofcontents_class")
      , s = o("tableofcontents_header")
      , r = o("tableofcontents_depth")
      , c = (t=>{
        let e = 0;
        return ()=>"mcetoc_" + (new Date).getTime().toString(32) + (e++).toString(32)
    }
    )()
      , a = t=>{
        const n = l(t)
          , o = s(t)
          , a = (t=>{
            const e = [];
            for (let n = 1; n <= t; n++)
                e.push("h" + n);
            return e.join(",")
        }
        )(r(t));
        let i = t.dom.select(a);
        return i.length && /^h[1-9]$/i.test(o) && (i = ((t,e)=>{
            const n = [];
            for (let o = 0, l = t.length; o < l; o++) {
                const l = t[o];
                e(l) && n.push(l)
            }
            return n
        }
        )(i, (o=>{
            const l = o.parentNode;
            return e(l) && !t.dom.hasClass(l, n)
        }
        ))),
        ((t,e)=>{
            const n = t.length
              , o = new Array(n);
            for (let l = 0; l < n; l++) {
                const n = t[l];
                o[l] = e(n)
            }
            return o
        }
        )(i, (t=>({
            id: t.id || c(),
            level: parseInt(t.nodeName.replace(/^H/i, ""), 10),
            title: t.innerText,
            element: t
        })))
    }
      , i = t=>{
        let e = "";
        const n = a(t);
        let o = (t=>{
            let e = 9;
            for (const n of t)
                if (n.level < e && (e = n.level),
                1 === e)
                    return e;
            return e
        }
        )(n) - 1;
        if (!n.length)
            return "";
        e += ((t,e)=>{
            const n = "</" + t + ">";
            return "<" + t + ' contenteditable="true">' + tinymce.DOM.encode(e) + n
        }
        )(s(t), t.translate("Table of Contents"));
        for (let t = 0; t < n.length; t++) {
            const l = n[t];
            l.element.id = l.id;
            const s = n[t + 1] && n[t + 1].level;
            if (o === l.level)
                e += "<li>";
            else
                for (let t = o; t < l.level; t++)
                    e += "<ul><li>";
            if (e += '<a href="#' + l.id + '">' + l.title + "</a>",
            s !== l.level && s)
                for (let t = l.level; t > s; t--)
                    e += t === s + 1 ? "</li></ul><li>" : "</li></ul>";
            else
                e += "</li>",
                s || (e += "</ul>");
            o = l.level
        }
        return e
    }
      , d = t=>{
        const e = l(t)
          , n = t.dom.select("." + e);
        n.length && t.undoManager.transact((()=>{
            t.dom.setHTML(n, i(t))
        }
        ))
    }
      , u = t=>e=>{
        const n = ()=>e.setEnabled(!t.mode.isReadOnly() && (t=>a(t).length > 0)(t));
        return n(),
        t.on("LoadContent SetContent change", n),
        ()=>t.on("LoadContent SetContent change", n)
    }
      , f = t=>e=>t.dom.is(e, "." + l(t)) && t.getBody().contains(e);
    tinymce.PluginManager.requireLangPack("tableofcontents", "ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW"),
    tinymce.PluginManager.add("tableofcontents", (o=>{
        (e=>{
            const o = e.options.register;
            o("tableofcontents_class", {
                processor: "string",
                default: "mce-toc"
            }),
            o("tableofcontents_header", {
                processor: e=>t(e) && /^h[1-6]$/.test(e),
                default: "h2"
            }),
            o("tableofcontents_depth", {
                processor: t=>n(t) && t >= 1 && t <= 9,
                default: 3
            })
        }
        )(o),
        (t=>{
            t.addCommand("mceInsertToc", (()=>{
                (t=>{
                    const e = l(t)
                      , n = t.dom.select("." + e);
                    ((t,e)=>!e.length || t.dom.getParents(e[0], ".mce-offscreen-selection").length > 0)(t, n) ? t.insertContent((t=>{
                        const e = i(t);
                        return '<div class="' + t.dom.encode(l(t)) + '" contenteditable="false" data-mce-toc="true">' + e + "</div>"
                    }
                    )(t)) : d(t)
                }
                )(t)
            }
            )),
            t.addCommand("mceUpdateToc", (()=>{
                d(t)
            }
            ))
        }
        )(o),
        (t=>{
            const e = ()=>t.execCommand("mceInsertToc");
            t.ui.registry.addButton("tableofcontents", {
                icon: "toc",
                tooltip: "Table of contents",
                onAction: e,
                onSetup: u(t)
            }),
            t.ui.registry.addButton("tableofcontentsupdate", {
                icon: "reload",
                tooltip: "Update",
                onAction: ()=>t.execCommand("mceUpdateToc")
            }),
            t.ui.registry.addMenuItem("tableofcontents", {
                icon: "toc",
                text: "Table of contents",
                onAction: e,
                onSetup: u(t)
            }),
            t.ui.registry.addContextToolbar("tableofcontents", {
                items: "tableofcontentsupdate",
                predicate: f(t),
                scope: "node",
                position: "node"
            })
        }
        )(o),
        (t=>{
            const n = l(t)
              , o = "data-mce-toc";
            t.on("PreProcess", (e=>{
                const o = t.dom
                  , l = o.select("." + n, e.node)[0];
                l && ((t,e)=>{
                    for (let e = 0, l = t.length; e < l; e++)
                        n = t[e],
                        o.setAttrib(n, "contentEditable", null);
                    var n
                }
                )([l].concat(o.select("[contenteditable]", l)))
            }
            )),
            t.on("PreInit", (()=>{
                t.serializer.addTempAttr(o)
            }
            )),
            t.on("SetContent", (()=>{
                const l = t.dom
                  , s = l.select("." + n)[0];
                if (s) {
                    l.setAttribs(s, {
                        contentEditable: !1,
                        [o]: !0
                    });
                    const t = s.firstElementChild;
                    e(t) && l.setAttrib(t, "contentEditable", !0)
                }
            }
            ))
        }
        )(o)
    }
    ))
}();
