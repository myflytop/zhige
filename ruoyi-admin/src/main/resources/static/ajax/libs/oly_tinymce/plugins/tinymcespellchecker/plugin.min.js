/*!
 * Tiny Spell Checker Pro plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 3.0.3-295
 */

!function() {
    "use strict";
    const e = e=>parseInt(e, 10)
      , t = (e,t)=>{
        const n = e - t;
        return 0 === n ? 0 : n > 0 ? 1 : -1
    }
      , n = (e,t,n)=>({
        major: e,
        minor: t,
        patch: n
    })
      , r = t=>{
        const r = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(t);
        return r ? n(e(r[1]), e(r[2]), e(r[3])) : n(0, 0, 0)
    }
      , o = Object.getPrototypeOf
      , s = (e,t,n)=>{
        var r;
        return !!n(e, t.prototype) || (null === (r = e.constructor) || void 0 === r ? void 0 : r.name) === t.name
    }
      , l = e=>t=>(e=>{
        const t = typeof e;
        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && s(e, String, ((e,t)=>t.isPrototypeOf(e))) ? "string" : t
    }
    )(t) === e
      , a = e=>t=>typeof t === e
      , i = e=>t=>e === t
      , c = l("string")
      , u = l("object")
      , g = e=>((e,t)=>u(e) && s(e, t, ((e,t)=>o(e) === t)))(e, Object)
      , d = l("array")
      , m = i(null)
      , p = a("boolean")
      , h = i(void 0)
      , f = e=>null == e
      , y = e=>!f(e)
      , b = a("function")
      , w = a("number")
      , v = (e,t)=>{
        if (d(e)) {
            for (let n = 0, r = e.length; n < r; ++n)
                if (!t(e[n]))
                    return !1;
            return !0
        }
        return !1
    }
      , x = ()=>{}
      , k = (e,t)=>(...n)=>e(t.apply(null, n))
      , T = e=>()=>e
      , S = e=>e
      , O = (e,t)=>e === t;
    function E(e, ...t) {
        return (...n)=>{
            const r = t.concat(n);
            return e.apply(null, r)
        }
    }
    const C = e=>e()
      , _ = e=>{
        e()
    }
      , A = T(!1)
      , N = T(!0);
    class I {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new I(!0,e)
        }
        static none() {
            return I.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? I.some(e(this.value)) : I.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : I.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : I.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return y(e) ? I.some(e) : I.none()
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    I.singletonNone = new I(!1);
    const D = Array.prototype.slice
      , L = Array.prototype.indexOf
      , R = Array.prototype.push
      , j = (e,t)=>L.call(e, t)
      , M = (e,t)=>j(e, t) > -1
      , z = (e,t)=>{
        for (let n = 0, r = e.length; n < r; n++)
            if (t(e[n], n))
                return !0;
        return !1
    }
      , P = (e,t)=>{
        const n = e.length
          , r = new Array(n);
        for (let o = 0; o < n; o++) {
            const n = e[o];
            r[o] = t(n, o)
        }
        return r
    }
      , B = (e,t)=>{
        for (let n = 0, r = e.length; n < r; n++)
            t(e[n], n)
    }
      , F = (e,t)=>{
        const n = [];
        for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r];
            t(o, r) && n.push(o)
        }
        return n
    }
      , q = (e,t,n)=>(B(e, ((e,r)=>{
        n = t(n, e, r)
    }
    )),
    n)
      , V = (e,t)=>((e,t,n)=>{
        for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r];
            if (t(o, r))
                return I.some(o);
            if (n(o, r))
                break
        }
        return I.none()
    }
    )(e, t, A)
      , W = (e,t)=>{
        for (let n = 0, r = e.length; n < r; n++)
            if (t(e[n], n))
                return I.some(n);
        return I.none()
    }
      , U = (e,t)=>(e=>{
        const t = [];
        for (let n = 0, r = e.length; n < r; ++n) {
            if (!d(e[n]))
                throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
            R.apply(t, e[n])
        }
        return t
    }
    )(P(e, t))
      , H = (e,t)=>{
        for (let n = 0, r = e.length; n < r; ++n)
            if (!0 !== t(e[n], n))
                return !1;
        return !0
    }
      , J = e=>{
        const t = D.call(e, 0);
        return t.reverse(),
        t
    }
      , $ = e=>[e]
      , K = (e,t)=>t >= 0 && t < e.length ? I.some(e[t]) : I.none()
      , G = e=>K(e, 0)
      , Z = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , Y = {
        fromHtml: (e,t)=>{
            const n = (t || document).createElement("div");
            if (n.innerHTML = e,
            !n.hasChildNodes() || n.childNodes.length > 1) {
                const t = "HTML does not have a single root node";
                throw console.error(t, e),
                new Error(t)
            }
            return Z(n.childNodes[0])
        }
        ,
        fromTag: (e,t)=>{
            const n = (t || document).createElement(e);
            return Z(n)
        }
        ,
        fromText: (e,t)=>{
            const n = (t || document).createTextNode(e);
            return Z(n)
        }
        ,
        fromDom: Z,
        fromPoint: (e,t,n)=>I.from(e.dom.elementFromPoint(t, n)).map(Z)
    }
      , X = Object.keys
      , Q = Object.hasOwnProperty
      , ee = (e,t)=>{
        const n = X(e);
        for (let r = 0, o = n.length; r < o; r++) {
            const o = n[r];
            t(e[o], o)
        }
    }
      , te = (e,t)=>ne(e, ((e,n)=>({
        k: n,
        v: t(e, n)
    })))
      , ne = (e,t)=>{
        const n = {};
        return ee(e, ((e,r)=>{
            const o = t(e, r);
            n[o.k] = o.v
        }
        )),
        n
    }
      , re = (e,t)=>{
        const n = [];
        return ee(e, ((e,r)=>{
            n.push(t(e, r))
        }
        )),
        n
    }
      , oe = e=>re(e, S)
      , se = (e,t)=>le(e, t) ? I.from(e[t]) : I.none()
      , le = (e,t)=>Q.call(e, t)
      , ae = "undefined" != typeof window ? window : Function("return this;")()
      , ie = (e,t)=>((e,t)=>{
        let n = null != t ? t : ae;
        for (let t = 0; t < e.length && null != n; ++t)
            n = n[e[t]];
        return n
    }
    )(e.split("."), t)
      , ce = Object.getPrototypeOf
      , ue = e=>{
        const t = ie("ownerDocument.defaultView", e);
        return u(e) && ((e=>((e,t)=>{
            const n = ((e,t)=>ie(e, t))(e, t);
            if (null == n)
                throw new Error(e + " not available on this browser");
            return n
        }
        )("HTMLElement", e))(t).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(ce(e).constructor.name))
    }
      , ge = e=>e.dom.nodeName.toLowerCase()
      , de = e=>e.dom.nodeType
      , me = e=>t=>de(t) === e
      , pe = e=>8 === de(e) || "#comment" === ge(e)
      , he = e=>ue(e.dom)
      , fe = me(1)
      , ye = me(3)
      , be = me(9)
      , we = me(11)
      , ve = e=>t=>fe(t) && ge(t) === e
      , xe = (e,t,n)=>{
        if (!(c(n) || p(n) || w(n)))
            throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e),
            new Error("Attribute value was not simple");
        e.setAttribute(t, n + "")
    }
      , ke = (e,t,n)=>{
        xe(e.dom, t, n)
    }
      , Te = (e,t)=>{
        const n = e.dom.getAttribute(t);
        return null === n ? void 0 : n
    }
      , Se = (e,t)=>I.from(Te(e, t))
      , Oe = (e,t)=>{
        e.dom.removeAttribute(t)
    }
      , Ee = (e,t)=>{
        const n = e.dom;
        if (1 !== n.nodeType)
            return !1;
        {
            const e = n;
            if (void 0 !== e.matches)
                return e.matches(t);
            if (void 0 !== e.msMatchesSelector)
                return e.msMatchesSelector(t);
            if (void 0 !== e.webkitMatchesSelector)
                return e.webkitMatchesSelector(t);
            if (void 0 !== e.mozMatchesSelector)
                return e.mozMatchesSelector(t);
            throw new Error("Browser lacks native selectors")
        }
    }
      , Ce = (e,t)=>e.dom === t.dom
      , _e = Ee
      , Ae = (e,t,n=O)=>e.exists((e=>n(e, t)))
      , Ne = e=>{
        const t = []
          , n = e=>{
            t.push(e)
        }
        ;
        for (let t = 0; t < e.length; t++)
            e[t].each(n);
        return t
    }
      , Ie = (e,t,n)=>"" === t || e.length >= t.length && e.substr(n, n + t.length) === t
      , De = (e,t)=>-1 !== e.indexOf(t)
      , Le = (Re = /^\s+|\s+$/g,
    e=>e.replace(Re, ""));
    var Re;
    const je = e=>void 0 !== e.style && b(e.style.getPropertyValue)
      , Me = e=>Y.fromDom(e.dom.ownerDocument)
      , ze = e=>be(e) ? e : Me(e)
      , Pe = e=>I.from(e.dom.parentNode).map(Y.fromDom)
      , Be = (e,t)=>{
        const n = b(t) ? t : A;
        let r = e.dom;
        const o = [];
        for (; null !== r.parentNode && void 0 !== r.parentNode; ) {
            const e = r.parentNode
              , t = Y.fromDom(e);
            if (o.push(t),
            !0 === n(t))
                break;
            r = e
        }
        return o
    }
      , Fe = e=>I.from(e.dom.previousSibling).map(Y.fromDom)
      , qe = e=>I.from(e.dom.nextSibling).map(Y.fromDom)
      , Ve = e=>P(e.dom.childNodes, Y.fromDom)
      , We = (e,t)=>{
        const n = e.dom.childNodes;
        return I.from(n[t]).map(Y.fromDom)
    }
      , Ue = e=>e.dom.childNodes.length
      , He = (e,t)=>({
        element: e,
        offset: t
    })
      , Je = b(Element.prototype.attachShadow) && b(Node.prototype.getRootNode)
      , $e = T(Je)
      , Ke = Je ? e=>Y.fromDom(e.dom.getRootNode()) : ze
      , Ge = e=>Y.fromDom(e.dom.host)
      , Ze = e=>{
        const t = ye(e) ? e.dom.parentNode : e.dom;
        if (null == t || null === t.ownerDocument)
            return !1;
        const n = t.ownerDocument;
        return (e=>{
            const t = Ke(e);
            return we(n = t) && y(n.dom.host) ? I.some(t) : I.none();
            var n
        }
        )(Y.fromDom(t)).fold((()=>n.body.contains(t)), (r = Ze,
        o = Ge,
        e=>r(o(e))));
        var r, o
    }
      , Ye = (e,t,n)=>{
        ((e,t,n)=>{
            if (!c(n))
                throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e),
                new Error("CSS value must be a string: " + n);
            je(e) && e.style.setProperty(t, n)
        }
        )(e.dom, t, n)
    }
      , Xe = (e,t)=>{
        const n = e.dom
          , r = window.getComputedStyle(n).getPropertyValue(t);
        return "" !== r || Ze(e) ? r : Qe(n, t)
    }
      , Qe = (e,t)=>je(e) ? e.style.getPropertyValue(t) : ""
      , et = (e,t)=>{
        const n = e.dom
          , r = Qe(n, t);
        return I.from(r).filter((e=>e.length > 0))
    }
      , tt = (e,t)=>{
        ((e,t)=>{
            je(e) && e.style.removeProperty(t)
        }
        )(e.dom, t),
        Ae(Se(e, "style").map(Le), "") && Oe(e, "style")
    }
      , nt = (e,t)=>{
        Pe(e).each((n=>{
            n.dom.insertBefore(t.dom, e.dom)
        }
        ))
    }
      , rt = (e,t)=>{
        qe(e).fold((()=>{
            Pe(e).each((e=>{
                st(e, t)
            }
            ))
        }
        ), (e=>{
            nt(e, t)
        }
        ))
    }
      , ot = (e,t)=>{
        const n = (e=>We(e, 0))(e);
        n.fold((()=>{
            st(e, t)
        }
        ), (n=>{
            e.dom.insertBefore(t.dom, n.dom)
        }
        ))
    }
      , st = (e,t)=>{
        e.dom.appendChild(t.dom)
    }
      , lt = (e,t)=>{
        nt(e, t),
        st(t, e)
    }
      , at = (e,t)=>{
        B(t, ((n,r)=>{
            const o = 0 === r ? e : t[r - 1];
            rt(o, n)
        }
        ))
    }
      , it = (e,t)=>{
        B(t, (t=>{
            st(e, t)
        }
        ))
    }
      , ct = (e,t)=>{
        let n = [];
        return B(Ve(e), (e=>{
            t(e) && (n = n.concat([e])),
            n = n.concat(ct(e, t))
        }
        )),
        n
    }
      , ut = (e,t,n)=>{
        let r = e.dom;
        const o = b(n) ? n : A;
        for (; r.parentNode; ) {
            r = r.parentNode;
            const e = Y.fromDom(r);
            if (t(e))
                return I.some(e);
            if (o(e))
                break
        }
        return I.none()
    }
      , gt = e=>{
        const t = e.dom;
        null !== t.parentNode && t.parentNode.removeChild(t)
    }
      , dt = e=>{
        const t = Ve(e);
        t.length > 0 && at(e, t),
        gt(e)
    }
      , mt = (e,t)=>((e,t)=>{
        const n = void 0 === t ? document : t.dom;
        return 1 !== (r = n).nodeType && 9 !== r.nodeType && 11 !== r.nodeType || 0 === r.childElementCount ? [] : P(n.querySelectorAll(e), Y.fromDom);
        var r
    }
    )(t, e)
      , pt = (e,t,n)=>ut(e, (e=>Ee(e, t)), n)
      , ht = (e,t,n)=>((e,t,n,r,o)=>((e,t)=>Ee(e, t))(n, r) ? I.some(n) : b(o) && o(n) ? I.none() : t(n, r, o))(0, pt, e, t, n)
      , ft = ((e,t)=>{
        const n = t=>e(t) ? I.from(t.dom.nodeValue) : I.none();
        return {
            get: t=>{
                if (!e(t))
                    throw new Error("Can only get text value of a text node");
                return n(t).getOr("")
            }
            ,
            getOption: n,
            set: (t,n)=>{
                if (!e(t))
                    throw new Error("Can only set raw text value of a text node");
                t.dom.nodeValue = n
            }
        }
    }
    )(ye)
      , yt = e=>ft.get(e)
      , bt = (e,t)=>ft.set(e, t);
    var wt = ["body", "p", "div", "article", "aside", "figcaption", "figure", "footer", "header", "nav", "section", "ol", "ul", "li", "table", "thead", "tbody", "tfoot", "caption", "tr", "td", "th", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "pre", "address"]
      , vt = ()=>({
        up: T({
            selector: pt,
            closest: ht,
            predicate: ut,
            all: Be
        }),
        down: T({
            selector: mt,
            predicate: ct
        }),
        styles: T({
            get: Xe,
            getRaw: et,
            set: Ye,
            remove: tt
        }),
        attrs: T({
            get: Te,
            set: ke,
            remove: Oe,
            copyTo: (e,t)=>{
                ((e,t)=>{
                    const n = e.dom;
                    ee(t, ((e,t)=>{
                        xe(n, t, e)
                    }
                    ))
                }
                )(t, q(e.dom.attributes, ((e,t)=>(e[t.name] = t.value,
                e)), {}))
            }
        }),
        insert: T({
            before: nt,
            after: rt,
            afterAll: at,
            append: st,
            appendAll: it,
            prepend: ot,
            wrap: lt
        }),
        remove: T({
            unwrap: dt,
            remove: gt
        }),
        create: T({
            nu: Y.fromTag,
            clone: e=>Y.fromDom(e.dom.cloneNode(!1)),
            text: Y.fromText
        }),
        query: T({
            comparePosition: (e,t)=>e.dom.compareDocumentPosition(t.dom),
            prevSibling: Fe,
            nextSibling: qe
        }),
        property: T({
            children: Ve,
            name: ge,
            parent: Pe,
            document: e=>ze(e).dom,
            isText: ye,
            isComment: pe,
            isElement: fe,
            isSpecial: e=>{
                const t = ge(e);
                return M(["script", "noscript", "iframe", "noframes", "noembed", "title", "style", "textarea", "xmp"], t)
            }
            ,
            getLanguage: e=>fe(e) ? Se(e, "lang") : I.none(),
            getText: yt,
            setText: bt,
            isBoundary: e=>!!fe(e) && ("body" === ge(e) || M(wt, ge(e))),
            isEmptyTag: e=>!!fe(e) && M(["br", "img", "hr", "input"], ge(e)),
            isNonEditable: e=>fe(e) && "false" === Te(e, "contenteditable")
        }),
        eq: Ce,
        is: _e
    });
    const xt = (e,t)=>({
        element: e,
        offset: t
    })
      , kt = (e,t,n)=>({
        element: e,
        start: t,
        finish: n
    })
      , Tt = e=>{
        if (!d(e))
            throw new Error("cases must be an array");
        if (0 === e.length)
            throw new Error("there must be at least one case");
        const t = []
          , n = {};
        return B(e, ((r,o)=>{
            const s = X(r);
            if (1 !== s.length)
                throw new Error("one and only one name per case");
            const l = s[0]
              , a = r[l];
            if (void 0 !== n[l])
                throw new Error("duplicate key detected:" + l);
            if ("cata" === l)
                throw new Error("cannot have a case named cata (sorry)");
            if (!d(a))
                throw new Error("case arguments must be an array");
            t.push(l),
            n[l] = (...n)=>{
                const r = n.length;
                if (r !== a.length)
                    throw new Error("Wrong number of arguments to case " + l + ". Expected " + a.length + " (" + a + "), got " + r);
                return {
                    fold: (...t)=>{
                        if (t.length !== e.length)
                            throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                        return t[o].apply(null, n)
                    }
                    ,
                    match: e=>{
                        const r = X(e);
                        if (t.length !== r.length)
                            throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + r.join(","));
                        if (!H(t, (e=>M(r, e))))
                            throw new Error("Not all branches were specified when using match. Specified: " + r.join(", ") + "\nRequired: " + t.join(", "));
                        return e[l].apply(null, n)
                    }
                    ,
                    log: e=>{
                        console.log(e, {
                            constructors: t,
                            constructor: l,
                            params: n
                        })
                    }
                }
            }
        }
        )),
        n
    }
      , St = Tt([{
        before: ["element"]
    }, {
        after: ["element"]
    }, {
        rest: ["element"]
    }, {
        last: ["element"]
    }, {
        invalid: ["element", "offset"]
    }]);
    St.before,
    St.after,
    St.rest,
    St.last,
    St.invalid;
    const Ot = (e,t)=>W(e, (e=>e.start === t))
      , Et = (e,t,n=0)=>q(e, ((e,n)=>t(n, e.len).fold(T(e), (t=>({
        len: t.finish,
        list: e.list.concat([t])
    })))), {
        len: n,
        list: []
    }).list
      , Ct = (e,t,n)=>0 === t.length ? e : U(e, (e=>{
        const r = U(t, (t=>((e,t)=>t >= e.start && t <= e.finish)(e, t) ? [t - e.start] : []));
        return r.length > 0 ? ((e,t,n)=>{
            return r = n(e, t),
            o = e.start,
            P(r, (e=>({
                ...e,
                start: e.start + o,
                finish: e.finish + o
            })));
            var r, o
        }
        )(e, r, n) : [e]
    }
    ))
      , _t = Tt([{
        none: []
    }, {
        start: ["element"]
    }, {
        middle: ["before", "after"]
    }, {
        end: ["element"]
    }]);
    _t.none,
    _t.start,
    _t.middle,
    _t.end;
    const At = Tt([{
        include: ["item"]
    }, {
        excludeWith: ["item"]
    }, {
        excludeWithout: ["item"]
    }])
      , Nt = {
        include: At.include,
        excludeWith: At.excludeWith,
        excludeWithout: At.excludeWithout,
        cata: (e,t,n,r)=>e.fold(t, n, r)
    }
      , It = Tt([{
        boundary: ["item", "universe"]
    }, {
        empty: ["item", "universe"]
    }, {
        text: ["item", "universe"]
    }, {
        nonEditable: ["item", "universe"]
    }])
      , Dt = A
      , Lt = N
      , Rt = T(0)
      , jt = T(1)
      , Mt = e=>({
        ...e,
        isBoundary: ()=>e.fold(Lt, Dt, Dt, Dt),
        toText: ()=>e.fold(I.none, I.none, (e=>I.some(e)), I.none),
        is: t=>e.fold(Dt, Dt, ((e,n)=>n.eq(e, t)), Dt),
        len: ()=>e.fold(Rt, jt, ((e,t)=>t.property().getText(e).length), jt)
    })
      , zt = {
        text: k(Mt, It.text),
        boundary: k(Mt, It.boundary),
        empty: k(Mt, It.empty),
        nonEditable: k(Mt, It.empty),
        cata: (e,t,n,r,o)=>e.fold(t, n, r, o)
    }
      , Pt = T([])
      , Bt = (e,t,n)=>{
        if (e.property().isText(t))
            return [zt.text(t, e)];
        if (e.property().isEmptyTag(t))
            return [zt.empty(t, e)];
        if (e.property().isNonEditable(t))
            return [];
        if (e.property().isElement(t)) {
            const r = e.property().children(t)
              , o = e.property().isBoundary(t) ? [zt.boundary(t, e)] : []
              , s = void 0 !== n && n(t) ? [] : U(r, (t=>Bt(e, t, n)));
            return o.concat(s).concat(o)
        }
        return []
    }
      , Ft = Bt
      , qt = (e,t,n)=>{
        const r = ((e,t)=>{
            const n = [];
            let r = [];
            return B(e, (e=>{
                const o = t(e);
                Nt.cata(o, (()=>{
                    r.push(e)
                }
                ), (()=>{
                    r.length > 0 && n.push(r),
                    n.push([e]),
                    r = []
                }
                ), (()=>{
                    r.length > 0 && n.push(r),
                    r = []
                }
                ))
            }
            )),
            r.length > 0 && n.push(r),
            n
        }
        )(U(t, (t=>Ft(e, t, n))), (e=>e.match({
            boundary: ()=>Nt.excludeWithout(e),
            empty: ()=>Nt.excludeWith(e),
            text: ()=>Nt.include(e),
            nonEditable: ()=>Nt.excludeWithout(e)
        })));
        return F(r, (e=>e.length > 0))
    }
      , Vt = (e,t)=>{
        if (e.property().isText(t))
            return xt(t, e.property().getText(t).length);
        {
            const n = e.property().children(t);
            return n.length > 0 ? Vt(e, n[n.length - 1]) : xt(t, n.length)
        }
    }
      , Wt = (e,t,n)=>{
        const r = e.property().children(t);
        return r.length > 0 && n < r.length ? Wt(e, r[n], 0) : r.length > 0 && e.property().isElement(t) && r.length === n ? Vt(e, r[r.length - 1]) : xt(t, n)
    }
      , Ut = vt()
      , Ht = (e,t)=>{
        const n = Te(e, t);
        return void 0 === n || "" === n ? [] : n.split(" ")
    }
      , Jt = e=>void 0 !== e.dom.classList
      , $t = (e,t)=>{
        Jt(e) ? e.dom.classList.add(t) : ((e,t)=>{
            ((e,t,n)=>{
                const r = Ht(e, t).concat([n]);
                ke(e, t, r.join(" "))
            }
            )(e, "class", t)
        }
        )(e, t)
    }
      , Kt = (e,t)=>{
        Jt(e) ? e.dom.classList.remove(t) : ((e,t)=>{
            ((e,t,n)=>{
                const r = F(Ht(e, t), (e=>e !== n));
                r.length > 0 ? ke(e, t, r.join(" ")) : Oe(e, t)
            }
            )(e, "class", t)
        }
        )(e, t),
        (e=>{
            const t = Jt(e) ? e.dom.classList : (e=>Ht(e, "class"))(e);
            0 === t.length && Oe(e, "class")
        }
        )(e)
    }
      , Gt = Wt
      , Zt = (e,t)=>E(e.eq, t)
      , Yt = (e,t)=>{
        const n = e.property();
        return n.getLanguage(t).orThunk((()=>((e,t)=>{
            for (let n = 0; n < e.length; n++) {
                const r = t(e[n], n);
                if (r.isSome())
                    return r
            }
            return I.none()
        }
        )(e.up().all(t, A), n.getLanguage)))
    }
      , Xt = Yt
      , Qt = (e,t)=>({
        item: e,
        mode: t
    })
      , en = (e,t,n,r=tn)=>e.property().parent(t).map((e=>Qt(e, r)))
      , tn = (e,t,n,r=nn)=>n.sibling(e, t).map((e=>Qt(e, r)))
      , nn = (e,t,n,r=nn)=>{
        const o = e.property().children(t);
        return n.first(o).map((e=>Qt(e, r)))
    }
      , rn = [{
        current: en,
        next: tn,
        fallback: I.none()
    }, {
        current: tn,
        next: nn,
        fallback: I.some(en)
    }, {
        current: nn,
        next: nn,
        fallback: I.some(tn)
    }]
      , on = (e,t,n,r,o=rn)=>V(o, (e=>e.current === n)).bind((n=>n.current(e, t, r, n.next).orThunk((()=>n.fallback.bind((n=>on(e, t, n, r)))))))
      , sn = {
        left: ()=>({
            sibling: (e,t)=>e.query().prevSibling(t),
            first: e=>e.length > 0 ? I.some(e[e.length - 1]) : I.none()
        }),
        right: ()=>({
            sibling: (e,t)=>e.query().nextSibling(t),
            first: e=>e.length > 0 ? I.some(e[0]) : I.none()
        })
    }
      , ln = (e,t,n,r,o,s)=>on(e, t, r, o).bind((t=>s(t.item) ? I.none() : n(t.item) ? I.some(t.item) : ln(e, t.item, n, t.mode, o, s)))
      , an = (e,t,n,r)=>ln(e, t, n, tn, sn.right(), r)
      , cn = an
      , un = ()=>({
        left: sn.left,
        right: sn.right
    })
      , gn = on
      , dn = (e,t,n,r)=>({
        item: e,
        start: t,
        finish: n,
        text: r
    })
      , mn = (e,t)=>({
        items: e,
        abort: t
    })
      , pn = (e,t)=>{
        const n = e.property().getText(t);
        return dn(t, 0, n.length, n)
    }
      , hn = (e,t,n)=>mn([], !0)
      , fn = (e,t,n)=>mn([], !1)
      , yn = (e,t,n)=>{
        const r = e.property().getText(t);
        return n(r).fold((()=>mn([dn(t, 0, r.length, r)], !1)), (e=>{
            const n = e[0] === e[1] ? [] : [dn(t, e[0], e[1], r.substring(e[0], e[1]))];
            return mn(n, !0)
        }
        ))
    }
      , bn = pn
      , wn = (e,t)=>e.property().isText(t) ? pn(e, t) : dn(t, 0, 0, "")
      , vn = (e,t,n,r)=>(e.property().isBoundary(t) || e.property().isEmptyTag(t) || r(e, t) ? hn : e.property().isText(t) ? yn : fn)(e, t, n)
      , xn = T("[^\\w'\\-\xad\\u0100-\\u017F\\u00C0-\\u00FF\ufeff\\u2018\\u2019]")
      , kn = T("[\\w'\\-\xad\\u0100-\\u017F\\u00C0-\\u00FF\ufeff\\u2018\\u2019]")
      , Tn = (e,t,n,r)=>({
        term: ()=>new RegExp(e,r.getOr("g")),
        prefix: t,
        suffix: n
    })
      , Sn = Tn
      , On = xn
      , En = kn
      , Cn = (e,t)=>{
        const n = t.term()
          , r = [];
        let o = n.exec(e);
        for (; o; ) {
            const s = o.index + t.prefix(o)
              , l = o[0].length - t.prefix(o) - t.suffix(o);
            r.push({
                start: s,
                finish: s + l
            }),
            n.lastIndex = s + l,
            o = n.exec(e)
        }
        return r
    }
      , _n = Cn
      , An = new RegExp(On() + "+","g")
      , Nn = T(0)
      , In = un()
      , Dn = In.left()
      , Ln = In.right()
      , Rn = {
        left: {
            sibling: Dn.sibling,
            first: Dn.first,
            slicer: e=>(e=>{
                const t = _n(e, Sn(On(), Nn, Nn, I.none()));
                return I.from(t[t.length - 1]).map((e=>e.start))
            }
            )(e).map((t=>[t + 1, e.length]))
        },
        right: {
            sibling: Ln.sibling,
            first: Ln.first,
            slicer: e=>(e=>{
                const t = e.search(An);
                return t > -1 ? I.some(t) : I.none()
            }
            )(e).map((e=>[0, e]))
        }
    }
      , jn = (e,t,n,r,o)=>{
        const s = gn(e, t, n, r).map((t=>{
            const n = vn(e, t.item, r.slicer, o)
              , s = n.abort ? [] : jn(e, t.item, t.mode, r, o);
            return n.items.concat(s)
        }
        )).getOr([]);
        return F(s, (e=>e.text.trim().length > 0))
    }
      , Mn = (e,t,n,r)=>{
        const o = ((e,t,n)=>jn(e, t, tn, Rn.left, n))(e, t, r)
          , s = ((e,t,n)=>jn(e, t, tn, Rn.right, n))(e, n, r);
        return {
            left: o.length > 0 ? o[o.length - 1] : wn(e, t),
            right: s.length > 0 ? s[s.length - 1] : wn(e, n),
            isEmpty: 0 === o.length && 0 === s.length
        }
    }
      , zn = (e,t,n)=>({
        word: e,
        left: t,
        right: n
    })
      , Pn = ["'", "\u2018", "\u2019"]
      , Bn = U(Pn, (e=>P(["twas"], (t=>e + t))))
      , Fn = e=>M(Pn, e)
      , qn = e=>{
        const t = (o = En() + "+",
        Tn(o, T(0), T(0), I.none()))
          , n = _n(e, t)
          , r = e.length;
        var o;
        return P(n, (t=>{
            const n = t.start
              , o = t.finish
              , s = e.substring(n, o)
              , l = n > 0 ? I.some(e.charAt(n - 1)) : I.none()
              , a = o < r ? I.some(e.charAt(o)) : I.none();
            return (e=>{
                const t = (e=>{
                    const t = e.word;
                    return t.length >= 2 && Fn(t.charAt(t.length - 1)) && !Fn(t.charAt(t.length - 2)) ? (e=>{
                        const t = e.word;
                        return zn(t.substring(0, t.length - 1), e.left, I.some(t.charAt(t.length - 1)))
                    }
                    )(e) : e
                }
                )(e);
                return (e=>{
                    const t = e.word
                      , n = z(Bn, (e=>t.indexOf(e) > -1)) ? 2 : 1
                      , r = t.substring(0, n);
                    return H(r, Fn) && !Fn(t.charAt(n)) ? (e=>{
                        const t = e.word;
                        return zn(t.substring(1), I.some(t.charAt(0)), e.right)
                    }
                    )(e) : e
                }
                )(t)
            }
            )(zn(s, l, a))
        }
        ))
    }
      , Vn = {
        ...Tt([{
            aboveView: ["item"]
        }, {
            inView: ["item"]
        }, {
            belowView: ["item"]
        }]),
        cata: (e,t,n,r)=>e.fold(t, n, r)
    }
      , Wn = (e,t,n)=>e.property().isSpecial(n.item) || e.property().isNonEditable(n.item) ? I.some({
        item: n.item,
        mode: tn
    }) : e.property().isBoundary(n.item) ? Vn.cata(t.assess(n.item), (()=>n.mode !== en ? I.some({
        item: n.item,
        mode: tn
    }) : I.none()), (()=>I.some(n)), (()=>I.none())) : I.some(n)
      , Un = (e,t,n,r,o)=>{
        const s = e.property().getLanguage(o.item);
        e.property().isText(o.item) ? t.addDetail(n(e, o.item)) : e.property().isBoundary(o.item) ? Vn.cata(r.assess(o.item), x, (()=>(o.mode === nn ? t.openBoundary(s, o.item) : t.closeBoundary(s, o.item),
        I.some(o))), x) : e.property().isEmptyTag(o.item) ? t.addEmpty(o.item) : o.mode === nn ? t.openInline(s, o.item) : t.closeInline(s, o.item)
    }
      , Hn = (e,t,n,r,o,s)=>(e.eq(t, n) ? I.some(t) : e.property().parent(t)).map((l=>{
        const a = Xt(e, l).getOr(r);
        return ((e,t,n,r,o,s)=>{
            const l = t=>!e.eq(t.item, n) || t.mode === nn && !e.property().isText(t.item) && 0 !== e.property().children(t.item).length
              , a = (e=>{
                let t = [];
                const n = [];
                let r = []
                  , o = e;
                const s = e=>{
                    e.each((e=>{
                        t.push(e)
                    }
                    ))
                }
                  , l = e=>{
                    e.each((e=>{
                        t = t.slice(0, t.length - 1)
                    }
                    ))
                }
                  , a = ()=>{
                    r.length > 0 && n.push({
                        lang: o,
                        details: r
                    })
                }
                  , i = e=>{
                    a(),
                    r = [],
                    o = e
                }
                  , c = n=>n.or(I.from(t[t.length - 1])).getOr(e);
                return {
                    openInline: (e,t)=>{
                        const n = c(e);
                        n !== o && i(n),
                        s(e)
                    }
                    ,
                    closeInline: (e,t)=>{
                        l(e)
                    }
                    ,
                    addDetail: e=>{
                        const t = c(I.none());
                        t !== o && i(t),
                        r.push(e)
                    }
                    ,
                    addEmpty: e=>{
                        const t = c(I.none());
                        i(t)
                    }
                    ,
                    openBoundary: (e,t)=>{
                        s(e);
                        const n = c(e);
                        i(n)
                    }
                    ,
                    closeBoundary: (e,t)=>{
                        l(e);
                        const n = c(e);
                        i(n)
                    }
                    ,
                    done: ()=>(a(),
                    n.slice(0))
                }
            }
            )(r);
            let i = I.some({
                item: t,
                mode: nn
            }).filter(l);
            for (; i.isSome(); )
                i.each((t=>Un(e, a, o, s, t))),
                i = i.bind((t=>Wn(e, s, t))).filter(l).bind((t=>gn(e, t.item, t.mode, un().right()))).filter(l);
            return e.property().isText(n) && a.addDetail(o(e, n)),
            a.done()
        }
        )(e, t, n, a, o, s)
    }
    ))
      , Jn = (e,t,n,r,o,s)=>{
        const l = ((e,t,n)=>{
            const r = ((e,t,n,r=A)=>{
                const o = [t].concat(e.up().all(t))
                  , s = [n].concat(e.up().all(n))
                  , l = e=>W(e, r).fold((()=>e), (t=>e.slice(0, t + 1)))
                  , a = l(o)
                  , i = l(s)
                  , c = V(a, (t=>z(i, Zt(e, t))));
                return {
                    firstpath: a,
                    secondpath: i,
                    shared: c
                }
            }
            )(e, t, n);
            return r.shared.bind((t=>((e,t,n,r)=>{
                const o = e.property().children(t);
                if (e.eq(t, n[0]))
                    return I.some([n[0]]);
                if (e.eq(t, r[0]))
                    return I.some([r[0]]);
                const s = n=>{
                    const r = J(n)
                      , s = W(r, Zt(e, t)).getOr(-1)
                      , l = s < r.length - 1 ? r[s + 1] : r[s];
                    return W(o, Zt(e, l))
                }
                  , l = s(n)
                  , a = s(r);
                return l.bind((e=>a.map((t=>{
                    const n = Math.min(e, t)
                      , r = Math.max(e, t);
                    return o.slice(n, r + 1)
                }
                ))))
            }
            )(e, t, r.firstpath, r.secondpath)))
        }
        )(e, t, n).bind((t=>{
            if (0 === t.length)
                return I.none();
            const n = t[0]
              , l = t[t.length - 1];
            return Hn(e, n, l, r, o, s)
        }
        )).getOr([]);
        return ((e,t)=>{
            const n = P(t, (e=>{
                const t = e.details
                  , n = e.lang
                  , r = P(t, (e=>e.text)).join("")
                  , o = P(t, (e=>e.item));
                return {
                    lang: n,
                    words: qn(r),
                    elements: o
                }
            }
            ));
            return {
                zones: n
            }
        }
        )(0, l)
    }
      , $n = (e,t)=>(n,r)=>n.eq(r, e.item) ? e : n.eq(r, t.item) ? t : bn(n, r)
      , Kn = ()=>({
        zones: []
    })
      , Gn = (e,t,n,r)=>e.property().isBoundary(t) ? ((e,t,n,r,o)=>Jn(e, t, n, r, bn, o))(e, t, t, n, r) : e.property().isEmptyTag(t) ? Zn() : ((e,t,n,r)=>{
        const o = ((e,t)=>{
            const n = Mn(e, t, t, A)
              , r = n.isEmpty && ((e,t)=>!e.property().isText(t) && 0 === e.down().predicate(t, e.property().isText).length)(e, t);
            return {
                left: n.left,
                right: n.right,
                isEmpty: r
            }
        }
        )(e, t)
          , s = $n(o.left, o.right);
        return o.isEmpty ? Kn() : Jn(e, o.left.item, o.right.item, n, s, r)
    }
    )(e, t, n, r)
      , Zn = Kn
      , Yn = {
        af: "Afrikaans",
        af_za: "Afrikaans (South Africa)",
        ar: "Arabic",
        ca: "Catalan",
        cs: "Czech",
        da: "Danish",
        de: "German",
        el: "Greek",
        en: "English",
        en_au: "English (Australia)",
        en_br: "English (United Kingdom)",
        en_ca: "English (Canada)",
        en_gb: "English (United Kingdom)",
        en_gb_medical: "Medical English (UK)",
        en_uk: "English (United Kingdom)",
        en_us: "English (United States)",
        en_us_medical: "Medical English (US)",
        es: "Spanish",
        es_419: "Spanish (Latin America)",
        es_es: "Spanish (Spain)",
        fa: "Farsi",
        fi: "Finnish",
        fr: "French",
        fr_ca: "French (Canada)",
        he: "Hebrew",
        hr: "Croatian",
        hu: "Hungarian",
        it: "Italian",
        ja: "Japanese",
        kk: "Kazakh",
        ko: "Korean",
        mi_nz: "Maori (New Zealand)",
        nb: "Norwegian Bokm\xe5l",
        nl: "Dutch",
        nn: "Norwegian Nynorsk",
        no: "Norwegian",
        pl: "Polish",
        pt: "Portuguese",
        pt_br: "Portuguese (Brazil)",
        pt_pt: "Portuguese (Portugal)",
        ro: "Romanian",
        ru: "Russian",
        sk: "Slovak",
        sl: "Slovenian",
        sv: "Swedish",
        sv_fi: "Swedish (Finland)",
        th: "Thai",
        tr: "Turkish",
        tt: "Tatar",
        uk: "Ukrainian",
        zh: "Chinese",
        zh_cn: "Chinese (Simplified)",
        zh_tw: "Chinese (Traditional)"
    }
      , Xn = e=>e.replace(/-/g, "_").toLowerCase()
      , Qn = e=>se(Yn, Xn(e)).getOrThunk((()=>e.toUpperCase()))
      , er = (e=>{
        let t, n = !1;
        return (...r)=>(n || (n = !0,
        t = e.apply(null, r)),
        t)
    }
    )((()=>new RegExp("^" + /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g.source + "$")))
      , tr = e=>{
        return I.from((t = e,
        t.dom.textContent)).exists((e=>{
            const t = e.trim().replace(/[\u200B\uFEFF]/g, "");
            return er().test(t)
        }
        ));
        var t
    }
      , nr = vt()
      , rr = nr.property()
      , or = {
        ...nr,
        property: T({
            ...rr,
            getLanguage: (e,t)=>ht(e, "[lang]").map((e=>{
                const n = Se(e, "data-mce-lang").getOrThunk((()=>Te(e, "lang")))
                  , r = Xn(n);
                return h(t) || le(t, r) || (t[r] = Qn(r)),
                r
            }
            ))
        })
    }
      , sr = ()=>Zn()
      , lr = {
        assess: Vn.inView
    }
      , ar = {
        anything: T(lr)
    }
      , ir = (e,t,n,r,o,s)=>{
        const l = Jn(e, t, n, r, s, ar.anything()).zones;
        return 1 === l.length ? ((e,t)=>e.lang === t ? I.some(e) : I.none())(l[0], o) : I.none()
    }
      , cr = (e,t,n,r,o)=>ir(e, t, n, r, o, bn)
      , ur = (e,t,n,r)=>e.property().isBoundary(t) ? cr(e, t, t, n, r) : e.property().isEmptyTag(t) ? I.none() : ((e,t,n,r)=>{
        const o = ((e,t)=>(n,r)=>{
            const o = Yt(n, r).getOr(e);
            return t !== o
        }
        )(n, r)
          , s = Mn(e, t, t, o)
          , l = $n(s.left, s.right);
        return s.isEmpty ? ((e,t,n,r)=>{
            const o = e.property().isText(t) ? e.property().getText(t).length : e.property().children(t).length
              , s = Gt(e, t, 0)
              , l = Gt(e, t, o);
            return cr(e, s.element, l.element, n, r)
        }
        )(e, t, n, r) : ir(e, s.left.item, s.right.item, n, r, l)
    }
    )(e, t, n, r)
      , gr = vt()
      , dr = e=>U(e, (e=>ct(e, ye)))
      , mr = e=>U(e, Ve)
      , pr = e=>{
        const t = hr(e);
        return {
            resolve: e=>{
                const n = e.split(" ");
                return P(n, (e=>fr(t, e))).join(" ")
            }
        }
    }
      , hr = e=>e.replace(/\./g, "-")
      , fr = (e,t)=>e + "-" + t
      , yr = pr("data.mce").resolve
      , br = yr("annotation")
      , wr = yr("highlight-id")
      , vr = yr("lingo")
      , xr = (e,t)=>ht(e, "." + t)
      , kr = e=>I.from(Te(e, wr))
      , Tr = e=>kr(e).fold(T([e]), (t=>{
        const n = Me(e);
        return mt(n, "." + t)
    }
    ))
      , Sr = e=>{
        const t = (e=>I.from(Te(e, br)))(e)
          , n = Te(e, vr);
        return t.fold(T([e]), (t=>Or(Me(e), t, n)))
    }
      , Or = (e,t,n)=>{
        const r = mt(e, `span[${br}]`);
        return F(r, (e=>{
            const r = !y(n) || Te(e, vr) === n;
            return Te(e, br) === t && r
        }
        ))
    }
      , Er = T(br)
      , Cr = pr("mce").resolve
      , _r = yr("lingo")
      , Ar = Cr("spellchecker-annotation")
      , Nr = Cr("spellchecker-word")
      , Ir = Cr("spellchecker-ignore")
      , Dr = Cr("spellchecker-current")
      , Lr = (e,t)=>I.from(Te(e, t))
      , Rr = {
        nu: ()=>{
            const e = Y.fromTag("span");
            var t;
            return t = e,
            B([Ar, Nr], (e=>{
                $t(t, e)
            }
            )),
            ke(e, "aria-invalid", "spelling"),
            (e=>((e,t)=>({
                element: t,
                wrap: n=>{
                    e.insert().append(t, n)
                }
            }))(Ut, e))(e)
        }
        ,
        set: (e,t,n)=>{
            ke(e, "data-mce-bogus", 1),
            ke(e, Er(), n),
            ke(e, _r, t)
        }
        ,
        setCurrent: e=>{
            $t(e, Dr)
        }
        ,
        unSetCurrent: e=>{
            Kt(e, Dr)
        }
        ,
        label: T(Ar),
        wordLabel: T(Nr),
        ignoreLabel: T(Ir),
        currentLabel: T(Dr),
        detail: e=>kr(e).bind((t=>Lr(e, Er()).bind((n=>Lr(e, _r).map((r=>({
            id: t,
            word: n,
            lang: r,
            element: e
        })))))))
    }
      , jr = e=>({
        fold: (t,n)=>n(e)
    })
      , Mr = Cr("wrap-disabled")
      , zr = e=>{
        const t = Tr(e);
        B(t, (e=>{
            Kt(e, Mr)
        }
        ))
    }
    ;
    let Pr = 0;
    const Br = e=>{
        const t = (new Date).getTime()
          , n = Math.floor(1e9 * Math.random());
        return Pr++,
        e + "_" + n + Pr + String(t)
    }
      , Fr = (e,t,n)=>{
        const r = U(n, (e=>[e.start, e.finish]))
          , o = Ct(t, r, ((t,n)=>((e,t,n)=>{
            const r = e.property().getText(t)
              , o = F(((e,t)=>{
                if (0 === t.length)
                    return [e];
                const n = q(t, ((t,n)=>{
                    if (0 === n)
                        return t;
                    const r = e.substring(t.prev, n);
                    return {
                        prev: n,
                        values: t.values.concat([r])
                    }
                }
                ), {
                    prev: 0,
                    values: []
                })
                  , r = t[t.length - 1];
                return r < e.length ? n.values.concat(e.substring(r)) : n.values
            }
            )(r, n), (e=>e.length > 0));
            if (o.length <= 1)
                return [kt(t, 0, r.length)];
            e.property().setText(t, o[0]);
            const s = Et(o.slice(1), ((t,n)=>{
                const r = e.create().text(t)
                  , o = kt(r, n, n + t.length);
                return I.some(o)
            }
            ), o[0].length)
              , l = P(s, (e=>e.element));
            return e.insert().afterAll(t, l),
            [kt(t, 0, o[0].length)].concat(s)
        }
        )(e, t.element, n)));
        return P(n, (t=>{
            const n = ((e,t,n)=>{
                const r = Ot(e, t)
                  , o = Ot(e, n);
                return r.bind((t=>{
                    const r = o.getOr(((e,t)=>e[e.length - 1] && e[e.length - 1].finish === t ? e.length + 1 : -1)(e, n));
                    return r > -1 ? I.some(e.slice(t, r)) : I.none()
                }
                )).getOr([])
            }
            )(o, t.start, t.finish)
              , r = P(n, (e=>e.element))
              , s = P(r, e.property().getText).join("");
            return {
                elements: r,
                word: t.word,
                exact: s
            }
        }
        ))
    }
      , qr = (e,t,n,r)=>{
        const o = qt(e, t, r)
          , s = U(o, (t=>{
            const r = U(t, (e=>e.fold(Pt, Pt, (e=>[e]), Pt)))
              , o = ((e,t)=>{
                const n = U(t, (t=>{
                    const n = Cn(e, t.pattern);
                    return P(n, (e=>({
                        ...t,
                        ...e
                    })))
                }
                ));
                return (e=>{
                    const t = Array.prototype.slice.call(e, 0);
                    return t.sort(((e,t)=>e.start < t.start ? -1 : t.start < e.start ? 1 : 0)),
                    t
                }
                )(n)
            }
            )(P(r, e.property().getText).join(""), n)
              , s = ((e,t)=>Et(t, ((t,n)=>{
                const r = n + e.property().getText(t).length;
                return I.from(kt(t, n, r))
            }
            )))(e, r);
            return Fr(e, s, o)
        }
        ));
        return s
    }
      , Vr = (e,t,n,r)=>{
        const o = P(n, (e=>((e,t)=>({
            word: e,
            pattern: t
        }))(e, (e=>{
            const t = "((?:^'?)|(?:" + xn() + "+'?))" + e + "((?:'?$)|(?:'?" + xn() + "+))";
            return Tn(t, (e=>e.length > 1 ? e[1].length : 0), (e=>e.length > 2 ? e[2].length : 0), I.none())
        }
        )(e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")))));
        return qr(e, t, o, r)
    }
      , Wr = vt()
      , Ur = (e,t,n,r)=>{
        if (z(e, (e=>pt(e, "a").exists(tr))))
            return !1;
        {
            const o = (e=>{
                const t = dr(e);
                return P(t, (e=>ye(e) ? yt(e) : "")).join("")
            }
            )(e)
              , s = ((e,t,n)=>I.from(e[0]).bind((e=>{
                const r = ((e,t,n)=>ur(gr, e, t, n))(e, t, n);
                return r.bind((e=>{
                    const t = e.words;
                    return 1 === t.length ? I.some(t[0].word) : I.none()
                }
                ))
            }
            )))(e, n, r);
            return o === t && Ae(s, t)
        }
    }
      , Hr = (e,t,n,r,o)=>{
        const s = ((e,t)=>{
            const n = {};
            return B(e, (e=>{
                xr(e, t.label()).filter(Ze).each((e=>{
                    t.detail(e).each((t=>{
                        const {id: r, word: o, lang: s} = t
                          , l = Tr(e);
                        l.length > 0 && (n[r] = ((e,t,n,r)=>({
                            id: e,
                            elements: t,
                            word: n,
                            lang: r
                        }))(r, l, o, s))
                    }
                    ))
                }
                ))
            }
            )),
            n
        }
        )(e.elements, t)
          , l = ((e,t,n)=>{
            const r = oe(e);
            return P(r, (e=>{
                return e.lang === n && Ur(e.elements, e.word, t, e.lang) ? (r = e,
                {
                    fold: (e,t)=>t(r)
                }) : (e=>({
                    fold: (t,n)=>t(e)
                }))(e);
                var r
            }
            ))
        }
        )(s, o, e.lang);
        B(l, (e=>{
            const t = e=>t=>{
                B(t.elements, e)
            }
            ;
            e.fold(t(r), t(n))
        }
        ))
    }
      , Jr = (e,t,n,r)=>{
        Hr(t, Rr, zr, dt, e.lang());
        const o = ((e,t,n)=>((e,t,n)=>Vr(Wr, e, t, n))(e, t, n))(t.elements, n, r)
          , s = ((e,t)=>P(e, (e=>((e,t)=>{
            const n = U(e.elements, (e=>xr(e, t).fold(T([]), $)));
            return ((e,t,n)=>({
                id: e,
                match: t,
                current: n
            }))(Br("mce-cram"), e, I.from(n[0]))
        }
        )(e, t))))(o, Rr.label());
        return U(s, (n=>n.current.fold((()=>{
            const r = n.match
              , o = r.word;
            if (e.ignore(r))
                return [];
            const s = ((e,t)=>((e,t,n)=>{
                if (0 === t.length)
                    return t;
                const r = F(t, (t=>e.property().isText(t) && e.property().getText(t).length > 0));
                return P(r, (t=>{
                    const r = n();
                    return e.insert().before(t, r.element),
                    r.wrap(t),
                    r.element
                }
                ))
            }
            )(Ut, e, t))(F(r.elements, (e=>(he(e) ? I.some(e) : Pe(e).filter(he)).exists((e=>"false" !== e.dom.contentEditable && !ht(e, "a").exists(tr))))), Rr.nu) || [];
            return B(s, (e=>{
                var r, s;
                r = e,
                s = n.id,
                ke(r, wr, s),
                $t(r, s),
                Rr.set(e, t.lang, o)
            }
            )),
            s.length > 0 ? [jr(s)] : []
        }
        ), (e=>{
            return [(t = e,
            {
                fold: (e,n)=>e(t)
            })];
            var t
        }
        ))))
    }
      , $r = e=>((e,t,n)=>ht(e, "." + t + ":not(." + n + ")"))(e, Rr.label(), Rr.ignoreLabel())
      , Kr = e=>((e,t,n)=>P(e.dom.select("." + t + ":not(." + n + ")"), Y.fromDom))(e, Rr.label(), Rr.ignoreLabel())
      , Gr = e=>Rr.detail(e)
      , Zr = Rr.label
      , Yr = "no.language"
      , Xr = e=>e !== Yr
      , Qr = T(Yr)
      , eo = e=>{
        const t = {};
        return B(e, (e=>{
            t[e] = {}
        }
        )),
        X(t)
    }
      , to = ()=>(new Date).getTime()
      , no = (e,t=36e5)=>{
        const n = {}
          , r = (e,t,r)=>{
            n[e] = {
                result: t,
                timestamp: r
            }
        }
          , o = (e,n)=>e - n < t
          , s = T(n);
        return u(e) && (e=>{
            const t = to();
            ee(e, ((e,n)=>{
                o(t, e.timestamp) && r(n, e.result, e.timestamp)
            }
            ))
        }
        )(e),
        {
            set: r,
            get: (e,t)=>I.from(n[t]).filter((t=>o(e, t.timestamp))).map((e=>e.result)),
            dump: s
        }
    }
    ;
    var ro;
    !function(e) {
        e.JSON = "json",
        e.Blob = "blob",
        e.Text = "text",
        e.FormData = "formdata",
        e.MultipartFormData = "multipart/form-data"
    }(ro || (ro = {}));
    const oo = e=>{
        let t = I.none()
          , n = [];
        const r = e=>{
            o() ? s(e) : n.push(e)
        }
          , o = ()=>t.isSome()
          , s = e=>{
            t.each((t=>{
                setTimeout((()=>{
                    e(t)
                }
                ), 0)
            }
            ))
        }
        ;
        return e((e=>{
            o() || (t = I.some(e),
            B(n, s),
            n = [])
        }
        )),
        {
            get: r,
            map: e=>oo((t=>{
                r((n=>{
                    t(e(n))
                }
                ))
            }
            )),
            isReady: o
        }
    }
      , so = {
        nu: oo,
        pure: e=>oo((t=>{
            t(e)
        }
        ))
    }
      , lo = e=>{
        setTimeout((()=>{
            throw e
        }
        ), 0)
    }
      , ao = e=>{
        const t = t=>{
            e().then(t, lo)
        }
        ;
        return {
            map: t=>ao((()=>e().then(t))),
            bind: t=>ao((()=>e().then((e=>t(e).toPromise())))),
            anonBind: t=>ao((()=>e().then((()=>t.toPromise())))),
            toLazy: ()=>so.nu(t),
            toCached: ()=>{
                let t = null;
                return ao((()=>(null === t && (t = e()),
                t)))
            }
            ,
            toPromise: e,
            get: t
        }
    }
      , io = e=>ao((()=>new Promise(e)))
      , co = e=>ao((()=>Promise.resolve(e)))
      , uo = e=>{
        const t = t=>t(e)
          , n = T(e)
          , r = ()=>o
          , o = {
            tag: !0,
            inner: e,
            fold: (t,n)=>n(e),
            isValue: N,
            isError: A,
            map: t=>mo.value(t(e)),
            mapError: r,
            bind: t,
            exists: t,
            forall: t,
            getOr: n,
            or: r,
            getOrThunk: n,
            orThunk: r,
            getOrDie: n,
            each: t=>{
                t(e)
            }
            ,
            toOptional: ()=>I.some(e)
        };
        return o
    }
      , go = e=>{
        const t = ()=>n
          , n = {
            tag: !1,
            inner: e,
            fold: (t,n)=>t(e),
            isValue: A,
            isError: N,
            map: t,
            mapError: t=>mo.error(t(e)),
            bind: t,
            exists: A,
            forall: N,
            getOr: S,
            or: S,
            getOrThunk: C,
            orThunk: C,
            getOrDie: (r = String(e),
            ()=>{
                throw new Error(r)
            }
            ),
            each: x,
            toOptional: I.none
        };
        var r;
        return n
    }
      , mo = {
        value: uo,
        error: go,
        fromOption: (e,t)=>e.fold((()=>go(t)), uo)
    }
      , po = e=>({
        ...e,
        toCached: ()=>po(e.toCached()),
        bindFuture: t=>po(e.bind((e=>e.fold((e=>co(mo.error(e))), (e=>t(e)))))),
        bindResult: t=>po(e.map((e=>e.bind(t)))),
        mapResult: t=>po(e.map((e=>e.map(t)))),
        mapError: t=>po(e.map((e=>e.mapError(t)))),
        foldResult: (t,n)=>e.map((e=>e.fold(t, n))),
        withTimeout: (t,n)=>po(io((r=>{
            let o = !1;
            const s = setTimeout((()=>{
                o = !0,
                r(mo.error(n()))
            }
            ), t);
            e.get((e=>{
                o || (clearTimeout(s),
                r(e))
            }
            ))
        }
        )))
    })
      , ho = e=>po(io(e))
      , fo = e=>po(co(mo.value(e)))
      , yo = {
        nu: ho,
        wrap: po,
        pure: fo,
        value: fo,
        error: e=>po(co(mo.error(e))),
        fromResult: e=>po(co(e)),
        fromFuture: e=>po(e.map(mo.value)),
        fromPromise: e=>ho((t=>{
            e.then((e=>{
                t(mo.value(e))
            }
            ), (e=>{
                t(mo.error(e))
            }
            ))
        }
        ))
    }
      , bo = e=>io((t=>{
        const n = new FileReader;
        n.onload = e=>{
            const n = e.target ? e.target.result : "";
            t(n)
        }
        ,
        n.readAsText(e)
    }
    ))
      , wo = e=>{
        try {
            const t = JSON.parse(e);
            return mo.value(t)
        } catch (e) {
            return mo.error("Response was not JSON.")
        }
    }
      , vo = e=>co(e.response)
      , xo = e=>yo.nu((t=>{
        const n = new XMLHttpRequest;
        var r;
        n.open(e.method, (r = e.url,
        I.from(e.query).map((e=>{
            const t = re(e, ((e,t)=>encodeURIComponent(t) + "=" + encodeURIComponent(e)))
              , n = De(r, "?") ? "&" : "?";
            return t.length > 0 ? r + n + t.join("&") : r
        }
        )).getOr(r)), !0);
        const o = (e=>{
            const t = (n = e.body,
            I.from(n).bind((e=>{
                switch (e.type) {
                case ro.JSON:
                    return I.some("application/json");
                case ro.FormData:
                    return I.some("application/x-www-form-urlencoded; charset=UTF-8");
                case ro.MultipartFormData:
                    return I.none();
                case ro.Text:
                default:
                    return I.some("text/plain")
                }
            }
            )));
            var n;
            const r = !0 === e.credentials ? I.some(!0) : I.none()
              , o = (e=>{
                switch (e) {
                case ro.Blob:
                    return "application/octet-stream";
                case ro.JSON:
                    return "application/json, text/javascript";
                case ro.Text:
                    return "text/plain";
                default:
                    return ""
                }
            }
            )(e.responseType) + ", */*; q=0.01"
              , s = void 0 !== e.headers ? e.headers : {};
            return {
                contentType: t,
                responseType: (e=>{
                    switch (e) {
                    case ro.JSON:
                        return I.none();
                    case ro.Blob:
                        return I.some("blob");
                    case ro.Text:
                        return I.some("text");
                    default:
                        return I.none()
                    }
                }
                )(e.responseType),
                credentials: r,
                accept: o,
                headers: s,
                progress: b(e.progress) ? I.some(e.progress) : I.none()
            }
        }
        )(e);
        ((e,t)=>{
            t.contentType.each((t=>e.setRequestHeader("Content-Type", t))),
            e.setRequestHeader("Accept", t.accept),
            t.credentials.each((t=>e.withCredentials = t)),
            t.responseType.each((t=>e.responseType = t)),
            t.progress.each((t=>e.upload.addEventListener("progress", (e=>t(e.loaded, e.total))))),
            ee(t.headers, ((t,n)=>e.setRequestHeader(n, t)))
        }
        )(n, o);
        const s = ()=>{
            ((e,t,n)=>((e,t)=>{
                switch (e) {
                case ro.JSON:
                    return wo(t.response).fold((()=>vo(t)), co);
                case ro.Blob:
                    return (e=>I.from(e.response).map(bo).getOr(co("no response content")))(t);
                case ro.Text:
                default:
                    return vo(t)
                }
            }
            )(t, n).map((t=>({
                message: 0 === n.status ? "Unknown HTTP error (possible cross-domain request)" : `Could not load url ${e}: ${n.statusText}`,
                status: n.status,
                responseText: t
            }))))(e.url, e.responseType, n).get((e=>t(mo.error(e))))
        }
        ;
        var l;
        n.onerror = s,
        n.onload = ()=>{
            var r;
            0 !== n.status || (r = e.url,
            Ie(r, "file:", 0)) ? n.status < 100 || n.status >= 400 ? s() : ((e,t)=>{
                const n = e=>yo.error({
                    message: e,
                    status: t.status,
                    responseText: t.responseText
                });
                switch (e) {
                case ro.JSON:
                    return wo(t.response).fold(n, yo.pure);
                case ro.Blob:
                case ro.Text:
                    return yo.pure(t.response);
                default:
                    return n("unknown data type")
                }
            }
            )(e.responseType, n).get(t) : s()
        }
        ,
        (l = e.body,
        I.from(l).map((e=>e.type === ro.JSON ? JSON.stringify(e.data) : e.type === ro.FormData || e.type === ro.MultipartFormData ? (e=>{
            const t = new FormData;
            return ee(e, ((e,n)=>{
                t.append(n, e)
            }
            )),
            t
        }
        )(e.data) : e.data))).fold((()=>n.send()), (e=>{
            n.send(e)
        }
        ))
    }
    ))
      , ko = e=>({
        tag: 1,
        error: e
    })
      , To = (e,t)=>{
        const n = -1 === e.indexOf("?") ? "?" : "&";
        return t ? e + n + "apiKey=" + encodeURIComponent(t) : e
    }
      , So = e=>{
        const t = e.responseText;
        return u(t) ? t : e.message
    }
      , Oo = (e,t,n=So)=>{
        const r = (e=>se(e, "tiny-api-key").orThunk((()=>se(e, "tinymce-api-key"))).orThunk((()=>se(e, "textbox-api-key"))).getOrUndefined())(t);
        return {
            execute: o=>{
                const s = (l = {
                    url: To(e, r),
                    body: (a = o,
                    {
                        type: ro.JSON,
                        data: a
                    }),
                    responseType: ro.JSON,
                    credentials: !0,
                    headers: t
                },
                xo({
                    ...l,
                    method: "post"
                })).mapError(n);
                var l, a;
                return yo.wrap(s)
            }
            ,
            cancelCurrent: x
        }
    }
      , Eo = (e,t)=>{
        const n = [];
        return {
            execute: r=>(0 === e ? yo.nu((e=>{
                n.push({
                    resume: ()=>e(mo.value(void 0)),
                    reject: ()=>e(mo.error({
                        tag: 0
                    }))
                })
            }
            )) : (e -= 1,
            yo.pure(void 0))).bindFuture((()=>t.execute(r).map((t=>(I.from(n.shift()).fold((()=>e += 1), (e=>setTimeout(e.resume, 0))),
            t.mapError(ko)))))),
            cancelCurrent: ()=>{
                for (var e; n.length; )
                    null === (e = n.pop()) || void 0 === e || e.reject()
            }
        }
    }
    ;
    var Co;
    !function(e) {
        e[e.Error = 0] = "Error",
        e[e.Value = 1] = "Value"
    }(Co || (Co = {}));
    const _o = (e,t,n)=>e.stype === Co.Error ? t(e.serror) : n(e.svalue)
      , Ao = e=>({
        stype: Co.Value,
        svalue: e
    })
      , No = e=>({
        stype: Co.Error,
        serror: e
    })
      , Io = _o
      , Do = e=>u(e) && X(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2)
      , Lo = (e,t)=>No([{
        path: e,
        getErrorInfo: t
    }])
      , Ro = e=>(...t)=>{
        if (0 === t.length)
            throw new Error("Can't merge zero objects");
        const n = {};
        for (let r = 0; r < t.length; r++) {
            const o = t[r];
            for (const t in o)
                le(o, t) && (n[t] = e(n[t], o[t]))
        }
        return n
    }
      , jo = Ro(((e,t)=>g(e) && g(t) ? jo(e, t) : t))
      , Mo = Ro(((e,t)=>t))
      , zo = (e,t,n)=>{
        switch (e.tag) {
        case "field":
            return t(e.key, e.newKey, e.presence, e.prop);
        case "custom":
            return n(e.newKey, e.instantiator)
        }
    }
      , Po = (Bo = Ao,
    {
        extract: (e,t)=>{
            return n = Bo(t),
            r = t=>((e,t)=>Lo(e, T(t)))(e, t),
            n.stype === Co.Error ? r(n.serror) : n;
            var n, r
        }
        ,
        toString: T("val")
    });
    var Bo;
    const Fo = (e,t,n,r)=>r(se(e, t).getOrThunk((()=>n(e))))
      , qo = (e,t,n,r,o)=>{
        const s = e=>o.extract(t.concat([r]), e)
          , l = e=>e.fold((()=>Ao(I.none())), (e=>{
            const n = o.extract(t.concat([r]), e);
            return s = n,
            l = I.some,
            s.stype === Co.Value ? {
                stype: Co.Value,
                svalue: l(s.svalue)
            } : s;
            var s, l
        }
        ));
        switch (e.tag) {
        case "required":
            return ((e,t,n,r)=>se(t, n).fold((()=>((e,t,n)=>Lo(e, (()=>'Could not find valid *required* value for "' + t + '" in ' + Do(n))))(e, n, t)), r))(t, n, r, s);
        case "defaultedThunk":
            return Fo(n, r, e.process, s);
        case "option":
            return ((e,t,n)=>n(se(e, t)))(n, r, l);
        case "defaultedOptionThunk":
            return ((e,t,n,r)=>r(se(e, t).map((t=>!0 === t ? n(e) : t))))(n, r, e.process, l);
        case "mergeWithThunk":
            return Fo(n, r, T({}), (t=>{
                const r = jo(e.process(n), t);
                return s(r)
            }
            ))
        }
    }
      , Vo = (e,t,n)=>{
        return r = ((e,t,n)=>((e,t)=>e.stype === Co.Error ? {
            stype: Co.Error,
            serror: t(e.serror)
        } : e)(t.extract([e], n), (e=>({
            input: n,
            errors: e
        }))))(e, t, n),
        _o(r, mo.error, mo.value);
        var r
    }
      , Wo = e=>"Errors: \n" + (e=>{
        const t = e.length > 10 ? e.slice(0, 10).concat([{
            path: [],
            getErrorInfo: T("... (only showing first ten failures)")
        }]) : e;
        return P(t, (e=>"Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()))
    }
    )(e.errors).join("\n") + "\n\nInput object: " + Do(e.input)
      , Uo = e=>((e,t)=>t((t=>{
        const n = [];
        let r = 0;
        0 === e.length ? t([]) : B(e, ((o,s)=>{
            o.get((o=>s=>{
                n[o] = s,
                r++,
                r >= e.length && t(n)
            }
            )(s))
        }
        ))
    }
    )))(e, io);
    Tt([{
        bothErrors: ["error1", "error2"]
    }, {
        firstError: ["error1", "value2"]
    }, {
        secondError: ["value1", "error2"]
    }, {
        bothValues: ["value1", "value2"]
    }]);
    const Ho = (e,t,n,r,o,s)=>{
        const l = ((e,t,n,r,o)=>o ? {
            known: {},
            unknown: n
        } : q(n, ((n,o)=>{
            const s = r(o);
            return e(t, s).fold((()=>({
                known: n.known,
                unknown: n.unknown.concat([o])
            })), (e=>{
                const t = ((e,t)=>((e,t)=>({
                    [e]: t
                }))(e, t))(s, e);
                return {
                    known: {
                        ...n.known,
                        ...t
                    },
                    unknown: n.unknown
                }
            }
            ))
        }
        ), {
            known: {},
            unknown: []
        }))(t.get, o, n, r, s);
        return 0 === l.unknown.length ? yo.value(l.known) : ((e,t,n,r,o,s)=>e(r, s).mapResult((e=>(ee(e, ((e,n)=>{
            t.set(n, e, o)
        }
        )),
        {
            ...n,
            ...e
        }))))(e, t, l.known, l.unknown, o, s)
    }
      , Jo = T(Po)
      , $o = e=>((e,t,n,r)=>({
        tag: "field",
        key: e,
        newKey: t,
        presence: n,
        prop: r
    }))(e, e, {
        tag: "required",
        process: {}
    }, Jo())
      , Ko = (e=>({
        extract: (t,n)=>((e,t,n)=>{
            const r = {}
              , o = [];
            for (const s of n)
                zo(s, ((n,s,l,a)=>{
                    const i = qo(l, e, t, n, a);
                    Io(i, (e=>{
                        o.push(...e)
                    }
                    ), (e=>{
                        r[s] = e
                    }
                    ))
                }
                ), ((e,n)=>{
                    r[e] = n(t)
                }
                ));
            return o.length > 0 ? No(o) : Ao(r)
        }
        )(t, n, e),
        toString: ()=>{
            const t = P(e, (e=>zo(e, ((e,t,n,r)=>e + " -> " + r.toString()), ((e,t)=>"state(" + e + ")"))));
            return "obj{\n" + t.join("\n") + "}"
        }
    }))([$o("language"), $o("words")])
      , Go = (e,t,n,r,o)=>{
        const s = ((e,t)=>{
            const n = [];
            for (let r = 0; r < e.length; r += t) {
                const o = D.call(e, r, r + t);
                n.push(o)
            }
            return n
        }
        )(r, o)
          , l = P(s, (t=>{
            const r = ((e,t,n)=>Vo(e, t, n).fold((e=>{
                throw new Error(Wo(e))
            }
            ), S))("ephox.spelling.service.many.ajax.service.get", Ko, {
                language: n,
                words: t
            });
            return e.execute(r)
        }
        ))
          , a = Uo(l).map((e=>{
            const n = (e=>{
                const t = []
                  , n = [];
                return B(e, (e=>{
                    e.fold((e=>{
                        t.push(e)
                    }
                    ), (e=>{
                        n.push(e)
                    }
                    ))
                }
                )),
                {
                    errors: t,
                    values: n
                }
            }
            )(e);
            if (n.values.length > 0) {
                const e = P(n.values, t)
                  , r = q(e, Mo, {});
                return mo.value(r)
            }
            {
                const e = (e=>{
                    const t = F(e, (e=>1 === e.tag));
                    return P(t, (e=>e.error))
                }
                )(n.errors);
                return 0 === e.length ? mo.value({}) : mo.error(e)
            }
        }
        ));
        return yo.wrap(a)
    }
      , Zo = (e={})=>{
        const t = {};
        return ee(e, ((e,n)=>{
            t[n] = no(e)
        }
        )),
        t
    }
      , Yo = Br("good-spelling")
      , Xo = (e,t)=>se(e, t).getOrThunk((()=>no()))
      , Qo = e=>eo(e).sort()
      , es = e=>{
        const t = e.responseText
          , n = u(t) ? t : {
            error: {
                data: null,
                message: e.message,
                type: "Unknown"
            }
        };
        return {
            status: e.status,
            ...n
        }
    }
      , ts = {
        chunkSize: 1500,
        maxRetries: 3,
        maxInFlight: 8
    }
      , ns = (e,t,n,r=ts)=>{
        var o;
        e = ((e,t)=>Ie(e, t, e.length - t.length))(o = e, "/") ? ((e,t)=>e.substring(0, e.length - t))(o, "/".length) : o;
        const s = Zo(n)
          , l = Zo({})
          , a = e=>{
            const t = ((e,t)=>({
                execute: e=>{
                    let n = 0;
                    const o = ()=>(n++,
                    t.execute(e).bind(s))
                      , s = e=>e.fold((e=>((e,t)=>!(t >= r.maxRetries) && (e.status < 400 || e.status >= 500))(e, n) ? o() : yo.error(e)), yo.pure);
                    return yo.wrap(o())
                }
                ,
                cancelCurrent: t.cancelCurrent
            }))(0, e);
            return Eo(r.maxInFlight, t)
        }
          , i = a(Oo(e + "/2/check", t, es))
          , c = a(Oo(e + "/2/suggestions", t, es));
        return {
            check: (e,t)=>{
                const n = Qo(t)
                  , o = to()
                  , a = Xo(l, e)
                  , c = Xo(s, e);
                return l[e] = a,
                s[e] = c,
                ((e,t,n,r,o,s,l,a)=>{
                    const i = e=>e.check;
                    return Ho(((t,n)=>Go(e, i, r, t, l)), n, o, S, s, !1).mapResult((e=>{
                        const n = {};
                        return ee(e, ((e,r)=>{
                            e ? t.set(r, Yo, s) : n[r] = !1
                        }
                        )),
                        n
                    }
                    ))
                }
                )(i, c, a, e, n, o, r.chunkSize)
            }
            ,
            suggestions: (e,t)=>{
                const n = Qo(t)
                  , o = to()
                  , l = Xo(s, e);
                return s[e] = l,
                ((e,t,n,r,o,s,l)=>{
                    const a = e=>e.spell;
                    return Ho(((t,r)=>Go(e, a, n, t, s)), t, r, S, o, !1).mapResult((e=>{
                        B(r, (n=>{
                            le(e, n) || t.set(n, Yo, o)
                        }
                        ));
                        const n = {};
                        return ee(e, ((e,r)=>{
                            t.get(o, r).each((t=>{
                                t !== Yo && (n[r] = e)
                            }
                            ))
                        }
                        )),
                        n
                    }
                    ))
                }
                )(c, l, e, n, o, r.chunkSize)
            }
            ,
            cancelCurrent: ()=>{
                i.cancelCurrent(),
                c.cancelCurrent()
            }
            ,
            dumpCache: ()=>te(s, (e=>e.dump()))
        }
    }
      , rs = [{
        value: "no.language",
        text: "Off"
    }]
      , os = e=>t=>t.options.get(e)
      , ss = os("spellchecker_dialog")
      , ls = os("spellchecker_language")
      , as = os("spellchecker_ignore_list")
      , is = os("spellchecker_handler")
      , cs = os("spellchecker_rpc_url")
      , us = os("spellchecker_active")
      , gs = e=>{
        const t = new RegExp("\ufeff","g")
          , n = new RegExp("[\u2018\u2019]","g");
        return e.replace(t, "").replace(n, "'")
    }
      , ds = (e,t)=>({
        suggestions: e,
        ignore: t
    })
      , ms = e=>{
        const t = new Set;
        return B(e, (e=>t.add(e))),
        t
    }
      , ps = vt()
      , hs = (e,t)=>Gt(ps, e, t)
      , fs = e=>!e.inline && e.hasPlugin("autoresize")
      , ys = e=>!e.inline && !fs(e)
      , bs = (e,t)=>e + t.top
      , ws = e=>e.dom.getBoundingClientRect()
      , vs = e=>{
        const t = Y.fromDom(e.startContainer)
          , n = Y.fromDom(e.endContainer);
        return xs(t, e.startOffset, n, e.endOffset)
    }
      , xs = (e,t,n,r)=>({
        startContainer: e,
        startOffset: t,
        endContainer: n,
        endOffset: r,
        collapsed: Ce(e, n) && t === r
    })
      , ks = ve("img")
      , Ts = e=>e.filter((e=>!e.collapsed)).bind((e=>(e=>{
        const t = e.startContainer;
        if (!Ce(t, e.endContainer))
            return I.none();
        if (ks(t))
            return I.some(t);
        const n = Math.min(e.startOffset, e.endOffset)
          , r = Math.max(e.startOffset, e.endOffset)
          , o = We(t, n).filter(ks);
        return r === n || r === n + 1 ? o : I.none()
    }
    )(e).orThunk((()=>(e=>{
        const t = We(e.startContainer, e.startOffset).filter(ks);
        return (e=>qe(e.startContainer).filter(ve("img")))(e).or(t).bind((n=>(e=>Fe(e.endContainer).filter(ve("img")))(e).bind((r=>{
            const o = Ce(n, r)
              , s = Ue(e.startContainer) === e.startOffset
              , l = 0 === e.endOffset;
            return o && (s || t.isSome()) && l ? I.some(n) : I.none()
        }
        ))))
    }
    )(e)))))
      , Ss = (e,t,n)=>{
        const r = xt(t, n);
        return le(e.getVoidElements(), ge(t)) ? (o = Pe(t),
        a = t,
        s = Pe(a).bind((e=>{
            const t = Ve(e);
            return W(t, (e=>Ce(a, e)))
        }
        )),
        l = (e,t)=>xt(e, 0 === n ? t : t + 1),
        o.isSome() && s.isSome() ? I.some(l(o.getOrDie(), s.getOrDie())) : I.none()).getOr(r) : r;
        var o, s, l, a
    }
      , Os = e=>vs(e.selection.getRng())
      , Es = e=>e.slice(0).sort()
      , Cs = (e,t)=>{
        const n = F(t, (t=>!M(e, t)));
        n.length > 0 && (e=>{
            throw new Error("Unsupported keys for object: " + Es(e).join(", "))
        }
        )(n)
    }
      , _s = (e,t)=>((e,t)=>({
        ch: e,
        offset: t
    }))(e.charAt(t), t)
      , As = e=>y(e) && void 0 !== e.index && e.index >= 0 ? I.some(e.index) : I.none()
      , Ns = un().left()
      , Is = un().right()
      , Ds = Tt([{
        abort: []
    }, {
        kontinue: []
    }, {
        finish: ["info"]
    }])
      , Ls = Tt([{
        aborted: []
    }, {
        edge: ["element"]
    }, {
        success: ["info"]
    }])
      , Rs = (e,t)=>((e,t)=>M(["br", "img", "hr", "input"], e.property().name(t)))(e, t) || e.property().isBoundary(t)
      , js = (e,t,n,r,o,s,l)=>{
        const a = ()=>l.fold(Ls.aborted, Ls.edge)
          , i = r=>gn(e, t, n, s).fold(a, (t=>js(e, t.item, t.mode, I.none(), o, s, r)));
        if (Rs(e, t))
            return a();
        if (e.property().isText(t)) {
            const n = e.property().getText(t);
            return o(e, Ds, t, n, r).fold(a, (()=>i(I.some(t))), Ls.success)
        }
        return i(l)
    }
      , Ms = (e,t,n)=>{
        const r = t=>Rs(e, t);
        return ((e,t,n,r)=>{
            const o = Gt(e, t, n);
            return e.property().isText(t) ? I.none() : ((e,t,n,r)=>ln(e, t, n, tn, sn.left(), r))(e, o.element, e.property().isText, r).map((t=>xt(t, e.property().getText(t).length)))
        }
        )(e, t, n, r).orThunk((()=>((e,t,n,r)=>{
            const o = Gt(e, t, n);
            return e.property().isText(t) ? I.none() : an(e, o.element, e.property().isText, r).map((e=>xt(e, 0)))
        }
        )(e, t, n, r))).getOr(xt(t, n))
    }
      , zs = ((e,t)=>((e,t,n)=>{
        if (0 === t.length)
            throw new Error("You must specify at least one required field.");
        return ((e,t)=>{
            if (!d(t))
                throw new Error("The required fields must be an array. Was: " + t + ".");
            B(t, (t=>{
                if (!c(t))
                    throw new Error("The value " + t + " in the " + e + " fields was not a string.")
            }
            ))
        }
        )("required", t),
        (e=>{
            const t = Es(e);
            V(t, ((e,n)=>n < t.length - 1 && e === t[n + 1])).each((e=>{
                throw new Error("The field: " + e + " occurs more than once in the combined fields: [" + t.join(", ") + "].")
            }
            ))
        }
        )(t),
        r=>{
            const o = X(r);
            H(t, (e=>M(o, e))) || ((e,t)=>{
                throw new Error("All required keys (" + Es(e).join(", ") + ") were not specified. Specified keys were: " + Es(t).join(", ") + ".")
            }
            )(t, o),
            e(t, o);
            const s = F(t, (e=>!n.validate(r[e], e)));
            return s.length > 0 && ((e,t)=>{
                throw new Error("All values need to be of type: " + t + ". Keys (" + Es(e).join(", ") + ") were not.")
            }
            )(s, n.label),
            r
        }
    }
    )(e, t, {
        validate: b,
        label: "function"
    }))(Cs, ["regex", "attempt"])
      , Ps = (e,t,n,r)=>{
        const o = Ms(e, t, n);
        return js(e, o.element, tn, I.some(o.offset), r, Ns, I.none())
    }
      , Bs = (e,t,n,r)=>{
        const o = Ms(e, t, n);
        return js(e, o.element, tn, I.some(o.offset), r, Is, I.none())
    }
      , Fs = (e,t,n)=>{
        const r = A;
        if (!e.property().isText(t))
            return I.none();
        const o = e.property().getText(t);
        return n <= o.length ? I.some(xt(t, n)) : cn(e, t, e.property().isText, r).bind((t=>Fs(e, t, n - o.length)))
    }
      , qs = {
        previousChar: (e,t)=>{
            for (let n = t.getOr(e.length) - 1; n >= 0; n--)
                if ("\ufeff" !== e.charAt(n))
                    return I.some(_s(e, n));
            return I.none()
        }
        ,
        nextChar: (e,t)=>{
            for (let n = t.getOr(0) + 1; n < e.length; n++)
                if ("\ufeff" !== e.charAt(n))
                    return I.some(_s(e, n));
            return I.none()
        }
        ,
        repeatLeft: Ps,
        repeatRight: Bs,
        expandLeft: (e,t,n,r)=>{
            const o = zs(r);
            return Ps(e, t, n, ((e,t,n,r,s)=>{
                const l = s.getOr(r.length);
                return ((e,t)=>{
                    t.lastIndex = -1;
                    const n = J(e).join("");
                    return As(n.match(t)).map((e=>n.length - 1 - e))
                }
                )(r.substring(0, l), o.regex()).fold((()=>t.kontinue()), (e=>o.attempt(t, n, r, e)))
            }
            ))
        }
        ,
        expandRight: (e,t,n,r)=>{
            const o = zs(r);
            return Bs(e, t, n, ((e,t,n,r,s)=>{
                const l = s.getOr(0);
                var a, i;
                return (a = r.substring(l),
                (i = o.regex()).lastIndex = -1,
                As(a.match(i))).fold((()=>t.kontinue()), (e=>o.attempt(t, n, r, l + e)))
            }
            ))
        }
        ,
        scanRight: Fs
    }
      , Vs = vt()
      , Ws = (e,t)=>{
        const n = xt(e, t);
        return ye(e) ? ((e,t)=>qs.scanRight(Vs, e, t))(e, t).getOr(n) : n
    }
      , Us = e=>ye(e) || "br" === ge(e)
      , Hs = (e,t,n,r)=>{
        return Us(n.startContainer) && Us(n.endContainer) || (o = I.some(n),
        Ts(o).map((e=>({
            image: ()=>e
        })))).isSome() ? ((e,t,n,r)=>{
            const o = t();
            if (e.hasFocus()) {
                const t = (e=>{
                    const t = Ws(e.startContainer, e.startOffset)
                      , n = Ws(e.endContainer, e.endOffset);
                    return xs(t.element, t.offset, n.element, n.offset)
                }
                )(((e,t)=>{
                    const n = Ss(e, t.startContainer, t.startOffset)
                      , r = Ss(e, t.endContainer, t.endOffset);
                    return xs(n.element, n.offset, r.element, r.offset)
                }
                )(e.schema, n))
                  , o = Os(e);
                l = t,
                Ce((s = o).startContainer, l.startContainer) && Ce(s.endContainer, l.endContainer) && s.startOffset === l.startOffset && s.endOffset === l.endOffset || ((e,t,n)=>{
                    const r = e.dom.createRng();
                    r.setStart(t.startContainer.dom, t.startOffset),
                    r.setEnd(t.endContainer.dom, t.endOffset),
                    e.selection.setRng(r, n)
                }
                )(e, t, r)
            }
            var s, l;
            return o
        }
        )(e, t, n, r) : ((e,t)=>{
            if (e.hasFocus()) {
                const n = e.selection.getBookmark()
                  , r = t();
                return e.selection.moveToBookmark(n),
                r
            }
            return t()
        }
        )(e, t);
        var o
    }
      , Js = (e,t)=>{
        const n = Os(e)
          , r = e.selection.isForward()
          , o = (e=>{
            if ((e=>{
                const t = ((e,t)=>{
                    const n = Ve(e);
                    return n.length > 0 && t < n.length ? He(n[t], 0) : He(e, t)
                }
                )(e.startContainer, e.startOffset).element;
                return fe(t) && "false" === Te(t, "contenteditable") && Ce(e.startContainer, e.endContainer) && e.startOffset === e.endOffset - 1
            }
            )(e))
                return e;
            {
                const t = hs(e.endContainer, e.endOffset)
                  , n = hs(e.startContainer, e.startOffset);
                return xs(n.element, n.offset, t.element, t.offset)
            }
        }
        )(n);
        return Hs(e, t, o, r)
    }
      , $s = e=>{
        let t = [];
        return {
            bind: e=>{
                if (void 0 === e)
                    throw new Error("Event bind error: undefined handler");
                t.push(e)
            }
            ,
            unbind: e=>{
                t = F(t, (t=>t !== e))
            }
            ,
            trigger: (...n)=>{
                const r = {};
                B(e, ((e,t)=>{
                    r[e] = n[t]
                }
                )),
                B(t, (e=>{
                    e(r)
                }
                ))
            }
        }
    }
      , Ks = e=>{
        const t = Y.fromDom((e=>{
            if ($e() && y(e.target)) {
                const t = Y.fromDom(e.target);
                if (fe(t) && y(t.dom.shadowRoot) && e.composed && e.composedPath) {
                    const t = e.composedPath();
                    if (t)
                        return G(t)
                }
            }
            return I.from(e.target)
        }
        )(e).getOr(e.target))
          , n = ()=>e.stopPropagation()
          , r = ()=>e.preventDefault()
          , o = k(r, n);
        return ((e,t,n,r,o,s,l)=>({
            target: e,
            x: t,
            y: n,
            stop: r,
            prevent: o,
            kill: s,
            raw: l
        }))(t, e.clientX, e.clientY, n, r, o, e)
    }
      , Gs = (e,t,n,r)=>{
        e.dom.removeEventListener(t, n, r)
    }
      , Zs = N
      , Ys = (e,t,n)=>((e,t,n,r)=>((e,t,n,r,o)=>{
        const s = ((e,t)=>n=>{
            e(n) && t(Ks(n))
        }
        )(n, r);
        return e.dom.addEventListener(t, s, o),
        {
            unbind: E(Gs, e, t, s, o)
        }
    }
    )(e, t, n, r, !1))(e, t, Zs, n)
      , Xs = e=>{
        const t = (()=>{
            let e = !1;
            return {
                lock: ()=>e ? I.none() : (e = !0,
                I.some(void 0)),
                unlock: ()=>{
                    if (!e)
                        throw new Error("Double unlock");
                    e = !1
                }
                ,
                runIfUnlocked: t=>{
                    e || t()
                }
            }
        }
        )()
          , n = (r = {
            lookup: $s(["element"]),
            scroll: $s([]),
            change: $s([])
        },
        {
            registry: te(r, (e=>({
                bind: e.bind,
                unbind: e.unbind
            }))),
            trigger: te(r, (e=>e.trigger))
        });
        var r;
        const o = ((e,t)=>{
            let n = null;
            const r = ()=>{
                m(n) || (clearTimeout(n),
                n = null)
            }
            ;
            return {
                cancel: r,
                throttle: (...t)=>{
                    r(),
                    n = setTimeout((()=>{
                        n = null,
                        e.apply(null, t)
                    }
                    ), 1e3)
                }
            }
        }
        )((()=>{
            t.runIfUnlocked((()=>n.trigger.scroll()))
        }
        ))
          , s = ((e,r)=>{
            let o = !1
              , s = !1;
            const l = ()=>{
                o = !0,
                t.runIfUnlocked((()=>n.trigger.change())),
                setTimeout((()=>{
                    o = !1,
                    s && (s = !1,
                    l())
                }
                ), 1e3)
            }
            ;
            return ()=>{
                o ? s = !0 : l()
            }
        }
        )();
        return e.on("keyup", (r=>{
            (e=>32 === (e.which || e.keyCode))(r) && (()=>{
                const r = vs(e.selection.getRng());
                t.runIfUnlocked((()=>n.trigger.lookup(r.startContainer)))
            }
            )()
        }
        )),
        e.on("init", (()=>{
            let r = Y.fromDom(e.getBody());
            const l = ys(e) ? e.getDoc() : document
              , a = e.inline ? "ResizeWindow" : "ResizeEditor"
              , i = Y.fromDom(l)
              , c = Ys(i, "scroll", o.throttle);
            o.throttle(),
            e.on(a, o.throttle),
            e.on("NodeChange", (e=>{
                if (e.selectionChange)
                    return;
                const o = Y.fromDom(e.element);
                Ce(r, o) || (t.runIfUnlocked((()=>n.trigger.lookup(r))),
                r = o)
            }
            )),
            e.on("SetContent change", s),
            e.on("remove", (()=>{
                c.unbind()
            }
            ))
        }
        )),
        {
            events: n.registry,
            transact: e=>{
                t.lock().fold((()=>console.warn("TinyMCE spellchecker state error")), (()=>e.get((()=>{
                    s(),
                    t.unlock()
                }
                ))))
            }
        }
    }
      , Qs = Zr()
      , el = e=>((e,t)=>Jt(e) && e.dom.classList.contains(t))(e, Qs)
      , tl = e=>{
        let t = e;
        return {
            get: ()=>t,
            set: e=>{
                t = e
            }
        }
    }
      , nl = (e,t,n)=>{
        const r = X(n);
        B(r, (r=>{
            const o = n[r];
            p(o) ? o || e.add(t, r, I.none()) : e.add(t, r, I.some(o))
        }
        ))
    }
      , rl = e=>e.fold(A, (e=>!e.ignore))
      , ol = (e,t,n)=>{
        const r = {
            ignore: A,
            lang: T(n)
        }
          , o = P(t, (e=>e.word))
          , s = F(o, ((e,t)=>((e,t)=>{
            const n = j(e, t);
            return -1 === n ? I.none() : I.some(n)
        }
        )(o, e).filter((e=>e === t)).isSome()));
        Jr(r, e, s, A)
    }
      , sl = (e,t,n)=>F(e, (e=>!t.isWordIgnored(n, e)))
      , ll = (e,t,n,r)=>{
        const o = t=>{
            const n = t.zone;
            nl(e, n.lang, t.spelling);
            const r = X(t.spelling)
              , o = ((e,t,n)=>F(n, (n=>{
                const r = e.get(t, n);
                return rl(r)
            }
            )))(e, n.lang, r);
            return {
                zone: n,
                words: F(n.words, (e=>{
                    const t = gs(e.word);
                    return M(o, t)
                }
                ))
            }
        }
        ;
        return P(n, (e=>((e,t,n)=>{
            const r = P(e.words, (e=>gs(e.word)));
            return t(sl(r, n, e.lang), e.lang).map((t=>t.map((t=>({
                spelling: t,
                zone: e
            })))))
        }
        )(e, t, r).map((e=>e.map(o)))))
    }
      , al = (e,t,n,r)=>{
        const o = t=>{
            nl(e, t.lang, t.spelling)
        }
          , s = ((e,t)=>{
            if (0 === e.length)
                return [];
            {
                let n = t(e[0]);
                const r = [];
                let o = [];
                for (let s = 0, l = e.length; s < l; s++) {
                    const l = e[s]
                      , a = t(l);
                    a !== n && (r.push(o),
                    o = []),
                    n = a,
                    o.push(l)
                }
                return 0 !== o.length && r.push(o),
                r
            }
        }
        )(((e,t)=>{
            const n = D.call(e, 0);
            return n.sort(((e,t)=>e.detail.lang < t.detail.lang ? -1 : t.detail.lang < e.detail.lang ? 1 : 0)),
            n
        }
        )(n), (e=>e.detail.lang))
          , l = P(s, (e=>{
            const n = P(e, (e=>e.detail.word));
            return ((e,t,n,r)=>{
                const o = sl(e, r, t);
                return n.suggestions(o, t).map((e=>e.map((e=>({
                    spelling: e,
                    lang: t
                })))))
            }
            )(n, e[0].detail.lang, t, r)
        }
        ));
        return Uo(l).map((e=>(B(e, (e=>{
            e.each(o)
        }
        )),
        Ne(e))))
    }
      , il = (e,t,n)=>{
        const r = (e,t,n)=>{
            e((()=>{
                B(t, (e=>{
                    ol(e.zone, e.words, n)
                }
                ))
            }
            ))
        }
          , o = (e,n,r,o)=>{
            if (0 === e.length)
                return void n(!0, x);
            const s = tl(!1)
              , l = ()=>{
                t.cancelCurrent(),
                s.set(!0)
            }
            ;
            let a = 0;
            const i = new Map;
            B(e, ((t,c)=>{
                t.get((t=>{
                    if (i.set(c, t),
                    n(!1, l),
                    r)
                        for (; i.has(a); )
                            s.get() || o(i.get(a)),
                            a += 1;
                    else
                        s.get() || o(t);
                    s.get() || n(e.length === i.size, l)
                }
                ))
            }
            )),
            n(!1, l)
        }
        ;
        return {
            local: (t,n,o,s)=>{
                const l = (t=>P(t, (t=>{
                    const n = ((e,t,n)=>F(n, (n=>{
                        const r = e.get(t, n.word);
                        return rl(r)
                    }
                    )))(e, t.lang, t.words);
                    return {
                        zone: t,
                        words: n
                    }
                }
                )))(n.zones);
                r(t, l, o),
                s(!0, x)
            }
            ,
            remote: (s,l,a,i,c)=>{
                const u = l.zones
                  , g = ll(e, t.suggestions, u, n);
                o(g, i, c, (e=>e.fold(x, (e=>r(s, [e], a)))))
            }
            ,
            check: (s,l,a,i,c)=>{
                const u = l.zones
                  , g = ll(e, t.check, u, n);
                o(g, i, c, (e=>e.fold(x, (e=>r(s, [e], a)))))
            }
            ,
            fetch: r=>al(e, t, r, n)
        }
    }
      , cl = (e,t)=>{
        const n = tl(e)
          , r = (()=>{
            let e = []
              , t = !1;
            const n = ()=>{
                t = !0,
                I.from(e.shift()).fold((()=>{
                    t = !1
                }
                ), (e=>{
                    e.f(e.area, n)
                }
                ))
            }
            ;
            return {
                enqueue: (r,o)=>{
                    e.push(((e,t)=>({
                        area: e,
                        f: t
                    }))(r, o)),
                    t || n()
                }
                ,
                destroy: ()=>{
                    e = []
                }
            }
        }
        )()
          , o = (e,r,o,s,l,a)=>{
            const i = a ? {
                assess: e=>Vn.inView(e)
            } : t()
              , c = ((e,t,r)=>{
                switch (e.tag) {
                case 0:
                    return o = e.element,
                    Ze(o) ? ((e,t,n)=>Gn(or, e, t, n))(o, n.get(), i) : sr();
                case 1:
                    return ((e,t,r,o)=>Ze(e) && Ze(r) ? ((e,t,n,r,o,s)=>((e,t,n,r,o,s,l)=>{
                        const a = Gt(e, t, n)
                          , i = Gt(e, r, o);
                        return e.eq(a.element, i.element) ? Gn(e, a.element, s, l) : ((e,t,n,r,o)=>{
                            const s = Mn(e, t, n, A)
                              , l = $n(s.left, s.right);
                            return Jn(e, s.left.item, s.right.item, r, l, o)
                        }
                        )(e, a.element, i.element, s, l)
                    }
                    )(or, e, t, n, r, o, s))(e, t, r, o, n.get(), i) : sr())(e.start, e.sOffset, e.finish, e.fOffset)
                }
                var o
            }
            )(o);
            r(e, c, n.get(), s, l)
        }
        ;
        return {
            run: (e,t,n,r,s,l)=>{
                o(e, t, n, r, s, l)
            }
            ,
            setLang: n.set,
            schedule: (e,t,n,s,l)=>{
                r.enqueue(n, ((n,r)=>{
                    l() ? r() : o(e, t, n, ((e,t)=>{
                        l() ? (t(),
                        r()) : e && r()
                    }
                    ), s, !1)
                }
                ))
            }
            ,
            destroy: ()=>{
                r.destroy()
            }
        }
    }
      , ul = e=>{
        let t = I.none()
          , n = [];
        const r = e=>{
            o() ? s(e) : n.push(e)
        }
          , o = ()=>t.isSome()
          , s = e=>{
            t.each((t=>{
                e(t)
            }
            ))
        }
        ;
        return e((e=>{
            var r;
            o() || (t = I.some(e),
            r = n,
            setTimeout((()=>B(r, s)), 0),
            n = [])
        }
        )),
        {
            get: r,
            getSync: ()=>t.fold((()=>mo.error(io(r))), mo.value),
            map: e=>ul((t=>{
                r((n=>{
                    t(e(n))
                }
                ))
            }
            )),
            isReady: o
        }
    }
      , gl = {
        nu: ul,
        pure: e=>ul((t=>{
            t(e)
        }
        ))
    }
      , dl = e=>e.dispatch("SpellcheckStart")
      , ml = e=>e.dispatch("SpellcheckEnd")
      , pl = (e,t,n)=>{
        const r = ns(t, (e=>{
            const t = (e=>{
                var t;
                return null !== (t = e.options.get("spellchecker_api_key")) && void 0 !== t ? t : e.options.get("api_key")
            }
            )(e);
            return f(t) ? {} : {
                "tiny-api-key": t
            }
        }
        )(e), void 0, n)
          , o = {}
          , s = t=>{
            const n = (e=>{
                const t = F(e, u)
                  , n = P(t, (e=>{
                    var t;
                    return null === (t = e.error) || void 0 === t ? void 0 : t.message
                }
                ))
                  , r = F(n, c)
                  , o = eo(r);
                if (o.sort(),
                o.length > 0) {
                    const e = (e=>z(e, (e=>0 === e.status)))(t) ? "Unable to communicate with the spelling service" : "Error response from the spelling service";
                    return e + " - " + o.join(", ")
                }
                return "An unexpected error occurred with the spelling service"
            }
            )(t);
            return console.error(n),
            ((e,t)=>{
                e.dispatch("SpellcheckError", t)
            }
            )(e, {
                message: n
            }),
            t
        }
          , l = (e,t)=>e ? t().map((e=>e.mapError(s).toOptional())) : co(I.none())
          , a = (e,t)=>se(o, e).getOrThunk((()=>{
            const t = (e=>gl.nu((t=>{
                r.check(e, ["startup"]).get((e=>{
                    t(e.isValue()),
                    e.mapError(s)
                }
                ))
            }
            )))(e);
            return o[e] = t,
            t
        }
        )).getSync().fold((e=>e.bind((e=>l(e, t)))), (e=>l(e, t)));
        return {
            check: (e,t)=>a(t, (()=>r.check(t, e))),
            suggestions: (e,t)=>a(t, (()=>r.suggestions(t, e))),
            state: ()=>r.dumpCache(),
            cancelCurrent: r.cancelCurrent
        }
    }
      , hl = (e,t,n,r,o,s,l)=>{
        const a = (e=>{
            const t = ()=>ys(e) ? e.getWin() : window
              , n = ()=>{
                if (fs(e)) {
                    const t = (e.inline ? e.getBody() : e.getContentAreaContainer()).getBoundingClientRect();
                    return e=>{
                        const n = ws(e);
                        return {
                            ...n,
                            top: bs(n.top, t),
                            bottom: bs(n.bottom, t)
                        }
                    }
                }
                return ws
            }
            ;
            return {
                sections: ()=>(()=>{
                    const r = e.getBody();
                    if (!r)
                        return [];
                    const o = t()
                      , s = n()
                      , l = o.innerHeight
                      , a = Y.fromDom(r)
                      , i = Ve(a);
                    return W(i, (e=>{
                        if (!fe(e))
                            return !1;
                        const t = s(e);
                        return t.top < l && t.bottom > 0
                    }
                    )).map((e=>{
                        const t = W(i.slice(e + 1), (e=>{
                            if (!fe(e))
                                return !1;
                            const t = s(e);
                            return !(t.top < l && t.bottom > 0)
                        }
                        )).map((t=>e + 1 + t)).getOr(i.length);
                        return i.slice(e, t)
                    }
                    )).getOr([a])
                }
                )(),
                viewport: ()=>{
                    const e = t()
                      , r = e ? e.innerHeight : 0
                      , o = n();
                    return {
                        assess: e=>{
                            return fe(e) ? (t = o(e),
                            n = r,
                            t.bottom < 0 ? Vn.aboveView : t.top > n ? Vn.belowView : Vn.inView)(e) : Vn.inView(e);
                            var t, n
                        }
                    }
                }
            }
        }
        )(e)
          , i = t=>Js(e, t)
          , c = (e=>{
            const t = e.gaol
              , n = e.editor
              , r = e.language
              , o = I.from(is(n)).getOrThunk((()=>pl(n, e.url, e.serverSettings)))
              , s = cl(r, e.viewable.viewport)
              , l = il(e.cache, o, e.ignoreList)
              , a = ()=>n.removed || !Xr(t.spelling().get())
              , i = ()=>{
                (e=>{
                    const t = n.dom.select("span.mce-spellchecker-word");
                    B(t, (e=>{
                        (e=>{
                            const t = e.parentNode
                              , n = e.childNodes;
                            if (t) {
                                for (; n.length > 0; )
                                    t.insertBefore(n[0], e);
                                t.removeChild(e)
                            }
                        }
                        )(e)
                    }
                    ))
                }
                )()
            }
            ;
            return e.editor.on("remove", (()=>{
                s.destroy()
            }
            )),
            {
                run: (e,n)=>{
                    const r = t.spelling().get();
                    Xr(r) && (s.setLang(r),
                    s.run(e, l.local, n, x, !1, !1),
                    s.schedule(e, l.remote, n, !1, a))
                }
                ,
                fetch: l.fetch,
                check: (e,n,r,o,a)=>{
                    s.setLang(t.nonOffSpelling()),
                    s.run(e, l.check, n, r, o, a)
                }
                ,
                refresh: ()=>{
                    const n = t.spelling().get();
                    Xr(n) && e.asYouType || i()
                }
                ,
                clear: i,
                state: o.state
            }
        }
        )({
            editor: e,
            gaol: r,
            viewable: a,
            cache: n,
            url: t,
            language: r.spelling().get(),
            asYouType: o,
            serverSettings: s,
            ignoreList: l
        });
        e.on("init", (()=>{
            const t = e.getBody()
              , n = Y.fromDom(t);
            ke(n, "spellcheck", !1),
            c.refresh()
        }
        )),
        e.on("remove", (()=>{
            const t = e.getBody()
              , r = Y.fromDom(t);
            Oe(r, "spellcheck"),
            n.destroy()
        }
        ));
        const u = (e,t,n,r)=>{
            const o = el(e) ? hs(e, t) : xt(e, t)
              , s = el(n) ? hs(n, r) : xt(n, r);
            return ((e,t,n,r)=>{
                const o = ((e,t,n,r)=>{
                    const o = ((e,t,n,r)=>{
                        const o = Me(e).dom.createRange();
                        return o.setStart(e.dom, t),
                        o.setEnd(n.dom, r),
                        o
                    }
                    )(e, t, n, r)
                      , s = Ce(e, n) && t === r;
                    return o.collapsed && !s
                }
                )(n, r, e, t)
                  , s = o ? xt(e, t) : xt(n, r)
                  , l = o ? xt(n, r) : xt(e, t);
                return {
                    tag: 1,
                    start: s.element,
                    sOffset: s.offset,
                    finish: l.element,
                    fOffset: l.offset
                }
            }
            )(o.element, o.offset, s.element, s.offset)
        }
          , g = e=>{
            const t = e[0]
              , n = e[e.length - 1]
              , r = Ue(n);
            return u(t, 0, n, r)
        }
          , d = ()=>{
            const e = a.sections();
            if (e.length > 0) {
                const t = g(e);
                c.run(i, t)
            }
        }
          , m = c.clear
          , p = c.fetch
          , h = o ? I.some(Xs(e)) : I.none();
        h.each((e=>{
            e.events.lookup.bind((e=>{
                const t = {
                    tag: 0,
                    element: e.element
                };
                c.run(i, t)
            }
            )),
            e.events.scroll.bind(d),
            e.events.change.bind(d)
        }
        ));
        const f = h.fold((()=>e=>e.get(x)), (e=>e.transact));
        return {
            scanView: d,
            scanRange: (e,t,n,r)=>{
                const o = u(e, t, n, r);
                c.run(i, o)
            }
            ,
            checkDocument: (t,n)=>{
                const r = Y.fromDom(e.getBody())
                  , o = Ve(r);
                if (o.length > 0) {
                    const e = g(o);
                    c.check(i, e, t, n, !0)
                }
            }
            ,
            fetch: p,
            clear: m,
            transact: f
        }
    }
      , fl = (()=>{
        try {
            const e = ae.localStorage
              , t = "__storage_test__";
            return e.setItem(t, t),
            e.removeItem(t),
            I.some(e)
        } catch (e) {
            return I.none()
        }
    }
    )().fold((()=>{
        const e = {};
        return {
            getItem: t=>e[t],
            setItem: (t,n)=>{
                e[t] = n
            }
        }
    }
    ), (e=>({
        getItem: t=>e.getItem("mce." + t),
        setItem: (t,n)=>{
            e.setItem("mce." + t, n)
        }
    })))
      , yl = e=>{
        const t = ((e,t)=>{
            const n = (e=>I.from(fl.getItem(e)))(e).map(JSON.parse);
            return n.getOr(t)
        }
        )("spelling", e)
          , n = Xn(t)
          , r = tl(n)
          , o = tl("no.language" === n ? "en_us" : n)
          , s = r.set
          , l = r.get
          , a = {
            setAndCache: (e,t)=>{
                ((e,t)=>{
                    e.options.set("spellchecker_language", t)
                }
                )(e, t),
                s(t),
                ((e,t)=>{
                    const n = JSON.stringify(t);
                    fl.setItem("spelling", n)
                }
                )(0, t),
                Xr(t) && o.set(t)
            }
            ,
            set: s,
            get: l
        };
        return {
            spelling: T(a),
            nonOffSpelling: o.get,
            setNonOffSpelling: o.set
        }
    }
      , bl = (e,t,n)=>{
        e.undoManager.transact((()=>{
            const r = ((e,t)=>((e,t)=>{
                const n = mr(e)
                  , r = dr(e);
                return I.from(e[0]).bind((o=>{
                    var s;
                    s = o,
                    B(n, (e=>{
                        nt(s, e)
                    }
                    ));
                    const l = I.from(r[0]);
                    return l.each((e=>{
                        bt(e, t)
                    }
                    )),
                    B(r.slice(1), (e=>{
                        bt(e, "")
                    }
                    )),
                    B(e, gt),
                    l
                }
                ))
            }
            )($r(e).fold(T([]), Tr), t))(t, n);
            r.each((t=>{
                const n = (e=>"img" === ge(e) ? 1 : (e=>ft.getOption(e))(e).fold((()=>Ve(e).length), (e=>e.length)))(t);
                e.selection.setCursorLocation(t.dom, n),
                e.focus()
            }
            ))
        }
        ))
    }
      , wl = (e,t)=>$r(e).bind(Gr).map((e=>({
        detail: e,
        suggestions: t.suggestions(e.lang, e.word)
    })))
      , vl = (e,t,n)=>{
        e.undoManager.transact((()=>{
            (e=>{
                const t = $r(e).fold(T([]), Tr);
                B(t, (e=>{
                    Kt(e, Rr.wordLabel()),
                    $t(e, Rr.ignoreLabel())
                }
                ))
            }
            )(t)
        }
        )),
        ((e,t)=>{
            e.dispatch("SpellcheckerIgnore", {
                word: t
            })
        }
        )(e, n)
    }
      , xl = (e,t,n,r,o)=>{
        o.ignore(r, n),
        (e=>{
            const t = $r(e).fold(T([]), Sr);
            B(t, dt)
        }
        )(t),
        ((e,t,n)=>{
            e.dispatch("SpellcheckerIgnoreAll", {
                word: t,
                language: n
            })
        }
        )(e, n, r)
    }
      , kl = e=>{
        const t = Kr(e);
        return G(t).bind(Gr)
    }
      , Tl = e=>Kr(e)
      , Sl = e=>Ne(P(e, Gr))
      , Ol = "SpellcheckStart SpellcheckEnd"
      , El = ()=>{
        const e = (e=>{
            const t = tl(I.none())
              , n = ()=>t.get().each(e);
            return {
                clear: ()=>{
                    n(),
                    t.set(I.none())
                }
                ,
                isSet: ()=>t.get().isSome(),
                get: ()=>t.get(),
                set: e=>{
                    n(),
                    t.set(I.some(e))
                }
            }
        }
        )(x);
        return {
            ...e,
            on: t=>e.get().each(t)
        }
    }
      , Cl = [{
        text: "No suggestions found",
        value: "No suggestions found"
    }]
      , _l = (e,t)=>{
        t.setEnabled("next", e.hasNext()),
        t.setEnabled("previous", e.hasPrevious())
    }
      , Al = (e,t,n,r)=>({
        title: "Spellcheck",
        body: {
            type: "panel",
            items: [{
                type: "label",
                label: "Misspelled word",
                items: [{
                    type: "bar",
                    items: [{
                        type: "input",
                        name: "textlabel",
                        maximized: !0
                    }, {
                        type: "bar",
                        items: [{
                            type: "button",
                            name: "previous",
                            text: "Previous",
                            icon: "action-prev",
                            borderless: !0,
                            enabled: e.hasPrevious()
                        }, {
                            type: "button",
                            name: "next",
                            text: "Next",
                            icon: "action-next",
                            borderless: !0,
                            enabled: e.hasNext()
                        }]
                    }]
                }]
            }, {
                type: "selectbox",
                name: "suggestions",
                label: "Suggestions",
                size: 6,
                enabled: t.length > 0,
                items: t.length > 0 ? t : Cl
            }]
        },
        initialData: {
            textlabel: n,
            suggestions: r.length > 0 ? r[0] : ""
        },
        onClose: e.onClose,
        onChange: (e,t)=>{
            "textlabel" === t.name && e.setEnabled("accept", e.getData().textlabel !== n)
        }
        ,
        onAction: (t,r)=>{
            switch (r.name) {
            case "accept":
                e.replace(t, n);
                break;
            case "ignore":
                e.ignore(t);
                break;
            case "ignoreall":
                e.ignoreAll(t);
                break;
            case "next":
                e.next(t);
                break;
            case "previous":
                e.previous(t)
            }
            _l(e, t),
            t.focus("textlabel")
        }
        ,
        buttons: [{
            type: "custom",
            primary: !0,
            name: "accept",
            text: "Accept",
            enabled: t.length > 0
        }, {
            type: "custom",
            name: "ignore",
            text: "Ignore"
        }, {
            type: "custom",
            name: "ignoreall",
            text: "Ignore all"
        }]
    })
      , Nl = (e,t,n)=>{
        const r = P(t, (e=>({
            text: e,
            value: e
        })));
        return Al(e, r, n.word, t)
    }
      , Il = (e,t,n,r,o)=>{
        const s = {
            inline: "toolbar"
        }
          , l = (()=>{
            const e = {
                words: [],
                index: -1,
                current: I.none()
            }
              , t = (t,r)=>{
                ((e,t)=>W(e, (e=>e.id === t)))(t, r).fold(n, (n=>((t,n)=>{
                    e.words = t,
                    e.index = n,
                    e.current = K(t, n)
                }
                )(t, n)))
            }
              , n = ()=>{
                e.words = [],
                e.index = -1,
                e.current = I.none()
            }
            ;
            return {
                getNextWord: (t,n)=>{
                    const r = e.words;
                    if (r.length <= 1)
                        return I.none();
                    {
                        const o = e.index
                          , s = r[o]
                          , l = J(r.slice(0, o))
                          , a = r.slice(o + 1)
                          , i = 0 === t ? a.concat(l) : l.concat(a);
                        return n ? V(i, (e=>e.word !== s.word || e.lang !== s.lang)) : G(i)
                    }
                }
                ,
                hasNext: ()=>e.words.length > 1 && e.index < e.words.length - 1,
                hasPrevious: ()=>e.words.length > 1 && e.index > 0,
                getCurrent: ()=>e.current,
                setCurrent: t,
                refreshCurrent: n=>{
                    e.current.each((e=>t(n, e.id)))
                }
                ,
                clear: n
            }
        }
        )()
          , a = e=>wl(e.element, t)
          , i = ()=>l.getCurrent().bind(a)
          , c = tl(!0)
          , u = El()
          , g = El()
          , d = {
            replace: (t,n)=>{
                const r = t.getData()
                  , o = r.textlabel !== n ? r.textlabel : r.suggestions;
                f(t, (t=>bl(e, t.detail.element, o)), 0)
            }
            ,
            ignore: t=>{
                f(t, (t=>vl(e, t.detail.element, t.detail.word)), 0)
            }
            ,
            ignoreAll: n=>{
                f(n, (n=>xl(e, n.detail.element, n.detail.word, n.detail.lang, t)), 0, !0)
            }
            ,
            onClose: ()=>{
                u.on(_),
                u.clear(),
                g.clear(),
                c.set(!0),
                ((e,t,n)=>{
                    t.clear(),
                    n && !e.removed && t.scanView()
                }
                )(e, n, r),
                l.clear()
            }
            ,
            next: e=>{
                f(e, x, 0)
            }
            ,
            previous: e=>{
                f(e, x, 1)
            }
            ,
            hasNext: l.hasNext,
            hasPrevious: l.hasPrevious
        }
          , m = (e,t)=>{
            e.redial(t),
            e.focus("textlabel")
        }
          , p = tl(x)
          , h = tl(!1)
          , f = (t,n,r,s=!1)=>{
            const a = ((t,n)=>l.getCurrent().fold((()=>kl(e)), (()=>l.getNextWord(t, n))).map((e=>e.id)))(r, s);
            i().each(n),
            (t=>{
                const n = Tl(e)
                  , r = Sl(n);
                return t.bind((e=>(l.setCurrent(r, e),
                i())))
            }
            )(a).fold((()=>{
                h.get() ? (t.block("Finding word suggestions"),
                p.set((()=>{
                    t.unblock(),
                    f(t, n, 0, s)
                }
                ))) : ((()=>{
                    const t = e.translate("No misspellings found.");
                    e.notificationManager.open({
                        text: t,
                        type: "info",
                        timeout: 3e3
                    })
                }
                )(),
                t.close())
            }
            ), (n=>{
                ((t,n)=>{
                    c.get() || (e.selection.scrollIntoView(t.detail.element.dom),
                    t.suggestions.fold((()=>{
                        ((e,t)=>{
                            t.block("Finding word suggestions"),
                            e.get((e=>{
                                t.unblock(),
                                e.fold((()=>{
                                    console.log("TinyMCE spellchecker fetch error")
                                }
                                ), (e=>{
                                    m(t, e)
                                }
                                ))
                            }
                            ))
                        }
                        )(io((e=>{
                            o.getWordsSuggestionsAsync([t], (()=>e(I.none())), (t=>e(I.some(t))), 0)
                        }
                        )).map((e=>e.map((e=>Nl(d, e, t.detail))))), n)
                    }
                    ), (e=>{
                        const r = Nl(d, e, t.detail);
                        m(n, r)
                    }
                    )))
                }
                )(n, t)
            }
            ))
        }
          , y = ()=>io((t=>{
            n.clear(),
            c.set(!1),
            h.set(!0);
            const r = Al(d, [], "", [])
              , o = e.windowManager.open(r, s);
            g.set(o),
            f(o, x, 0),
            t()
        }
        )).bind((()=>io((e=>setTimeout(e))))).bind((()=>io((n=>{
            o.getWordsAsyncWithProgress(((r,s)=>{
                h.set(!r),
                u.set((()=>{
                    r || s(),
                    n()
                }
                ));
                const a = Tl(e)
                  , i = Sl(a);
                l.refreshCurrent(i),
                g.on((e=>_l(d, e)));
                const c = ((e,t,n=100)=>{
                    const r = e.length > n ? n : e.length
                      , o = e.slice(0, r)
                      , s = P(o, (e=>wl(e, t)));
                    return (e=>{
                        const t = {};
                        return B(e, (e=>{
                            t[(e=>e.detail.word + "(" + e.detail.lang + ")")(e)] = e
                        }
                        )),
                        oe(t)
                    }
                    )(Ne(s))
                }
                )(a, t)
                  , m = F(c, (e=>e.suggestions.isNone()));
                m.length > 0 && o.getWordsSuggestionsAsync(m, x, x, 0);
                const f = kl(e);
                (r || f.isSome()) && (p.get()(),
                p.set(x))
            }
            ), !0)
        }
        ))))
          , b = {
            open: ()=>{
                g.isSet() || n.transact(y())
            }
            ,
            close: ()=>g.on((e=>{
                l.clear(),
                e.close()
            }
            ))
        };
        return b
    }
    ;
    tinymce.PluginManager.requireLangPack("tinymcespellchecker", "ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW"),
    tinymce.PluginManager.add("tinymcespellchecker", ((e,n)=>{
        if (((e,n)=>!!e && -1 === ((e,n)=>{
            const r = t(e.major, n.major);
            if (0 !== r)
                return r;
            const o = t(e.minor, n.minor);
            if (0 !== o)
                return o;
            const s = t(e.patch, n.patch);
            return 0 !== s ? s : 0
        }
        )((e=>r((e=>[e.majorVersion, e.minorVersion].join(".").split(".").slice(0, 3).join("."))(e)))(e), r(n)))(tinymce, "6.0.0"))
            return console.error('The "tinymcespellchecker" plugin requires at least version 6.0.0 of TinyMCE.'),
            {};
        (e=>{
            const t = e.options.register;
            t("spellchecker_dialog", {
                processor: "boolean",
                default: !1
            }),
            t("spellchecker_language", {
                processor: "string",
                default: "en_us"
            }),
            t("spellchecker_languages", {
                processor: e=>c(e) ? {
                    value: e.split(","),
                    valid: !0
                } : v(e, c) ? {
                    value: e,
                    valid: !0
                } : {
                    valid: !1,
                    message: "Must be a string or string array."
                },
                default: ["en_us", "en_gb", "da", "nl", "fi", "fr", "de", "it", "nb", "pt", "pt_pt", "es", "sv"]
            }),
            t("spellchecker_ignore_list", {
                processor: e=>u(e) || v(e, c),
                default: []
            }),
            t("spellchecker_handler", {
                processor: "object"
            }),
            t("spellchecker_api_key", {
                processor: "string"
            }),
            t("spellchecker_rpc_url", {
                processor: "string",
                default: ""
            }),
            t("spellchecker_active", {
                processor: "boolean",
                default: !0
            }),
            t("spellchecker_service_chunk_size", {
                processor: "number",
                default: ts.chunkSize
            }),
            t("spellchecker_service_max_retries", {
                processor: "number",
                default: ts.maxRetries
            }),
            t("spellchecker_service_max_in_flight", {
                processor: "number",
                default: ts.maxInFlight
            })
        }
        )(e);
        const o = ls(e)
          , s = cs(e)
          , l = ((e={})=>{
            let t = {};
            const n = e=>se(t, e).getOr({})
              , r = (e,r)=>{
                const o = n(e);
                r(o),
                t[e] = o
            }
              , o = (e,t)=>t(n(e))
              , s = (e,t,n)=>{
                r(e, (e=>{
                    const r = gs(t);
                    se(e, r).forall((e=>e.suggestions.isNone())) && (e[r] = ds(n, !1))
                }
                ))
            }
              , l = (e,t)=>{
                r(e, (e=>{
                    const n = gs(t)
                      , r = se(e, n).bind((e=>e.suggestions))
                      , o = ds(r, !0);
                    e[n] = o
                }
                ))
            }
            ;
            return ee(e, ((e,t)=>{
                ee(e, ((e,n)=>{
                    !0 === e.ignore && l(t, n),
                    void 0 !== e.suggestions && s(t, n, I.some(e.suggestions))
                }
                ))
            }
            )),
            {
                add: s,
                get: (e,t)=>o(e, (e=>{
                    const n = gs(t);
                    return se(e, n)
                }
                )),
                ignore: l,
                ignoreAll: e=>{
                    ee(t, ((t,n)=>{
                        l(n, e)
                    }
                    ))
                }
                ,
                suggestions: (e,t)=>o(e, (e=>{
                    const n = gs(t);
                    return se(e, n).bind((e=>e.ignore ? I.none() : e.suggestions))
                }
                )),
                state: ()=>te(t, ((e,t)=>te(e, (e=>({
                    ignore: e.ignore,
                    suggestions: e.suggestions.getOr([])
                }))))),
                destroy: ()=>{
                    t = {}
                }
            }
        }
        )(i)
          , a = yl(o);
        var i;
        us(e) || "no.language" === a.spelling().get() || a.spelling().set("no.language");
        const g = (e=>{
            const t = !ss(e)
              , n = e.options.get("spellchecker_languages")
              , r = re(((e,t=!0)=>q(e, ((e,n)=>{
                const [r,o] = De(n, "=") ? n.split("=") : [null, n];
                return e[t ? Xn(o) : o] = I.from(r).getOrThunk((()=>Qn(o))),
                e
            }
            ), {}))(n), ((e,t)=>({
                text: e,
                value: t
            })));
            return t ? rs.concat(r) : r
        }
        )(e)
          , m = !ss(e)
          , p = (e=>({
            chunkSize: e.options.get("spellchecker_service_chunk_size"),
            maxRetries: e.options.get("spellchecker_service_max_retries"),
            maxInFlight: e.options.get("spellchecker_service_max_in_flight")
        }))(e)
          , h = (e=>{
            const t = new Set
              , n = {};
            return d(e) ? B(e, (e=>t.add(e))) : ee(e, ((e,t)=>{
                const r = Xn(t);
                n[r] = ms(e)
            }
            )),
            {
                isWordIgnored: (e,r)=>!!t.has(r) || se(n, e).fold(A, (e=>e.has(r))),
                addToLang: (e,t)=>{
                    se(n, e).fold((()=>n[e] = ms([t])), (e=>e.add(t)))
                }
                ,
                addToGlobal: e=>{
                    t.add(e)
                }
            }
        }
        )(as(e))
          , f = hl(e, s, l, a, m, p, h)
          , b = ((e,t,n,r,o)=>{
            const s = t=>{
                const r = Xr(t);
                (r ? n.scanView : n.clear)(),
                (r ? dl : ml)(e)
            }
              , l = (e,t)=>{
                n.checkDocument(e, t)
            }
              , a = (e,t,o,s)=>{
                const l = ()=>{
                    s < 3 ? a(e, t, o, s + 1) : t()
                }
                ;
                n.fetch(e).get((t=>{
                    t.length > 0 ? wl(e[0].detail.element, r).bind((e=>e.suggestions)).fold(l, o) : l()
                }
                ))
            }
            ;
            return {
                changeLanguage: (n,r=!0)=>{
                    const l = Xn(n)
                      , a = t.nonOffSpelling()
                      , i = Xr(t.spelling().get());
                    r || i ? (t.spelling().setAndCache(e, l),
                    o && s(l)) : t.setNonOffSpelling(l),
                    ((t,n)=>{
                        Xr(t) && t !== n && ((e,t,n)=>{
                            e.dispatch("SpellcheckerLanguageChanged", {
                                language: t,
                                prevLanguage: n
                            })
                        }
                        )(e, t, n)
                    }
                    )(l, a)
                }
                ,
                getLanguage: ()=>{
                    const e = t.spelling().get();
                    return Xr(e) ? e : t.nonOffSpelling()
                }
                ,
                toggleLanguage: ()=>{
                    const n = Xr(t.spelling().get()) ? Qr() : t.nonOffSpelling();
                    t.spelling().setAndCache(e, n),
                    s(n)
                }
                ,
                getWordsAsync: e=>{
                    l((t=>{
                        t && e()
                    }
                    ), !1)
                }
                ,
                getWordsAsyncWithProgress: l,
                getWordsSuggestionsAsync: a
            }
        }
        )(e, a, f, l, m);
        return ((e,t)=>{
            const n = (t,n)=>({
                text: n,
                onAction: ()=>{
                    bl(e, t, n)
                }
            })
              , r = {
                getSubstituteItemsOverMax: (e,t,r)=>{
                    const o = t.slice(0, r)
                      , s = t.slice(r)
                      , l = P(o, (t=>n(e, t)))
                      , a = P(s, (t=>n(e, t)))
                      , i = {
                        type: "submenu",
                        text: "More...",
                        getSubmenuItems: T(a)
                    };
                    return l.concat([i])
                }
                ,
                getSubstituteItems: (e,t)=>P(t, (t=>n(e, t))),
                getSeparator: ()=>({
                    type: "separator"
                }),
                getIgnoreItem: (t,n)=>({
                    text: "Ignore",
                    onAction: ()=>{
                        vl(e, t, n)
                    }
                }),
                getIgnoreAllItem: (n,r,o)=>({
                    text: "Ignore all",
                    onAction: ()=>{
                        xl(e, n, r, o, t)
                    }
                }),
                getNoSuggestionsMenuItem: ()=>({
                    text: "No suggestions",
                    enabled: !1,
                    onAction: x
                })
            };
            e.ui.registry.addContextMenu("spellchecker", {
                update: e=>{
                    const n = (e=>wl(e, t).map((t=>((e,t,n,r,o)=>{
                        const s = ((e,t,n)=>0 === e.length ? [t.getNoSuggestionsMenuItem()] : e.length > 4 ? t.getSubstituteItemsOverMax(n, e, 4) : t.getSubstituteItems(n, e))(r.getOr([]), o, e)
                          , l = [o.getSeparator(), o.getIgnoreItem(e, n), o.getIgnoreAllItem(e, n, t)];
                        return s.concat(l)
                    }
                    )(e, t.detail.lang, t.detail.word, t.suggestions, r))))(Y.fromDom(e));
                    return n.getOr([])
                }
            })
        }
        )(e, l),
        ((e,t,n,r,o)=>{
            const s = P(t, (e=>({
                ...e,
                type: "choiceitem"
            })))
              , l = {
                tooltip: "Spellcheck...",
                icon: "spell-check",
                onAction: ()=>{
                    e.execCommand("mceSpellcheckDialog")
                }
            }
              , a = {
                tooltip: "Spellcheck...",
                icon: "spell-check",
                onAction: ()=>{
                    e.execCommand("mceSpellcheckDialog")
                }
                ,
                select: e=>e === n.spelling().get(),
                fetch: e=>{
                    e(s)
                }
                ,
                onItemAction: (e,t)=>{
                    r.changeLanguage(t)
                }
            }
              , i = {
                tooltip: "Spellcheck",
                icon: "spell-check",
                onAction: r.toggleLanguage,
                onSetup: t=>{
                    const r = ()=>{
                        t.setActive(Xr(n.spelling().get()))
                    }
                    ;
                    return r(),
                    e.on(Ol, r),
                    ()=>e.off(Ol, r)
                }
                ,
                select: e=>e === n.spelling().get(),
                fetch: e=>{
                    e(s)
                }
                ,
                onItemAction: (e,t)=>{
                    r.changeLanguage(t)
                }
            }
              , c = {
                text: "Spellcheck...",
                icon: "spell-check",
                onAction: ()=>{
                    e.execCommand("mceSpellcheckDialog")
                }
            };
            o ? (e.ui.registry.addSplitButton("spellchecker", i),
            e.ui.registry.addToggleMenuItem("spellchecker", {
                text: "Spellcheck",
                icon: "spell-check",
                onAction: r.toggleLanguage,
                onSetup: t=>{
                    const r = ()=>t.setActive(Xr(n.spelling().get()));
                    return r(),
                    e.on(Ol, r),
                    ()=>e.off(Ol, r)
                }
            }),
            e.ui.registry.addButton("spellcheckdialog", l),
            e.ui.registry.addMenuItem("spellcheckdialog", c)) : (e.ui.registry.addSplitButton("spellchecker", a),
            e.ui.registry.addMenuItem("spellchecker", c));
            const u = e=>({
                type: "togglemenuitem",
                text: e.text,
                onAction: ()=>r.changeLanguage(e.value),
                active: e.value === n.spelling().get()
            });
            e.ui.registry.addNestedMenuItem("spellcheckerlanguage", {
                text: "Spellcheck language",
                getSubmenuItems: ()=>P(s, u)
            })
        }
        )(e, g, a, b, m),
        ((e,t,n,r,o)=>{
            e.addCommand("mceSpellcheckEnable", (()=>{
                o ? n.changeLanguage(r.nonOffSpelling()) : t.open()
            }
            )),
            e.addCommand("mceSpellcheckDisable", (()=>{
                o && n.changeLanguage(Qr()),
                t.close()
            }
            )),
            e.addCommand("mceSpellcheckDialog", t.open),
            e.addCommand("mceSpellcheckDialogClose", t.close)
        }
        )(e, Il(e, l, f, m, b), b, a, m),
        ((e,t,n,r)=>({
            addIgnoredWords: (r,o)=>{
                B(r, (r=>{
                    if (y(o)) {
                        const e = Xn(o);
                        t.addToLang(e, r),
                        n.ignore(e, r)
                    } else
                        t.addToGlobal(r),
                        n.ignoreAll(r);
                    ((e,t,n)=>{
                        const r = Or(e, t, n);
                        B(r, (e=>dt(e)))
                    }
                    )(Y.fromDom(e.getDoc()), r, o)
                }
                ))
            }
            ,
            getLanguage: r.getLanguage,
            setLanguage: e=>r.changeLanguage(e, !1)
        }))(e, h, l, b)
    }
    ))
}();
