/*!
 * TinyDrive
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 2.0.1-32
 */

!function() {
    "use strict";
    const e = e=>{
        let t = e;
        return {
            get: ()=>t,
            set: e=>{
                t = e
            }
        }
    }
      , t = Object.getPrototypeOf
      , r = (e,t,r)=>{
        var o;
        return !!r(e, t.prototype) || (null === (o = e.constructor) || void 0 === o ? void 0 : o.name) === t.name
    }
      , o = e=>t=>(e=>{
        const t = typeof e;
        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && r(e, String, ((e,t)=>t.isPrototypeOf(e))) ? "string" : t
    }
    )(t) === e
      , n = e=>t=>typeof t === e
      , s = o("string")
      , a = o("object")
      , i = e=>((e,o)=>a(e) && r(e, o, ((e,r)=>t(e) === r)))(e, Object)
      , l = o("array")
      , u = n("boolean")
      , d = e=>!(e=>null == e)(e)
      , c = n("function")
      , p = n("number");
    class m {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new m(!0,e)
        }
        static none() {
            return m.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? m.some(e(this.value)) : m.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : m.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : m.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return d(e) ? m.some(e) : m.none()
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    m.singletonNone = new m(!1);
    const h = e=>parseInt(e, 10)
      , f = (e,t)=>{
        const r = e - t;
        return 0 === r ? 0 : r > 0 ? 1 : -1
    }
      , g = (e,t,r)=>({
        major: e,
        minor: t,
        patch: r
    })
      , y = e=>{
        const t = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(e);
        return t ? g(h(t[1]), h(t[2]), h(t[3])) : g(0, 0, 0)
    }
      , v = ()=>{}
      , b = (e,t)=>(...r)=>e(t.apply(null, r))
      , w = e=>()=>e
      , T = e=>e
      , x = (e,t)=>e === t;
    function O(e, ...t) {
        return (...r)=>{
            const o = t.concat(r);
            return e.apply(null, o)
        }
    }
    const U = e=>e()
      , k = w(!1)
      , j = w(!0)
      , _ = Array.prototype.indexOf
      , P = Array.prototype.push
      , D = (e,t)=>{
        return r = e,
        o = t,
        _.call(r, o) > -1;
        var r, o
    }
      , S = (e,t)=>{
        for (let r = 0, o = e.length; r < o; r++)
            if (t(e[r], r))
                return !0;
        return !1
    }
      , E = (e,t)=>{
        const r = e.length
          , o = new Array(r);
        for (let n = 0; n < r; n++) {
            const r = e[n];
            o[n] = t(r, n)
        }
        return o
    }
      , M = (e,t)=>{
        for (let r = 0, o = e.length; r < o; r++)
            t(e[r], r)
    }
      , F = (e,t)=>{
        const r = [];
        for (let o = 0, n = e.length; o < n; o++) {
            const n = e[o];
            t(n, o) && r.push(n)
        }
        return r
    }
      , C = (e,t,r)=>(M(e, ((e,o)=>{
        r = t(r, e, o)
    }
    )),
    r)
      , B = (e,t)=>((e,t,r)=>{
        for (let o = 0, n = e.length; o < n; o++) {
            const n = e[o];
            if (t(n, o))
                return m.some(n);
            if (r(n, o))
                break
        }
        return m.none()
    }
    )(e, t, k)
      , R = e=>{
        const t = [];
        for (let r = 0, o = e.length; r < o; ++r) {
            if (!l(e[r]))
                throw new Error("Arr.flatten item " + r + " was not an array, input: " + e);
            P.apply(t, e[r])
        }
        return t
    }
      , N = (e,t)=>R(E(e, t))
      , z = e=>((e,t)=>0 < e.length ? m.some(e[0]) : m.none())(e)
      , A = e=>{
        const t = t=>t(e)
          , r = w(e)
          , o = ()=>n
          , n = {
            tag: !0,
            inner: e,
            fold: (t,r)=>r(e),
            isValue: j,
            isError: k,
            map: t=>q.value(t(e)),
            mapError: o,
            bind: t,
            exists: t,
            forall: t,
            getOr: r,
            or: o,
            getOrThunk: r,
            orThunk: o,
            getOrDie: r,
            each: t=>{
                t(e)
            }
            ,
            toOptional: ()=>m.some(e)
        };
        return n
    }
      , I = e=>{
        const t = ()=>r
          , r = {
            tag: !1,
            inner: e,
            fold: (t,r)=>t(e),
            isValue: k,
            isError: j,
            map: t,
            mapError: t=>q.error(t(e)),
            bind: t,
            exists: k,
            forall: j,
            getOr: T,
            or: T,
            getOrThunk: U,
            orThunk: U,
            getOrDie: (o = String(e),
            ()=>{
                throw new Error(o)
            }
            ),
            each: v,
            toOptional: m.none
        };
        var o;
        return r
    }
      , q = {
        value: A,
        error: I,
        fromOption: (e,t)=>e.fold((()=>I(t)), A)
    }
      , L = "undefined" != typeof window ? window : Function("return this;")()
      , $ = Object.keys
      , J = Object.hasOwnProperty
      , H = (e,t)=>{
        const r = $(e);
        for (let o = 0, n = r.length; o < n; o++) {
            const n = r[o];
            t(e[n], n)
        }
    }
      , K = (e,t)=>V(e, ((e,r)=>({
        k: r,
        v: t(e, r)
    })))
      , V = (e,t)=>{
        const r = {};
        return H(e, ((e,o)=>{
            const n = t(e, o);
            r[n.k] = n.v
        }
        )),
        r
    }
      , W = e=>(t,r)=>{
        e[r] = t
    }
      , Y = (e,t)=>{
        const r = [];
        return H(e, ((e,o)=>{
            r.push(t(e, o))
        }
        )),
        r
    }
      , Z = e=>Y(e, T)
      , X = (e,t)=>G(e, t) ? m.from(e[t]) : m.none()
      , G = (e,t)=>J.call(e, t)
      , Q = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , ee = (e,t)=>{
        const r = (t || document).createElement(e);
        return Q(r)
    }
      , te = Q
      , re = (1,
    e=>1 === (e=>e.dom.nodeType)(e));
    const oe = (e,t)=>{
        e.dom.appendChild(t.dom)
    }
      , ne = c(Element.prototype.attachShadow) && c(Node.prototype.getRootNode)
      , se = w(ne)
      , ae = (e,t)=>{
        const r = e.dom;
        H(t, ((e,t)=>{
            ((e,t,r)=>{
                if (!(s(r) || u(r) || p(r)))
                    throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", r, ":: Element ", e),
                    new Error("Attribute value was not simple");
                e.setAttribute(t, r + "")
            }
            )(r, t, e)
        }
        ))
    }
      , ie = e=>{
        const t = te((e=>{
            if (se() && d(e.target)) {
                const t = te(e.target);
                if (re(t) && d(t.dom.shadowRoot) && e.composed && e.composedPath) {
                    const t = e.composedPath();
                    if (t)
                        return z(t)
                }
            }
            return m.from(e.target)
        }
        )(e).getOr(e.target))
          , r = ()=>e.stopPropagation()
          , o = ()=>e.preventDefault()
          , n = b(o, r);
        return ((e,t,r,o,n,s,a)=>({
            target: e,
            x: t,
            y: r,
            stop: o,
            prevent: n,
            kill: s,
            raw: a
        }))(t, e.clientX, e.clientY, r, o, n, e)
    }
      , le = (e,t,r,o)=>{
        e.dom.removeEventListener(t, r, o)
    }
      , ue = j
      , de = (e,t,r)=>((e,t,r,o)=>((e,t,r,o,n)=>{
        const s = ((e,t)=>r=>{
            e(r) && t(ie(r))
        }
        )(r, o);
        return e.dom.addEventListener(t, s, n),
        {
            unbind: O(le, e, t, s, n)
        }
    }
    )(e, t, r, o, !1))(e, t, ue, r)
      , ce = (e,t)=>((e,r)=>B(e.dom.childNodes, (e=>((e,t)=>{
        const r = e.dom;
        if (1 !== r.nodeType)
            return !1;
        {
            const e = r;
            if (void 0 !== e.matches)
                return e.matches(t);
            if (void 0 !== e.msMatchesSelector)
                return e.msMatchesSelector(t);
            if (void 0 !== e.webkitMatchesSelector)
                return e.webkitMatchesSelector(t);
            if (void 0 !== e.mozMatchesSelector)
                return e.mozMatchesSelector(t);
            throw new Error("Browser lacks native selectors")
        }
    }
    )(te(e), t))).map(te))(e)
      , pe = (e,t)=>new Promise((r=>{
        const o = ee("script");
        ae(o, {
            src: e,
            ...t
        }),
        de(o, "load", (()=>{
            r(q.value(o))
        }
        )),
        de(o, "error", (()=>{
            r(q.error(`Failed to load script: ${e}`))
        }
        )),
        oe((e=>{
            const t = e.dom.body;
            if (null == t)
                throw new Error("Body is not available yet");
            return te(t)
        }
        )(te(document)), o)
    }
    ))
      , me = e=>new Promise((t=>{
        const r = (e=>{
            const t = e.dom.head;
            if (null == t)
                throw new Error("Head is not available yet");
            return te(t)
        }
        )(te(document))
          , o = ((e,t)=>ce(e, `link[href="${t}"]`))(r, e)
          , n = ee("link");
        ae(n, {
            rel: "stylesheet",
            href: e
        }),
        de(n, "load", (()=>{
            t(q.value(n))
        }
        )),
        de(n, "error", (()=>{
            t(q.error(`Failed to load css: ${e}`)),
            (e=>{
                const t = e.dom;
                null !== t.parentNode && t.parentNode.removeChild(t)
            }
            )(n)
        }
        )),
        o.fold((()=>oe(r, n)), (e=>t(q.value(e))))
    }
    ))
      , he = (e,t,r)=>X(e, t).fold((()=>((e,t,r)=>pe(r, {}).then((r=>q.fromOption(X(e, t), `Could not find "${t}" in the given namespace`))))(e, t, r)), (e=>Promise.resolve(q.value(e))))
      , fe = e=>e < 10 ? "0" + e.toString() : e.toString()
      , ge = e=>{
        let t = m.none()
          , r = [];
        const o = e=>{
            n() ? s(e) : r.push(e)
        }
          , n = ()=>t.isSome()
          , s = e=>{
            t.each((t=>{
                setTimeout((()=>{
                    e(t)
                }
                ), 0)
            }
            ))
        }
        ;
        return e((e=>{
            n() || (t = m.some(e),
            M(r, s),
            r = [])
        }
        )),
        {
            get: o,
            map: e=>ge((t=>{
                o((r=>{
                    t(e(r))
                }
                ))
            }
            )),
            isReady: n
        }
    }
      , ye = {
        nu: ge,
        pure: e=>ge((t=>{
            t(e)
        }
        ))
    }
      , ve = e=>{
        setTimeout((()=>{
            throw e
        }
        ), 0)
    }
      , be = e=>{
        const t = t=>{
            e().then(t, ve)
        }
        ;
        return {
            map: t=>be((()=>e().then(t))),
            bind: t=>be((()=>e().then((e=>t(e).toPromise())))),
            anonBind: t=>be((()=>e().then((()=>t.toPromise())))),
            toLazy: ()=>ye.nu(t),
            toCached: ()=>{
                let t = null;
                return be((()=>(null === t && (t = e()),
                t)))
            }
            ,
            toPromise: e,
            get: t
        }
    }
      , we = e=>be((()=>new Promise(e)))
      , Te = e=>be((()=>Promise.resolve(e)))
      , xe = e=>({
        ...e,
        toCached: ()=>xe(e.toCached()),
        bindFuture: t=>xe(e.bind((e=>e.fold((e=>Te(q.error(e))), (e=>t(e)))))),
        bindResult: t=>xe(e.map((e=>e.bind(t)))),
        mapResult: t=>xe(e.map((e=>e.map(t)))),
        mapError: t=>xe(e.map((e=>e.mapError(t)))),
        foldResult: (t,r)=>e.map((e=>e.fold(t, r))),
        withTimeout: (t,r)=>xe(we((o=>{
            let n = !1;
            const s = setTimeout((()=>{
                n = !0,
                o(q.error(r()))
            }
            ), t);
            e.get((e=>{
                n || (clearTimeout(s),
                o(e))
            }
            ))
        }
        )))
    })
      , Oe = e=>xe(we(e))
      , Ue = e=>xe(Te(q.value(e)))
      , ke = e=>xe(Te(q.error(e)))
      , je = (e,t)=>((e,t,r)=>"" === t || e.length >= t.length && e.substr(0, 0 + t.length) === t)(e, t);
    var _e;
    !function(e) {
        e.JSON = "json",
        e.Blob = "blob",
        e.Text = "text",
        e.FormData = "formdata",
        e.MultipartFormData = "multipart/form-data"
    }(_e || (_e = {}));
    const Pe = e=>({
        type: _e.JSON,
        data: e
    })
      , De = e=>we((t=>{
        const r = new FileReader;
        r.onload = e=>{
            const r = e.target ? e.target.result : "";
            t(r)
        }
        ,
        r.readAsText(e)
    }
    ))
      , Se = e=>{
        try {
            const t = JSON.parse(e);
            return q.value(t)
        } catch (e) {
            return q.error("Response was not JSON.")
        }
    }
      , Ee = e=>Te(e.response)
      , Me = e=>Oe((t=>{
        const r = new XMLHttpRequest;
        var o;
        r.open(e.method, (o = e.url,
        m.from(e.query).map((e=>{
            const t = Y(e, ((e,t)=>encodeURIComponent(t) + "=" + encodeURIComponent(e)))
              , r = ("?",
            -1 !== o.indexOf("?") ? "&" : "?");
            return t.length > 0 ? o + r + t.join("&") : o
        }
        )).getOr(o)), !0);
        const n = (e=>{
            const t = (r = e.body,
            m.from(r).bind((e=>{
                switch (e.type) {
                case _e.JSON:
                    return m.some("application/json");
                case _e.FormData:
                    return m.some("application/x-www-form-urlencoded; charset=UTF-8");
                case _e.MultipartFormData:
                    return m.none();
                case _e.Text:
                default:
                    return m.some("text/plain")
                }
            }
            )));
            var r;
            const o = !0 === e.credentials ? m.some(!0) : m.none()
              , n = (e=>{
                switch (e) {
                case _e.Blob:
                    return "application/octet-stream";
                case _e.JSON:
                    return "application/json, text/javascript";
                case _e.Text:
                    return "text/plain";
                default:
                    return ""
                }
            }
            )(e.responseType) + ", */*; q=0.01"
              , s = void 0 !== e.headers ? e.headers : {};
            return {
                contentType: t,
                responseType: (e=>{
                    switch (e) {
                    case _e.JSON:
                        return m.none();
                    case _e.Blob:
                        return m.some("blob");
                    case _e.Text:
                        return m.some("text");
                    default:
                        return m.none()
                    }
                }
                )(e.responseType),
                credentials: o,
                accept: n,
                headers: s,
                progress: c(e.progress) ? m.some(e.progress) : m.none()
            }
        }
        )(e);
        ((e,t)=>{
            t.contentType.each((t=>e.setRequestHeader("Content-Type", t))),
            e.setRequestHeader("Accept", t.accept),
            t.credentials.each((t=>e.withCredentials = t)),
            t.responseType.each((t=>e.responseType = t)),
            t.progress.each((t=>e.upload.addEventListener("progress", (e=>t(e.loaded, e.total))))),
            H(t.headers, ((t,r)=>e.setRequestHeader(r, t)))
        }
        )(r, n);
        const s = ()=>{
            ((e,t,r)=>((e,t)=>{
                switch (e) {
                case _e.JSON:
                    return Se(t.response).fold((()=>Ee(t)), Te);
                case _e.Blob:
                    return (e=>m.from(e.response).map(De).getOr(Te("no response content")))(t);
                case _e.Text:
                default:
                    return Ee(t)
                }
            }
            )(t, r).map((t=>({
                message: 0 === r.status ? "Unknown HTTP error (possible cross-domain request)" : `Could not load url ${e}: ${r.statusText}`,
                status: r.status,
                responseText: t
            }))))(e.url, e.responseType, r).get((e=>t(q.error(e))))
        }
        ;
        var a;
        r.onerror = s,
        r.onload = ()=>{
            0 !== r.status || je(e.url, "file:") ? r.status < 100 || r.status >= 400 ? s() : ((e,t)=>{
                const r = e=>ke({
                    message: e,
                    status: t.status,
                    responseText: t.responseText
                });
                switch (e) {
                case _e.JSON:
                    return Se(t.response).fold(r, Ue);
                case _e.Blob:
                case _e.Text:
                    return Ue(t.response);
                default:
                    return r("unknown data type")
                }
            }
            )(e.responseType, r).get(t) : s()
        }
        ,
        (a = e.body,
        m.from(a).map((e=>e.type === _e.JSON ? JSON.stringify(e.data) : e.type === _e.FormData || e.type === _e.MultipartFormData ? (e=>{
            const t = new FormData;
            return H(e, ((e,r)=>{
                t.append(r, e)
            }
            )),
            t
        }
        )(e.data) : e.data))).fold((()=>r.send()), (e=>{
            r.send(e)
        }
        ))
    }
    ))
      , Fe = e=>Me({
        ...e,
        method: "post"
    })
      , Ce = (e,t,r)=>q.error({
        message: t,
        status: e,
        responseText: r
    })
      , Be = (e,t)=>Fe({
        url: e,
        responseType: _e.JSON,
        body: Pe({})
    }).bindResult((r=>s(r.token) ? ((e,t)=>(t.set(m.some(e)),
    q.value(e)))(r.token, t) : ((e,t)=>(t.set(m.none()),
    Ce(500, `Jwt token provider: "${e}" did not return a "token" string property in it's JSON response body.`, "")))(e, t)))
      , Re = (e,t)=>Oe((r=>{
        e((e=>{
            t.set(m.some(e.token)),
            r(q.value(e.token))
        }
        ), (e=>{
            t.set(m.none()),
            r(Ce(0, e, ""))
        }
        ))
    }
    ))
      , Ne = (e,t)=>s(e) ? ((e,t)=>r=>r ? Be(e, t) : t.get().fold((()=>Be(e, t)), (e=>Ue(e))))(e, t) : c(e) ? ((e,t)=>r=>r ? Re(e, t) : t.get().fold((()=>Re(e, t)), (e=>Ue(e))))(e, t) : ("Required jwt token provider not defined.",
    e=>{
        return t = Ce(0, "Required jwt token provider not defined.", ""),
        xe(Te(t));
        var t
    }
    )
      , ze = "oxide"
      , Ae = [ze, "oxide-dark"]
      , Ie = e=>D(Ae, e)
      , qe = e=>t=>t.options.get(e)
      , Le = e=>t=>m.from(e(t))
      , $e = e=>{
        var t;
        return m.from(null !== (t = e.options.get("tinydrive_api_key")) && void 0 !== t ? t : e.options.get("api_key"))
    }
      , Je = qe("tinydrive_script_url")
      , He = Le(qe("tinydrive_demo_files_url"))
      , Ke = Le(qe("tinydrive_demo_files"))
      , Ve = Le(qe("tinydrive_service_url"))
      , We = Le(qe("tinydrive_max_image_dimension"))
      , Ye = Le(qe("tinydrive_dropbox_app_key"))
      , Ze = Le(qe("tinydrive_google_drive_key"))
      , Xe = Le(qe("tinydrive_google_drive_client_id"))
      , Ge = Le(qe("tinydrive_css_url"))
      , Qe = Le(qe("skin"))
      , et = Le(qe("tinydrive_skin"))
      , tt = (e,t)=>Ge(e).getOrThunk((()=>{
        const r = et(e).orThunk((()=>Qe(e))).filter(Ie).getOr(ze);
        return ((e,t)=>"oxide" === t ? `${e}/assetmanager.min.css` : `${e}/skins/${t}.min.css`)(t, r)
    }
    ))
      , rt = (e,t)=>{
        const r = e.options.get("tinydrive_token_provider");
        return Ne(r, t)
    }
      , ot = qe("tinydrive_upload_path")
      , nt = e=>(...t)=>{
        if (0 === t.length)
            throw new Error("Can't merge zero objects");
        const r = {};
        for (let o = 0; o < t.length; o++) {
            const n = t[o];
            for (const t in n)
                G(n, t) && (r[t] = e(r[t], n[t]))
        }
        return r
    }
      , st = nt(((e,t)=>i(e) && i(t) ? st(e, t) : t))
      , at = nt(((e,t)=>t))
      , it = e=>t=>t.fold((e=>Promise.resolve(q.error(e))), e)
      , lt = e=>t=>Promise.resolve(t.bind(e))
      , ut = e=>t=>t.mapError(e)
      , dt = e=>e.then((e=>new Promise(((t,r)=>{
        e.fold(r, t)
    }
    ))))
      , ct = e=>e.replace(/\\/g, "/")
      , pt = (e,t,...r)=>{
        const o = ct(e).replace(/\/$/, "") + "/" + ct(t).replace(/^\//, "");
        return C(r, ((e,t)=>pt(e, t)), o)
    }
      , mt = e=>{
        const t = []
          , r = e=>{
            t.push(e)
        }
        ;
        for (let t = 0; t < e.length; t++)
            e[t].each(r);
        return t
    }
      , ht = (e,t,r)=>e.sort(((e,o)=>{
        if ("name" === t)
            return "desc" === r ? o.name.localeCompare(e.name) : e.name.localeCompare(o.name);
        if ("size" === t)
            return "desc" === r ? o.size - e.size : e.size - o.size;
        {
            const t = e.modificationDate.getTime()
              , n = o.modificationDate.getTime();
            return "desc" === r ? n - t : t - n
        }
    }
    ))
      , ft = (e,t,r)=>{
        const o = ((e,t)=>{
            const r = []
              , o = [];
            for (let t = 0, s = e.length; t < s; t++) {
                const s = e[t];
                (n = s,
                "directory" === n.type ? r : o).push(s)
            }
            var n;
            return {
                pass: r,
                fail: o
            }
        }
        )(e);
        return ht(o.pass, t, r).concat(ht(o.fail, t, r))
    }
      , gt = e=>({
        type: "",
        message: e
    })
      , yt = e=>({
        type: "",
        message: e.message
    });
    let vt = 0;
    const bt = ()=>(e=>{
        const t = (new Date).getTime()
          , r = Math.floor(1e9 * Math.random());
        return vt++,
        "file_" + r + vt + String(t)
    }
    )()
      , wt = (e,t)=>{
        const r = ((e,t,r)=>B(e, (e=>t.fold((()=>e.parentUuid.isNone() && e.name === r), (t=>e.parentUuid.exists((o=>o === t && e.name === r)))))))(e.files, e.parentUuid, t);
        return r.fold((()=>{
            const r = {
                uuid: bt(),
                type: "directory",
                parentUuid: e.parentUuid,
                name: t,
                size: 0,
                modificationDate: new Date,
                url: m.none(),
                thumbUrl: m.none(),
                starred: !1,
                path: m.none()
            };
            return {
                files: e.files.concat([r]),
                parentUuid: m.some(r.uuid)
            }
        }
        ), (t=>({
            files: e.files,
            parentUuid: m.some(t.uuid)
        })))
    }
      , Tt = (e,t)=>C((e=>F(e.split("/"), (e=>e.length > 0)))(t), wt, {
        files: e,
        parentUuid: m.none()
    })
      , xt = e=>m.from(e.split(".")[1]).map((e=>JSON.parse(window.atob(e))))
      , Ot = R(Z({
        "image/webp": ["webp"],
        "image/gif": ["gif"],
        "image/jpeg": ["jpeg", "jpg", "jpe", "jfi", "jif", "jfif", "pjpeg", "pjp"],
        "image/apng": ["apng"],
        "image/avif": ["avif"],
        "image/png": ["png"],
        "image/tiff": ["tif", "tiff"],
        "image/bmp": ["bmp"]
    }))
      , Ut = R(Z({
        "application/msword": ["doc"],
        "application/vnd.ms-excel": ["xls"],
        "application/vnd.ms-powerpoint": ["ppt", "pps"],
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
        "application/pdf": ["pdf"],
        "application/rtf": ["rtf"],
        "text/plain": ["txt"],
        "application/x-iwork-keynote-sffkey": ["key"],
        "application/x-iwork-pages-sffpages": ["pages"],
        "application/x-iwork-numbers-sffnumbers": ["numbers"]
    }))
      , kt = R(Z({
        "audio/wav": ["wav", "wave"],
        "audio/mpeg": ["mp3"],
        "audio/ogg": ["ogg", "oga", "ogx", "ogm", "spx", "opus"]
    }))
      , jt = R(Z({
        "video/mp4": ["mp4", "m4v"],
        "video/ogg": ["ogv"],
        "video/webm": ["webm"],
        "video/quicktime": ["mov"]
    }))
      , _t = R(Z({
        "application/zip": ["zip"]
    }))
      , Pt = e=>{
        const t = (e=>{
            const t = e.lastIndexOf(".");
            return -1 !== t ? e.substr(t) : ""
        }
        )(e).substring(1).toLowerCase();
        return D(Ot, t) ? m.some("image") : D(Ut, t) ? m.some("document") : D(kt, t) ? m.some("audio") : D(jt, t) ? m.some("video") : D(_t, t) ? m.some("archive") : m.none()
    }
      , Dt = e=>{
        switch (e) {
        case "directory":
            return "directory";
        case "document":
            return "document";
        case "audio":
            return "audio";
        case "video":
            return "video";
        case "image":
            return "image";
        case "archive":
            return "archive"
        }
    }
      , St = e=>{
        switch (e) {
        case "directory":
            return m.some("directory");
        case "document":
            return m.some("document");
        case "audio":
            return m.some("audio");
        case "video":
            return m.some("video");
        case "image":
            return m.some("image");
        case "archive":
            return m.some("archive");
        default:
            return m.none()
        }
    }
      , Et = e=>{
        const t = mt(E(e, St));
        return t.length > 0 ? ["directory"].concat(t) : []
    }
    ;
    var Mt;
    !function(e) {
        e[e.Error = 0] = "Error",
        e[e.Value = 1] = "Value"
    }(Mt || (Mt = {}));
    const Ft = (e,t,r)=>e.stype === Mt.Error ? t(e.serror) : r(e.svalue)
      , Ct = e=>({
        stype: Mt.Value,
        svalue: e
    })
      , Bt = e=>({
        stype: Mt.Error,
        serror: e
    })
      , Rt = Ft
      , Nt = e=>a(e) && $(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2)
      , zt = (e,t)=>Bt([{
        path: e,
        getErrorInfo: t
    }])
      , At = e=>{
        const t = (e=>{
            const t = []
              , r = [];
            return M(e, (e=>{
                Ft(e, (e=>r.push(e)), (e=>t.push(e)))
            }
            )),
            {
                values: t,
                errors: r
            }
        }
        )(e);
        return t.errors.length > 0 ? (r = t.errors,
        b(Bt, R)(r)) : Ct(t.values);
        var r
    }
      , It = (e,t,r)=>{
        switch (e.tag) {
        case "field":
            return t(e.key, e.newKey, e.presence, e.prop);
        case "custom":
            return r(e.newKey, e.instantiator)
        }
    }
      , qt = e=>({
        extract: (t,r)=>{
            return o = e(r),
            n = e=>((e,t)=>zt(e, w(t)))(t, e),
            o.stype === Mt.Error ? n(o.serror) : o;
            var o, n
        }
        ,
        toString: w("val")
    })
      , Lt = qt(Ct)
      , $t = (e,t,r,o)=>o(X(e, t).getOrThunk((()=>r(e))))
      , Jt = (e,t,r,o,n)=>{
        const s = e=>n.extract(t.concat([o]), e)
          , a = e=>e.fold((()=>Ct(m.none())), (e=>{
            const r = n.extract(t.concat([o]), e);
            return s = r,
            a = m.some,
            s.stype === Mt.Value ? {
                stype: Mt.Value,
                svalue: a(s.svalue)
            } : s;
            var s, a
        }
        ));
        switch (e.tag) {
        case "required":
            return ((e,t,r,o)=>X(t, r).fold((()=>((e,t,r)=>zt(e, (()=>'Could not find valid *required* value for "' + t + '" in ' + Nt(r))))(e, r, t)), o))(t, r, o, s);
        case "defaultedThunk":
            return $t(r, o, e.process, s);
        case "option":
            return ((e,t,r)=>r(X(e, t)))(r, o, a);
        case "defaultedOptionThunk":
            return ((e,t,r,o)=>o(X(e, t).map((t=>!0 === t ? r(e) : t))))(r, o, e.process, a);
        case "mergeWithThunk":
            return $t(r, o, w({}), (t=>{
                const o = st(e.process(r), t);
                return s(o)
            }
            ))
        }
    }
      , Ht = e=>({
        extract: (t,r)=>((e,t,r)=>{
            const o = {}
              , n = [];
            for (const s of r)
                It(s, ((r,s,a,i)=>{
                    const l = Jt(a, e, t, r, i);
                    Rt(l, (e=>{
                        n.push(...e)
                    }
                    ), (e=>{
                        o[s] = e
                    }
                    ))
                }
                ), ((e,r)=>{
                    o[e] = r(t)
                }
                ));
            return n.length > 0 ? Bt(n) : Ct(o)
        }
        )(t, r, e),
        toString: ()=>{
            const t = E(e, (e=>It(e, ((e,t,r,o)=>e + " -> " + o.toString()), ((e,t)=>"state(" + e + ")"))));
            return "obj{\n" + t.join("\n") + "}"
        }
    })
      , Kt = e=>({
        extract: (t,r)=>{
            const o = E(r, ((r,o)=>e.extract(t.concat(["[" + o + "]"]), r)));
            return At(o)
        }
        ,
        toString: ()=>"array(" + e.toString() + ")"
    })
      , Vt = (e,t,r)=>{
        return o = ((e,t,r)=>((e,t)=>e.stype === Mt.Error ? {
            stype: Mt.Error,
            serror: t(e.serror)
        } : e)(t.extract([e], r), (e=>({
            input: r,
            errors: e
        }))))(e, t, r),
        Ft(o, q.error, q.value);
        var o
    }
      , Wt = e=>"Errors: \n" + (e=>{
        const t = e.length > 10 ? e.slice(0, 10).concat([{
            path: [],
            getErrorInfo: w("... (only showing first ten failures)")
        }]) : e;
        return E(t, (e=>"Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()))
    }
    )(e.errors).join("\n") + "\n\nInput object: " + Nt(e.input)
      , Yt = w(Lt)
      , Zt = (e,t)=>qt((r=>{
        const o = typeof r;
        return e(r) ? Ct(r) : Bt(`Expected type: ${t} but got: ${o}`)
    }
    ))
      , Xt = Zt(p, "number")
      , Gt = Zt(s, "string")
      , Qt = Zt(u, "boolean")
      , er = Zt(c, "function")
      , tr = (e,t,r,o)=>({
        tag: "field",
        key: e,
        newKey: t,
        presence: r,
        prop: o
    })
      , rr = (e,t)=>tr(e, e, {
        tag: "required",
        process: {}
    }, t)
      , or = e=>rr(e, Xt)
      , nr = e=>rr(e, Gt)
      , sr = e=>rr(e, Qt)
      , ar = (e,t)=>tr(e, e, {
        tag: "required",
        process: {}
    }, Kt(t))
      , ir = e=>((e,t)=>tr(e, e, {
        tag: "option",
        process: {}
    }, t))(e, Gt)
      , lr = (e,t,r)=>tr(e, e, (e=>({
        tag: "defaultedThunk",
        process: w(e)
    }))(t), r)
      , ur = Ht([nr("name"), nr("sub"), ir("root"), tr("https://claims.tiny.cloud/drive/root", "root", {
        tag: "option",
        process: {}
    }, Gt)])
      , dr = (e,t)=>{
        e.set(at(e.get(), {
            files: t
        }))
    }
      , cr = (e,t)=>{
        e.set(at(e.get(), {
            meta: at(e.get().meta, t)
        }))
    }
      , pr = (e,t)=>{
        const r = {}
          , o = C(t, ((t,o)=>{
            const n = p(o.size) ? Pt(o.name).getOr("document") : "directory"
              , a = o.size ? o.size : 0
              , i = s(o.date) ? (d = o.date,
            (e=>m.from(/^([0-9]{4})\-([0-9]{2})\-([0-9]{2}) ([0-9]{2})\:([0-9]{2})\:([0-9]{2})$/.exec(e)))(d).map((e=>{
                const t = Date.parse(`${e[1]}-${e[2]}-${e[3]}T${e[4]}:${e[5]}:${e[6]}Z`);
                return new Date(t)
            }
            ))).getOr(new Date) : new Date
              , l = o.uuid ? o.uuid : bt()
              , u = {
                uuid: l,
                type: n,
                parentUuid: m.from(o.parentUuid),
                name: o.name,
                size: a,
                modificationDate: i,
                url: m.from(o.url),
                thumbUrl: m.from(o.thumbUrl),
                starred: !0 === o.starred,
                path: m.none()
            };
            var d;
            return r[l] = ((e,t)=>{
                const r = e.meta ? e.meta : {}
                  , o = m.from(r.createdBy).orThunk((()=>xt(t).map((e=>e.name))));
                return {
                    description: r.description ? r.description : "",
                    createdBy: o
                }
            }
            )(o, e),
            ((e,t,r)=>{
                const o = Tt(e, t);
                return o.files.concat([at(r, {
                    parentUuid: o.parentUuid
                })])
            }
            )(t, o.path, u)
        }
        ), [])
          , n = (e=>xt(e).bind((e=>Vt("claims", ur, e).toOptional())))(e).getOr({
            name: "",
            sub: "",
            root: m.none()
        });
        return n.root.fold((()=>({
            files: o,
            meta: r,
            claims: n,
            rootUuid: m.none()
        })), (e=>{
            const t = Tt(o, e)
              , s = t.parentUuid;
            return {
                files: t.files,
                meta: r,
                claims: n,
                rootUuid: s
            }
        }
        ))
    }
      , mr = (e,t)=>m.from(e).or(t.get().rootUuid)
      , hr = (e,t)=>e.parentUuid.bind((e=>fr(e, t)))
      , fr = (e,t)=>B(t, (t=>t.uuid === e))
      , gr = (e,t)=>at(e, {
        path: t
    })
      , yr = (e,t)=>gr(e, m.some(((e,t)=>{
        const r = [];
        for (let o = hr(e, t); o.isSome(); o = o.bind((e=>hr(e, t))))
            o.each((e=>r.push(e)));
        return "/" + E(r.reverse(), (e=>e.name)).concat([e.name]).join("/")
    }
    )(e, t)))
      , vr = (e,t)=>e.query.fold(j, (e=>-1 !== t.name.toLowerCase().indexOf(e.toLowerCase())))
      , br = (e,t)=>0 === e.fileTypes.length || S(e.fileTypes, (e=>e === t.type))
      , wr = (e,t,r,o,n)=>new Promise((s=>{
        const a = n.or(e.get().rootUuid);
        Pt(r).fold((()=>s(q.error({
            type: "",
            message: `Invalid file extension for "${r}"`
        }))), (n=>{
            const i = bt()
              , l = {
                uuid: i,
                type: n,
                parentUuid: a,
                name: r,
                size: t.size,
                modificationDate: new Date,
                url: m.some(URL.createObjectURL(t)),
                thumbUrl: o.map((e=>URL.createObjectURL(e))),
                starred: !1,
                path: m.none()
            };
            cr(e, {
                [i]: {
                    description: "",
                    createdBy: m.some(e.get().claims.name)
                }
            }),
            dr(e, e.get().files.concat([l])),
            s(q.value(l))
        }
        ))
    }
    ))
      , Tr = e=>t=>new Promise((r=>{
        ((e,o,n,s)=>{
            const a = (o,n)=>{
                setTimeout((()=>{
                    n < o ? (e(n, o),
                    a(o, n + 1)) : (e(n, o),
                    r(q.value(t)))
                }
                ), 10)
            }
            ;
            a(10, 0)
        }
        )(((r,o)=>{
            const n = Math.round(t.size * (r / o));
            e({
                name: t.name,
                uuid: t.uuid,
                loaded: n,
                total: t.size
            })
        }
        ))
    }
    ))
      , xr = (t,r)=>{
        const o = ((e,t)=>r=>e().then(lt((e=>(t.log && console.log("memfs:", r, e.get().claims),
        q.value(e))))))(((t,r)=>{
            const o = e({
                files: [],
                meta: {},
                claims: {
                    name: "",
                    sub: "",
                    root: m.none()
                },
                rootUuid: m.none()
            });
            return ()=>{
                return t.jwtTokenFactory(!1).toPromise().then((e = t.requestDelay,
                t=>new Promise((r=>{
                    setTimeout((()=>{
                        r(t)
                    }
                    ), e)
                }
                )))).then(ut(yt)).then((e=>r.then(it((t=>(o.get().files.length <= 0 && e.each((e=>o.set(pr(e, t)))),
                Promise.resolve(q.value(o))))))));
                var e
            }
        }
        )(t, r), t)
          , n = (e,t,r)=>{
            const o = m.from(e.get().meta[t]).fold((()=>({
                [t]: {
                    description: "",
                    createdBy: m.none(),
                    ...r
                }
            })), (e=>({
                [t]: at(e, r)
            })));
            cr(e, at(e.get().meta, o))
        }
          , a = (e,t)=>e.claims.root.map((e=>t.path.exists((t=>{
            return e === t || (r = e,
            0 === pt(t, "/").indexOf(pt(r, "/")));
            var r
        }
        )))).getOr(!0)
          , i = (e,t)=>E(e, (e=>t.fold(w(e), (t=>gr(e, e.path.map((e=>{
            var r, o;
            return "/" + (je(r = e, o = t + "/") ? ((e,t)=>e.substring(t))(r, o.length) : r)
        }
        )))))));
        return {
            rename: (e,t)=>o("rename").then(it((r=>new Promise((o=>{
                var n, s;
                dr(r, E(r.get().files, (r=>r.uuid === e ? at(r, {
                    name: t
                }) : r))),
                z((n = r.get().files,
                s = [e],
                F(n, (e=>D(s, e.uuid))))).fold((()=>o(q.error({
                    type: "error",
                    message: "File not found"
                }))), (e=>o(q.value(e.uuid))))
            }
            ))))),
            mkdir: (e,t)=>o("mkdir").then(it((r=>new Promise((o=>{
                const n = bt()
                  , a = {
                    uuid: n,
                    type: "directory",
                    parentUuid: s(t) ? mr(t, r) : m.none(),
                    name: e,
                    size: 0,
                    modificationDate: new Date,
                    url: m.none(),
                    thumbUrl: m.none(),
                    starred: !1,
                    path: m.none()
                };
                ((e,t,r)=>S(F(e, (e=>t.fold((()=>e.parentUuid.isNone()), (t=>e.parentUuid.exists((e=>e === t)))))), (e=>"directory" === e.type && e.name === r)))(r.get().files, m.from(t), e) ? o(q.error({
                    type: "x",
                    message: "Directory already exists"
                })) : (dr(r, r.get().files.concat([a])),
                o(q.value(n)))
            }
            ))))),
            upload: e=>o("upload").then(it((t=>((e,t)=>wr(e, t.blob, t.name, t.thumbBlob, t.parent).then(it(Tr(t.progress))))(t, e)))),
            list: e=>o("list").then(it((r=>new Promise((o=>{
                const n = F(r.get().files, (t=>((e,t,r)=>e.parentUuid.fold((()=>r.fold((()=>t.parentUuid.isNone()), (e=>t.parentUuid.exists((t=>t === e))))), (e=>t.parentUuid.exists((t=>t === e)))))(e, t, r.get().rootUuid) && vr(e, t) && br(e, t)))
                  , s = ft(n, e.sortBy, e.sortOrder)
                  , a = s.slice(e.offset, e.offset + t.limit)
                  , i = e.offset + a.length;
                o(q.value({
                    last: i >= s.length,
                    offset: i,
                    files: a
                }))
            }
            ))))),
            listStarred: e=>o("listStarred").then(it((r=>new Promise((o=>{
                const n = r.get().claims.root
                  , s = N(r.get().files, (t=>{
                    const o = yr(t, r.get().files);
                    return a(r.get(), o) && vr(e, o) && br(e, t) && !0 === o.starred ? [o] : []
                }
                ))
                  , l = ft(s, e.sortBy, e.sortOrder)
                  , u = l.slice(e.offset, e.offset + t.limit)
                  , d = e.offset + u.length;
                o(q.value({
                    last: d >= l.length,
                    offset: d,
                    files: i(u, n)
                }))
            }
            ))))),
            search: e=>o("search").then(it((r=>new Promise((o=>{
                const n = r.get().claims.root
                  , s = N(r.get().files, (t=>{
                    const o = yr(t, r.get().files);
                    return a(r.get(), o) && vr(e, o) && br(e, t) && "directory" !== t.type ? [o] : []
                }
                ))
                  , l = ft(s, e.sortBy, e.sortOrder)
                  , u = l.slice(e.offset, e.offset + t.limit)
                  , d = e.offset + u.length;
                o(q.value({
                    last: d >= l.length,
                    offset: d,
                    files: i(u, n)
                }))
            }
            ))))),
            remove: e=>o("remove").then(it((t=>new Promise((r=>{
                dr(t, N(t.get().files, (t=>D(e, t.uuid) ? [] : [t]))),
                r(q.value(e))
            }
            ))))),
            copy: (e,t)=>o("copy").then(it((r=>new Promise((o=>{
                const s = bt();
                dr(r, N(r.get().files, (r=>r.uuid === e ? [r, at(r, {
                    uuid: s,
                    parentUuid: m.from(t)
                })] : [r]))),
                r.get().meta[e] && n(r, s, r.get().meta[e]),
                o(q.value(s))
            }
            ))))),
            move: (e,t)=>o("move").then(it((r=>new Promise((o=>{
                dr(r, E(r.get().files, (r=>D(e, r.uuid) ? at(r, {
                    parentUuid: m.from(t)
                }) : r))),
                o(q.value(e))
            }
            ))))),
            star: e=>o("star").then(it((t=>new Promise((r=>{
                dr(t, E(t.get().files, (t=>D(e, t.uuid) ? at(t, {
                    starred: !0
                }) : t))),
                r(q.value(e))
            }
            ))))),
            unstar: e=>o("unstar").then(it((t=>new Promise((r=>{
                dr(t, E(t.get().files, (t=>D(e, t.uuid) ? at(t, {
                    starred: !1
                }) : t))),
                r(q.value(e))
            }
            ))))),
            setMeta: (e,t)=>o("setMeta").then(it((r=>new Promise((o=>{
                fr(e, r.get().files).fold((()=>o(q.error({
                    type: "error",
                    message: "No file!!"
                }))), (s=>{
                    n(r, e, {
                        description: t.description
                    }),
                    o(q.value(s.uuid))
                }
                ))
            }
            ))))),
            getMeta: e=>o("getMeta").then(it((t=>new Promise((r=>{
                fr(e, t.get().files).fold((()=>r(q.error({
                    type: "error",
                    message: "No file!!"
                }))), (()=>{
                    const o = t.get().meta[e];
                    r(q.value(o || {
                        description: "",
                        createdBy: m.none()
                    }))
                }
                ))
            }
            ))))),
            uploadToPath: e=>o("uploadToPath").then(it((t=>((e,t)=>{
                const r = Tt(e.get().files, ((e,t)=>e.get().claims.root.map((e=>pt(e, t.path))).getOr(t.path))(e, t));
                return dr(e, r.files),
                wr(e, t.blob, t.name, t.thumbBlob, r.parentUuid).then(it(Tr(t.progress)))
            }
            )(t, e))))
        }
    }
      , Or = (e,t)=>t && !/^https?:/.test(t) ? pt(e, t) : t
      , Ur = (e,t)=>{
        const r = {
            Authorization: "Bearer " + t
        };
        return e ? {
            ...e,
            ...r
        } : r
    }
    ;
    var kr;
    !function(e) {
        e.Thumbnail = "thumbnail",
        e.File = "file"
    }(kr || (kr = {}));
    const jr = Pe
      , _r = (e,t,r)=>Vt(e, t, r.data)
      , Pr = Ht([nr("id"), nr("name"), or("size"), nr("type"), nr("mdate"), ir("url"), ar("thumbs", Gt), sr("starred"), ir("path")])
      , Dr = e=>{
        return t = z(e.thumbs),
        r = e.url,
        o = (e,t)=>t + "-" + e,
        t.isSome() && r.isSome() ? m.some(o(t.getOrDie(), r.getOrDie())) : m.none();
        var t, r, o
    }
      , Sr = e=>{
        return {
            uuid: e.id,
            parentUuid: m.none(),
            name: e.name,
            size: e.size,
            type: (r = e.type,
            St(r).getOr("document")),
            modificationDate: (t = e.mdate,
            m.from(/^([0-9]{4})\-([0-9]{2})\-([0-9]{2})T([0-9]{2})\:([0-9]{2})\:([0-9]{2})Z$/.exec(t)).map((e=>{
                const t = E(e.slice(1), (e=>parseInt(e, 10)));
                return new Date(Date.UTC(t[0], t[1] - 1, t[2], t[3], t[4], t[5]))
            }
            ))).getOr(new Date),
            url: e.url,
            thumbUrl: Dr(e),
            starred: e.starred,
            path: e.path
        };
        var t, r
    }
      , Er = (e,t,r,o)=>({
        last: t,
        offset: r,
        files: E(e, Sr)
    })
      , Mr = Ht([rr("file", Pr)])
      , Fr = (e,t)=>{
        const r = ((e,t)=>{
            const r = {}
              , o = {};
            return ((e,t,r,o)=>{
                H(e, ((e,n)=>{
                    (t(e, n) ? r : o)(e, n)
                }
                ))
            }
            )(e, t, W(r), W(o)),
            {
                t: r,
                f: o
            }
        }
        )(K(e, ((e,r)=>t[r](e))), (e=>e.isSome())).t
          , o = K(r, (e=>e.getOrNull()));
        return Pe(o)
    }
      , Cr = Ht([ar("id", Gt)]);
    var Br;
    !function(e) {
        e.Thumbnail = "thumbnail",
        e.File = "file"
    }(Br || (Br = {}));
    const Rr = e=>Fr(e, {
        fileType: m.some,
        parent: T,
        path: T,
        name: m.some,
        size: m.some
    })
      , Nr = Ht([nr("uploadUrl"), nr("blobUrl"), ar("formItems", Ht([nr("name"), nr("value")])), nr("id")])
      , zr = e=>_r("create", Nr, e)
      , Ar = Ht([(Ir = "error",
    qr = [ir("type"), ir("data"), nr("message")],
    tr(Ir, Ir, {
        tag: "required",
        process: {}
    }, Ht(qr)))]);
    var Ir, qr;
    const Lr = Ht([nr("message")])
      , $r = e=>Fr(e, {
        offset: m.some,
        parent: T,
        sortBy: T,
        sortOrder: T,
        query: T,
        fileTypes: m.some
    })
      , Jr = Ht([sr("last"), or("offset"), ar("files", Pr)])
      , Hr = e=>_r("fileListResult", Jr, e)
      , Kr = (e,t)=>Er(t.files, t.last, t.offset)
      , Vr = Ht([nr("id"), nr("description"), ir("createdBy")])
      , Wr = Ht([rr("file", Pr)])
      , Yr = Ht([ar("ids", Gt)])
      , Zr = Ht([ar("ids", Gt)])
      , Xr = Pe
      , Gr = Ht([rr("file", Pr)])
      , Qr = Ht([nr("id")])
      , eo = Pe
      , to = Ht([ar("ids", Gt)])
      , ro = Ht([sr("last"), or("offset"), ar("files", Pr)])
      , oo = Pe
      , no = Ht([ar("ids", Gt)])
      , so = e=>{
        return (t = Pe(e.responseText),
        _r("error", Ar, t).fold((()=>(e=>_r("error", Lr, e).map((e=>({
            error: {
                type: m.none(),
                data: m.none(),
                message: e.message
            }
        }))))(t)), (e=>q.value(e)))).fold((t=>({
            type: "",
            message: "Error: " + e.message + " (" + e.status + ")"
        })), (e=>({
            type: "",
            message: e.error.message
        })));
        var t
    }
      , ao = (e,t)=>pt(e.restApiEndpoint, "/1", t) + "?apiKey=" + encodeURIComponent(e.apiKey)
      , io = (e,t,r)=>{
        var o, n;
        return (o = {
            url: ao(e, t),
            body: r,
            responseType: _e.JSON
        },
        n = e.jwtTokenFactory,
        ((e,t)=>(e=>e(!1))(t).bindFuture((r=>e(r).bind((r=>r.fold(((e,t)=>r=>401 === r.status ? (e=>e(!0))(e).bindFuture(t) : ke(r))(t, e), Ue))))))((e=>Fe({
            ...o,
            headers: Ur(o.headers, e)
        })), n)).toPromise().then((e=>e.fold((e=>q.error(so(e))), (e=>q.value(Pe(e))))))
    }
      , lo = e=>E(e, Dt)
      , uo = (e,t,r)=>io(e, "client/files/commit", jr({
        id: t,
        type: r
    })).then(lt((e=>{
        return (t = e,
        _r("commit", Mr, t)).fold((e=>q.error({
            type: "",
            message: "Could not decode http json response"
        })), (e=>q.value(e)));
        var t
    }
    )))
      , co = (e,t,r,o,n)=>io(e, "client/files/create", Rr({
        fileType: t,
        parent: r,
        path: m.none(),
        name: o,
        size: n
    })).then(lt((e=>zr(e).fold((e=>q.error({
        type: "",
        message: "Could not decode http json response"
    })), (e=>q.value(e))))))
      , po = (e,t,r,o,n)=>{
        const s = (a = t.formItems,
        i = C(a, ((e,t)=>(e[t.name] = t.value,
        e)), {}),
        {
            type: _e.MultipartFormData,
            data: i
        });
        var a, i;
        return s.data.file = o,
        Fe({
            url: t.uploadUrl,
            body: s,
            responseType: _e.Text,
            progress: (e,o)=>n({
                loaded: e,
                total: o,
                name: r,
                uuid: t.id
            })
        }).toPromise().then((e=>e.fold((e=>q.error(so(e))), (e=>q.value(t.id)))))
    }
      , mo = (e,t,r)=>o=>t.fold((()=>Promise.resolve(q.value(o))), (t=>((e,t,r,o)=>co(e, Br.Thumbnail, m.from(o), r, t.size).then(it((e=>po(0, e, r, t, v)))).then(it((t=>uo(e, t, kr.Thumbnail)))).then(lt((e=>q.value(e.file.id)))))(e, t, r, o.uuid).then((e=>q.value(o)))))
      , ho = e=>({
        rename: (t,r)=>((e,t,r)=>io(e, "client/files/rename", Xr({
            id: t,
            name: r
        })).then(lt((e=>{
            return (r = e,
            _r("rename", Gr, r)).fold((e=>q.error({
                type: "",
                message: "Could not decode http json response"
            })), (()=>q.value(t)));
            var r
        }
        ))))(e, t, r),
        mkdir: (t,r)=>((e,t,r)=>{
            return io(e, "client/files/mkdir", (o = {
                parent: t,
                name: r
            },
            Fr(o, {
                parent: T,
                name: m.some
            }))).then(lt((e=>{
                return (t = e,
                _r("mkdir", Wr, t)).fold((e=>q.error({
                    type: "",
                    message: "Could not decode http json response"
                })), (e=>q.value(e.file.id)));
                var t
            }
            )));
            var o
        }
        )(e, m.from(r), t),
        upload: t=>((e,t,r,o,n)=>co(e, Br.File, n, r, t.size).then(it((n=>po(0, n, r, t, o).then(it((t=>uo(e, t, kr.File)))).then(lt((e=>q.value(Sr(e.file)))))))))(e, t.blob, t.name, t.progress, t.parent).then(it(mo(e, t.thumbBlob, t.name))),
        list: t=>((e,t,r)=>io(e, "client/files/list", $r({
            offset: t.offset,
            parent: t.parentUuid,
            sortBy: m.some(t.sortBy),
            sortOrder: m.some(t.sortOrder),
            query: t.query,
            fileTypes: lo(t.fileTypes)
        })).then(lt((e=>Hr(e).fold((e=>q.error({
            type: "",
            message: "Could not decode http json response"
        })), (e=>q.value(Kr(m.none(), e))))))))(e, t),
        listStarred: t=>((e,t,r)=>{
            return io(e, "client/files/stars", (o = {
                offset: t.offset,
                sortBy: m.some(t.sortBy),
                sortOrder: m.some(t.sortOrder),
                query: t.query,
                fileTypes: lo(t.fileTypes)
            },
            Fr(o, {
                offset: m.some,
                sortBy: T,
                sortOrder: T,
                query: T,
                fileTypes: m.some
            }))).then(lt((e=>{
                return (t = e,
                _r("starsResult", ro, t)).fold((e=>q.error({
                    type: "",
                    message: "Could not decode http json response"
                })), (e=>{
                    return q.value((m.none(),
                    Er((t = e).files, t.last, t.offset)));
                    var t
                }
                ));
                var t
            }
            )));
            var o
        }
        )(e, t),
        search: t=>((e,t,r)=>io(e, "client/files/search", $r({
            offset: t.offset,
            parent: m.none(),
            sortBy: m.some(t.sortBy),
            sortOrder: m.some(t.sortOrder),
            query: t.query,
            fileTypes: lo(t.fileTypes)
        })).then(lt((e=>Hr(e).fold((e=>q.error({
            type: "",
            message: "Could not decode http json response"
        })), (e=>q.value(Kr(m.none(), e))))))))(e, t),
        remove: t=>((e,t)=>{
            return io(e, "client/files/delete", (r = {
                ids: t
            },
            Fr(r, {
                ids: m.some
            }))).then(lt((e=>{
                return (r = e,
                _r("remove", Zr, r)).fold((e=>q.error({
                    type: "",
                    message: "Could not decode http json response"
                })), (()=>q.value(t)));
                var r
            }
            )));
            var r
        }
        )(e, t),
        copy: (t,r)=>((e,t,r)=>{
            return io(e, "client/files/copy", (o = {
                id: t,
                parent: r
            },
            Fr(o, {
                parent: T,
                id: m.some
            }))).then(lt((e=>{
                return (r = e,
                _r("copy", Cr, r)).fold((e=>q.error({
                    type: "",
                    message: "Could not decode http json response"
                })), (()=>q.value(t)));
                var r
            }
            )));
            var o
        }
        )(e, t, m.from(r)),
        move: (t,r)=>((e,t,r)=>{
            return io(e, "client/files/move", (o = {
                ids: t,
                parent: r
            },
            Fr(o, {
                parent: T,
                ids: m.some
            }))).then(lt((e=>{
                return (r = e,
                _r("move", Yr, r)).fold((e=>q.error({
                    type: "",
                    message: "Could not decode http json response"
                })), (()=>q.value(t)));
                var r
            }
            )));
            var o
        }
        )(e, t, m.from(r)),
        star: t=>((e,t)=>io(e, "client/files/star", eo({
            ids: t
        })).then(lt((e=>{
            return (r = e,
            _r("star", to, r)).fold((e=>q.error({
                type: "",
                message: "Could not decode http json response"
            })), (()=>q.value(t)));
            var r
        }
        ))))(e, t),
        unstar: t=>((e,t)=>io(e, "client/files/unstar", oo({
            ids: t
        })).then(lt((e=>{
            return (r = e,
            _r("unstar", no, r)).fold((e=>q.error({
                type: "",
                message: "Could not decode http json response"
            })), (()=>q.value(t)));
            var r
        }
        ))))(e, t),
        setMeta: (t,r)=>((e,t,r)=>{
            return io(e, "client/files/setMeta", (o = {
                id: t,
                description: r.description
            },
            Fr(o, {
                id: m.some,
                description: m.some
            }))).then(lt((e=>{
                return (r = e,
                _r("setFileMeta", Qr, r)).fold((e=>q.error({
                    type: "",
                    message: "Could not decode http json response"
                })), (e=>q.value(t)));
                var r
            }
            )));
            var o
        }
        )(e, t, r),
        getMeta: t=>((e,t)=>{
            return io(e, "client/files/getMeta", (r = {
                id: t
            },
            Fr(r, {
                id: m.some
            }))).then(lt((e=>{
                return (t = e,
                _r("getFileMeta", Vr, t)).fold((e=>q.error({
                    type: "",
                    message: "Could not decode http json response"
                })), (e=>q.value({
                    description: e.description,
                    createdBy: e.createdBy
                })));
                var t
            }
            )));
            var r
        }
        )(e, t),
        uploadToPath: t=>((e,t,r,o,n)=>((e,t,r,o,n)=>io(e, "client/files/create", Rr({
            fileType: t,
            parent: m.none(),
            path: m.some(r),
            name: o,
            size: n
        })).then(lt((e=>zr(e).fold((e=>q.error({
            type: "",
            message: "Could not decode http json response"
        })), (e=>q.value(e)))))))(e, Br.File, n, r, t.size).then(it((n=>po(0, n, r, t, o).then(it((t=>uo(e, t, kr.File)))).then(lt((e=>q.value(Sr(e.file)))))))))(e, t.blob, t.name, t.progress, t.path).then(it(mo(e, t.thumbBlob, t.name)))
    })
      , fo = e=>{
        const t = e.jwtTokenFactory;
        return e.demoFilesUrl.fold((()=>e.demoFiles.fold((()=>((e,t,r)=>{
            const o = t.getOrDie("Failed to get service url")
              , n = r.getOrDie("Failed to get api key");
            return ho({
                jwtTokenFactory: e,
                restApiEndpoint: o,
                apiKey: n
            })
        }
        )(t, e.serviceUrl, e.apiKey)), (e=>((e,t)=>xr({
            jwtTokenFactory: e,
            requestDelay: 0,
            log: !1,
            limit: 30
        }, Promise.resolve(q.value(t))))(t, e)))), (e=>((e,t)=>((e,t)=>{
            const r = (o = {
                url: t,
                responseType: _e.JSON
            },
            Me({
                ...o,
                method: "get",
                body: {
                    type: _e.Text,
                    data: ""
                }
            })).toPromise().then((e=>e.fold((e=>q.error({
                type: "",
                message: "fs error"
            })), (e=>{
                return q.value((r = ct(t).replace(/\/[^\/]*\/?$/, ""),
                o = e.files,
                E(o, (e=>({
                    ...e,
                    url: Or(r, e.url),
                    thumbUrl: Or(r, e.thumbUrl)
                })))));
                var r, o
            }
            ))));
            var o;
            return xr(e, r)
        }
        )({
            jwtTokenFactory: e,
            requestDelay: 0,
            log: !1,
            limit: 30
        }, t))(t, e)))
    }
      , go = e=>"media" === e ? ["directory", "video", "audio"] : "image" === e ? ["directory", "image"] : []
      , yo = (e,t)=>{
        const r = We(t)
          , o = Ye(t)
          , n = Ze(t)
          , s = Xe(t);
        return {
            close: !0,
            insert: !0,
            fullscreen: !1,
            target: m.none(),
            fileTypes: [],
            zIndex: 65536,
            maxImageDimension: r,
            dropboxAppKey: o,
            googleDriveDeveloperKey: n,
            googleDriveClientId: s,
            baseUrl: e
        }
    }
      , vo = (e,t)=>{
        return r = {
            js: Je(e),
            css: tt(e, t)
        },
        Promise.all([he(X(L, "tinymce").or(X(L, "tinydrive")).getOrThunk((()=>{
            const e = {};
            return L.tinydrive = e,
            e
        }
        )), "_assetManagerProvider", r.js), me(r.css)]).then((([e,t])=>t.bind(w(e))));
        var r
    }
      , bo = (e,t,r,o)=>new Promise((n=>{
        vo(e, t).then((s=>{
            s.fold((e=>{
                console.error(e)
            }
            ), (s=>{
                let a = v;
                a = s(r, ((e,t)=>m.from(t.filetype).map(go).fold(w(e), (t=>({
                    ...e,
                    fileTypes: t
                }))))(yo(t, e), o), (e=>{
                    a(),
                    n(e)
                }
                ))
            }
            ))
        }
        ))
    }
    ))
      , wo = (e,t,r)=>{
        bo(e, t, r, {
            filetype: ""
        }).then((t=>{
            M(t, (t=>((e,t)=>{
                t.url.each((r=>{
                    var o;
                    e.insertContent((o = t.name,
                    ((e,t,r=x)=>e.exists((e=>r(e, t))))(Pt(o), "image") ? ((e,t)=>e.dom.createHTML("img", {
                        src: t
                    }))(e, r) : ((e,t,r)=>e.dom.createHTML("a", {
                        href: t
                    }, e.dom.encode(r.name)))(e, r, t)))
                }
                ))
            }
            )(e, t)))
        }
        ))
    }
      , To = (e,t)=>Uo(document.createElement("canvas"), e, t)
      , xo = e=>{
        const t = To(e.width, e.height);
        return Oo(t).drawImage(e, 0, 0),
        t
    }
      , Oo = e=>e.getContext("2d")
      , Uo = (e,t,r)=>(e.width = t,
    e.height = r,
    e)
      , ko = e=>e.naturalWidth || e.width
      , jo = e=>e.naturalHeight || e.height
      , _o = e=>{
        const t = URL.createObjectURL(e)
          , r = new Image;
        return r.src = t,
        (o = te(r),
        new Promise(((e,t)=>{
            const r = ()=>{
                s(),
                e(o)
            }
              , n = [de(o, "load", r), de(o, "error", (()=>{
                s(),
                t("Unable to load data from image: " + o.dom.src)
            }
            ))]
              , s = ()=>M(n, (e=>e.unbind()));
            o.dom.complete && r()
        }
        ))).then((e=>e.dom));
        var o
    }
      , Po = (e,t,r)=>{
        return t = t || "image/png",
        c(HTMLCanvasElement.prototype.toBlob) ? new Promise(((o,n)=>{
            e.toBlob((e=>{
                e ? o(e) : n()
            }
            ), t, r)
        }
        )) : (o = e.toDataURL(t, r),
        new Promise(((e,t)=>{
            (e=>{
                const t = e.split(",")
                  , r = /data:([^;]+)/.exec(t[0]);
                if (!r)
                    return m.none();
                const o = r[1]
                  , n = t[1]
                  , s = 1024
                  , a = atob(n)
                  , i = a.length
                  , l = Math.ceil(i / s)
                  , u = new Array(l);
                for (let e = 0; e < l; ++e) {
                    const t = e * s
                      , r = Math.min(t + s, i)
                      , o = new Array(r - t);
                    for (let e = t, n = 0; e < r; ++n,
                    ++e)
                        o[n] = a[e].charCodeAt(0);
                    u[e] = new Uint8Array(o)
                }
                return m.some(new Blob(u,{
                    type: o
                }))
            }
            )(o).fold((()=>{
                t("uri is not base64: " + o)
            }
            ), e)
        }
        )));
        var o
    }
      , Do = (e,t,r)=>{
        const o = t.type
          , n = w(o)
          , s = w(r)
          , a = (t,r)=>e.then((e=>((e,t,r)=>(t = t || "image/png",
        e.toDataURL(t, r)))(e, t, r)));
        return {
            getType: n,
            toBlob: ()=>Promise.resolve(t),
            toDataURL: s,
            toBase64: ()=>r.split(",")[1],
            toAdjustedBlob: (t,r)=>e.then((e=>Po(e, t, r))),
            toAdjustedDataURL: a,
            toAdjustedBase64: (e,t)=>a(e, t).then((e=>e.split(",")[1])),
            toCanvas: ()=>e.then(xo)
        }
    }
      , So = e=>(e=>new Promise((t=>{
        const r = new FileReader;
        r.onloadend = ()=>{
            t(r.result)
        }
        ,
        r.readAsDataURL(e)
    }
    )))(e).then((t=>Do((e=>_o(e).then((e=>{
        (e=>{
            URL.revokeObjectURL(e.src)
        }
        )(e);
        const t = To(ko(e), jo(e));
        return Oo(t).drawImage(e, 0, 0),
        t
    }
    )))(e), e, t)))
      , Eo = e=>So(e);
    (e=>{
        if (!l(e))
            throw new Error("cases must be an array");
        if (0 === e.length)
            throw new Error("there must be at least one case");
        const t = []
          , r = {};
        M(e, ((o,n)=>{
            const s = $(o);
            if (1 !== s.length)
                throw new Error("one and only one name per case");
            const a = s[0]
              , i = o[a];
            if (void 0 !== r[a])
                throw new Error("duplicate key detected:" + a);
            if ("cata" === a)
                throw new Error("cannot have a case named cata (sorry)");
            if (!l(i))
                throw new Error("case arguments must be an array");
            t.push(a),
            r[a] = (...r)=>{
                const o = r.length;
                if (o !== i.length)
                    throw new Error("Wrong number of arguments to case " + a + ". Expected " + i.length + " (" + i + "), got " + o);
                return {
                    fold: (...t)=>{
                        if (t.length !== e.length)
                            throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                        return t[n].apply(null, r)
                    }
                    ,
                    match: e=>{
                        const o = $(e);
                        if (t.length !== o.length)
                            throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + o.join(","));
                        if (!((e,t)=>{
                            for (let t = 0, n = e.length; t < n; ++t)
                                if (!0 !== (r = e[t],
                                D(o, r)))
                                    return !1;
                            var r;
                            return !0
                        }
                        )(t))
                            throw new Error("Not all branches were specified when using match. Specified: " + o.join(", ") + "\nRequired: " + t.join(", "));
                        return e[a].apply(null, r)
                    }
                    ,
                    log: e=>{
                        console.log(e, {
                            constructors: t,
                            constructor: a,
                            params: r
                        })
                    }
                }
            }
        }
        ))
    }
    )([{
        bothErrors: ["error1", "error2"]
    }, {
        firstError: ["error1", "value2"]
    }, {
        secondError: ["value1", "error2"]
    }, {
        bothValues: ["value1", "value2"]
    }]);
    const Mo = (e,t,r)=>{
        const o = ko(e)
          , n = jo(e);
        let s = t / o
          , a = r / n
          , i = !1;
        (s < .5 || s > 2) && (s = s < .5 ? .5 : 2,
        i = !0),
        (a < .5 || a > 2) && (a = a < .5 ? .5 : 2,
        i = !0);
        const l = Fo(e, s, a);
        return i ? l.then((e=>Mo(e, t, r))) : l
    }
      , Fo = (e,t,r)=>new Promise((o=>{
        const n = ko(e)
          , s = jo(e)
          , a = Math.floor(n * t)
          , i = Math.floor(s * r)
          , l = To(a, i);
        Oo(l).drawImage(e, 0, 0, n, s, 0, 0, a, i),
        o(l)
    }
    ))
      , Co = (e,t)=>Eo(e).then((e=>((e,t,r)=>((e,t,r)=>e.toCanvas().then((o=>Mo(o, t, r).then((t=>((e,t)=>Po(e, t).then((t=>Do(Promise.resolve(e), t, e.toDataURL()))))(t, e.getType()))))))(e, t, r))(e, t.width, t.height))).then((t=>t.toAdjustedBlob(e.type, 9)))
      , Bo = ["image/jpeg", "image/png", "image/gif", "image/webp", "image/apng"]
      , Ro = (e,t)=>Math.max(e.width / t.width, e.height / t.height)
      , No = (e,t)=>(e=>(e=>_o(e))(e).then((e=>{
        const t = e.naturalWidth
          , r = e.naturalHeight;
        return URL.revokeObjectURL(e.src),
        {
            width: t,
            height: r
        }
    }
    )))(e).then((r=>Ro(r, t) > 1 ? Co(e, ((e,t)=>{
        const r = Ro(e, t);
        return {
            width: Math.round(e.width / r),
            height: Math.round(e.height / r)
        }
    }
    )(r, t)) : Promise.resolve(e)))
      , zo = e=>Eo(e).then((e=>e.toBlob()))
      , Ao = (e,t)=>(e=>D(Bo, e.type))(e) ? ((e,t)=>((e,t)=>t.map((t=>No(e, {
        width: t,
        height: t
    }))).getOrThunk((()=>Promise.resolve(e))).then(zo).then((e=>No(e, {
        width: 512,
        height: 512
    }).then((t=>q.value({
        blob: e,
        thumbBlob: m.some(t)
    }))))))(e, t).then(ut(gt)))(e, t) : Promise.resolve(q.value({
        blob: e,
        thumbBlob: m.none()
    }))
      , Io = e=>Ao(e.blob, e.maxImageDimension).then(it((t=>e.fs.uploadToPath({
        blob: t.blob,
        thumbBlob: t.thumbBlob,
        name: e.name,
        progress: e.progress,
        path: e.path
    }))))
      , qo = Ht([(Ko = Gt,
    lr("filetypes", [], Kt(Ko)))])
      , Lo = Ht([lr("path", "/", Gt), nr("name"), (e=>tr(e, e, {
        tag: "required",
        process: {}
    }, Yt()))("blob"), ((e,t)=>lr("onprogress", t, er))(0, v), tr("max_image_dimension", "maxImageDimension", {
        tag: "option",
        process: {}
    }, Xt)])
      , $o = (e,t)=>{
        let r = String(e);
        if (r.length < t)
            for (let e = 0; e < t - r.length; e++)
                r = "0" + r;
        return r
    }
      , Jo = e=>e.url.map((t=>{
        return {
            name: e.name,
            url: t,
            size: e.size,
            type: Dt(e.type),
            mdate: (r = e.modificationDate,
            ((e,t)=>{
                const r = "Sun Mon Tue Wed Thu Fri Sat Sun".split(" ")
                  , o = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(" ")
                  , n = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
                  , s = "January February March April May June July August September October November December".split(" ");
                return (e = (e = (e = (e = (e = (e = (e = (e = (e = (e = (e = (e = (e = (e = e.replace("%D", "%m/%d/%Y")).replace("%r", "%I:%M:%S %p")).replace("%Y", "" + t.getFullYear())).replace("%m", $o(t.getMonth() + 1, 2))).replace("%d", $o(t.getDate(), 2))).replace("%H", "" + $o(t.getHours(), 2))).replace("%M", "" + $o(t.getMinutes(), 2))).replace("%S", "" + $o(t.getSeconds(), 2))).replace("%I", "" + ((t.getHours() + 11) % 12 + 1))).replace("%p", t.getHours() < 12 ? "AM" : "PM")).replace("%B", "" + s[t.getMonth()])).replace("%b", "" + n[t.getMonth()])).replace("%A", "" + o[t.getDay()])).replace("%a", "" + r[t.getDay()])).replace("%%", "%")
            }
            )("%Y-%m-%dT%H:%M:%SZ", (e=>new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds(),e.getUTCMilliseconds()))(r)))
        };
        var r
    }
    ))
      , Ho = (e,t,r,o,n)=>Promise.resolve((e=>Vt("picker settings", qo, e).mapError(Wt))(o)).then(it((o=>((e,t,r,o)=>new Promise((n=>{
        vo(e, t).then((e=>{
            e.fold((e=>n(q.error(e))), (e=>{
                let t = v;
                t = e(r, o, (e=>{
                    t(),
                    n(q.value(e))
                }
                ))
            }
            ))
        }
        ))
    }
    )))(e, t, r, {
        ...yo(t, e),
        fileTypes: Et(o.filetypes),
        insert: n
    })))).then(lt((e=>q.value({
        files: mt(E(e, Jo))
    }))));
    var Ko;
    tinymce.PluginManager.add("tinydrive", ((t,r)=>{
        if (((e,t)=>!!e && -1 === ((e,t)=>{
            const r = f(e.major, t.major);
            if (0 !== r)
                return r;
            const o = f(e.minor, t.minor);
            if (0 !== o)
                return o;
            const n = f(e.patch, t.patch);
            return 0 !== n ? n : 0
        }
        )((e=>y((e=>[e.majorVersion, e.minorVersion].join(".").split(".").slice(0, 3).join("."))(e)))(e), y(t)))(tinymce, "6.0.0"))
            return console.error("The tinydrive plugin requires at least version 6.0.0 of TinyMCE."),
            {};
        ((e,t)=>{
            const r = e.options.register;
            var o;
            r("tinydrive_api_key", {
                processor: "string"
            }),
            r("tinydrive_script_url", {
                processor: "string",
                default: t + "/assetmanager.min.js"
            }),
            r("tinydrive_demo_files_url", {
                processor: "string"
            }),
            r("tinydrive_demo_files", {
                processor: "object[]"
            }),
            r("tinydrive_service_url", {
                processor: "string"
            }),
            r("tinydrive_max_image_dimension", {
                processor: "number"
            }),
            r("tinydrive_dropbox_app_key", {
                processor: "string"
            }),
            r("tinydrive_google_drive_key", {
                processor: "string"
            }),
            r("tinydrive_google_drive_client_id", {
                processor: "string"
            }),
            r("tinydrive_css_url", {
                processor: "string"
            }),
            r("tinydrive_skin", {
                processor: e=>s(e) && Ie(e)
            }),
            r("tinydrive_token_provider", {
                processor: e=>s(e) || c(e)
            }),
            r("tinydrive_upload_path", {
                processor: "string",
                default: (o = "/uploads",
                ((e,t)=>{
                    return r = `${e.getFullYear()}${fe(e.getMonth() + 1)}${fe(e.getDate())}`,
                    t.replace(/\/$/, "") + "/" + r.replace(/^\//, "");
                    var r
                }
                )(new Date, o))
            })
        }
        )(t, r);
        const o = ((e,t)=>fo({
            demoFilesUrl: He(e),
            demoFiles: Ke(e),
            jwtTokenFactory: rt(e, t),
            serviceUrl: Ve(e),
            apiKey: $e(e)
        }))(t, e(m.none()))
          , n = (e=>{
            const t = {};
            return e.on("PreInit", (()=>{
                e.editorUpload.addFilter && e.editorUpload.addFilter((e=>!1 === t.hasOwnProperty(e.src)))
            }
            )),
            e=>{
                t[e] = !0
            }
        }
        )(t);
        return ((e,t,r)=>{
            const o = e.options;
            if (!o.isSet("images_upload_handler")) {
                const n = ot(e);
                o.set("images_upload_handler", ((e,t,r,o)=>(n,s)=>{
                    const a = c(s) ? e=>s(Math.round(e.total / e.loaded * 100)) : v;
                    return Io({
                        fs: e,
                        path: t,
                        name: n.filename(),
                        blob: n.blob(),
                        progress: a,
                        maxImageDimension: o
                    }).then((e=>e.fold((e=>Promise.reject(e.message)), (e=>e.url.fold((()=>Promise.reject("Failed to get upload url")), (e=>(r(e),
                    Promise.resolve(e))))))))
                }
                )(t, n, r, We(e)))
            }
        }
        )(t, o, n),
        ((e,t,r)=>{
            e.ui.registry.addButton("insertfile", {
                icon: "browse",
                tooltip: "Insert file",
                onAction: ()=>wo(e, t, r)
            })
        }
        )(t, r, o),
        ((e,t,r)=>{
            e.ui.registry.addMenuItem("insertfile", {
                icon: "browse",
                text: "File",
                onAction: ()=>wo(e, t, r)
            })
        }
        )(t, r, o),
        ((e,t,r)=>{
            const o = e.options;
            o.isSet("file_picker_callback") || o.set("file_picker_callback", ((o,n,s)=>{
                bo(e, t, r, s).then((e=>{
                    z(e).each((e=>{
                        e.url.each((t=>o(t, {
                            title: e.name,
                            text: e.name
                        })))
                    }
                    ))
                }
                ))
            }
            ))
        }
        )(t, r, o),
        ((e,t,r)=>({
            pick: o=>dt(Ho(e, t, r, o, !0)),
            browse: o=>dt(Ho(e, t, r, o, !1)).then(v),
            upload: t=>dt(((e,t,r)=>Promise.resolve((e=>Vt("upload settings", Lo, e).mapError(Wt))(r)).then(it((r=>{
                return Io({
                    fs: t,
                    path: r.path,
                    name: r.name,
                    blob: r.blob,
                    progress: (o = r.onprogress,
                    ({loaded: e, total: t})=>{
                        o({
                            loaded: e,
                            total: t
                        })
                    }
                    ),
                    maxImageDimension: r.maxImageDimension.or(We(e))
                }).then(lt((e=>q.fromOption(Jo(e).map((e=>({
                    file: e
                }))), gt("Failed to get upload file"))))).then(ut((e=>e.message)));
                var o
            }
            ))))(e, r, t))
        }))(t, r, o)
    }
    ))
}();
