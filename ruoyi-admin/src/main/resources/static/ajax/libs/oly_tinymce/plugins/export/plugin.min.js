/*!
 * Tiny Export plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 2.0.1-51
 */

!function() {
    "use strict";
    const e = e=>parseInt(e, 10)
      , t = (e,t)=>{
        const r = e - t;
        return 0 === r ? 0 : r > 0 ? 1 : -1
    }
      , r = (e,t,r)=>({
        major: e,
        minor: t,
        patch: r
    })
      , o = t=>{
        const o = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(t);
        return o ? r(e(o[1]), e(o[2]), e(o[3])) : r(0, 0, 0)
    }
      , n = e=>t=>(e=>{
        const t = typeof e;
        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && (r = o = e,
        (n = String).prototype.isPrototypeOf(r) || (null === (s = o.constructor) || void 0 === s ? void 0 : s.name) === n.name) ? "string" : t;
        var r, o, n, s
    }
    )(t) === e
      , s = e=>t=>typeof t === e
      , i = n("string")
      , a = n("array")
      , l = s("boolean")
      , c = (void 0,
    e=>undefined === e);
    const u = e=>!(e=>null == e)(e)
      , d = s("function")
      , m = s("number")
      , p = e=>()=>e;
    function h(e, ...t) {
        return (...r)=>{
            const o = t.concat(r);
            return e.apply(null, o)
        }
    }
    const g = p(!1);
    class y {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new y(!0,e)
        }
        static none() {
            return y.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? y.some(e(this.value)) : y.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : y.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : y.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return u(e) ? y.some(e) : y.none()
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    y.singletonNone = new y(!1);
    const f = Array.prototype.indexOf
      , v = (e,t)=>{
        const r = e.length
          , o = new Array(r);
        for (let n = 0; n < r; n++) {
            const r = e[n];
            o[n] = t(r, n)
        }
        return o
    }
      , _ = (e,t)=>{
        for (let r = 0, o = e.length; r < o; r++)
            t(e[r], r)
    }
      , x = (e,t)=>((e,t,r)=>{
        for (let o = 0, n = e.length; o < n; o++) {
            const n = e[o];
            if (t(n, o))
                return y.some(n);
            if (r(n, o))
                break
        }
        return y.none()
    }
    )(e, t, g)
      , b = Object.keys
      , w = Object.hasOwnProperty
      , P = (e,t)=>{
        const r = b(e);
        for (let o = 0, n = r.length; o < n; o++) {
            const n = r[o];
            t(e[n], n)
        }
    }
      , k = (e,t,r=!1)=>new Promise((o=>{
        const n = new XMLHttpRequest;
        n.onreadystatechange = ()=>{
            4 === n.readyState && o({
                status: n.status,
                blob: n.response
            })
        }
        ,
        n.open("GET", e, !0),
        n.withCredentials = r,
        P(t, ((e,t)=>{
            n.setRequestHeader(t, e)
        }
        )),
        n.responseType = "blob",
        n.send()
    }
    ))
      , R = [{
        code: 404,
        message: "Could not find Image Proxy"
    }, {
        code: 403,
        message: "Rejected request"
    }, {
        code: 0,
        message: "Incorrect Image Proxy URL"
    }]
      , j = [{
        type: "not_found",
        message: "Failed to load image."
    }, {
        type: "key_missing",
        message: "The request did not include an api key."
    }, {
        type: "key_not_found",
        message: "The provided api key could not be found."
    }, {
        type: "domain_not_trusted",
        message: "The api key is not valid for the request origins."
    }]
      , O = e=>{
        const t = (e=>"ImageProxy HTTP error: " + x(R, (t=>e === t.code)).fold(p("Unknown ImageProxy error"), (e=>e.message)))(e);
        return Promise.reject(t)
    }
      , I = e=>x(j, (t=>t.type === e)).fold(p("Unknown service error"), (e=>e.message))
      , S = e=>{
        const t = (e=>{
            try {
                return y.some(JSON.parse(e))
            } catch (e) {
                return y.none()
            }
        }
        )(e);
        return "ImageProxy Service error: " + t.bind((e=>((e,t)=>{
            const r = (o = (e,t)=>u(e) ? e[t] : void 0,
            n = e,
            _(t, ((e,t)=>{
                n = o(n, e)
            }
            )),
            n);
            var o, n;
            return y.from(r)
        }
        )(e, ["error", "type"]).map(I))).getOr("Invalid JSON in service error message")
    }
      , C = e=>e < 200 || e >= 300
      , T = (e,t)=>{
        const r = {
            "Content-Type": "application/json;charset=UTF-8",
            "tiny-api-key": t
        };
        return k(((e,t)=>{
            const r = -1 === e.indexOf("?") ? "?" : "&";
            return /[?&]apiKey=/.test(e) ? e : e + r + "apiKey=" + encodeURIComponent(t)
        }
        )(e, t), r).then((e=>{
            return C(e.status) ? ((e,t)=>"application/json" === (null == t ? void 0 : t.type) && (400 === e || 403 === e || 404 === e || 500 === e))(t = e.status, r = e.blob) ? (e=>(e=>new Promise(((t,r)=>{
                const o = new FileReader;
                o.onload = ()=>{
                    t(o.result)
                }
                ,
                o.onerror = e=>{
                    r(e)
                }
                ,
                o.readAsText(e)
            }
            )))(e).then((e=>{
                const t = S(e);
                return Promise.reject(t)
            }
            )))(r) : O(t) : Promise.resolve(e.blob);
            var t, r
        }
        ))
    }
      , U = e=>t=>t.options.get(e)
      , A = e=>{
        return "clientpdf" === e ? "PDF" : "" === (t = e) ? "" : t.charAt(0).toUpperCase() + t.substring(1);
        var t
    }
      , E = U("export_formats")
      , N = U("export_ignore_elements")
      , F = U("export_image_proxy_max_in_flight")
      , L = U("content_style")
      , M = U("content_css_cors")
      , q = e=>new Promise((t=>{
        const r = new FileReader;
        r.onload = ()=>{
            t(r.result)
        }
        ,
        r.readAsDataURL(e)
    }
    ))
      , B = (e,t)=>y.from((e=>{
        const t = e.options.get("export_image_proxy_service_url");
        return i(t) ? t + "/2/image" : e.options.get("export_image_proxy")
    }
    )(e)).map((r=>{
        const o = (e=>{
            var t;
            return null !== (t = e.options.get("export_api_key")) && void 0 !== t ? t : e.options.get("api_key")
        }
        )(e)
          , n = {}
          , s = tinymce.html.DomParser({}, e.schema);
        s.addNodeFilter("img", (t=>{
            _(t, (t=>{
                const r = t.attr("src");
                if (c(r))
                    return;
                const o = e.documentBaseURI.toAbsolute(r);
                var s, i;
                ((e,t)=>0 === t.indexOf("data:") || 0 === t.indexOf("blob:") || new tinymce.util.URI(t).host === e.documentBaseURI.host)(e, o) || ((e,t)=>{
                    return r = (e=>{
                        var t, r;
                        return null !== (r = null !== (t = e.options.get("export_cors_hosts")) && void 0 !== t ? t : e.options.get("editimage_cors_hosts")) && void 0 !== r ? r : []
                    }
                    )(e),
                    o = new tinymce.util.URI(t).host,
                    ((e,t)=>f.call(e, t))(r, o) > -1;
                    var r, o
                }
                )(e, o) || (s = n,
                i = r,
                ((e,t)=>w.call(e, t))(s, i) ? y.from(s[i]) : y.none()).fold((()=>n[o] = [t]), (e=>n[r] = e.concat(t)))
            }
            ))
        }
        ));
        const i = s.parse(t, {
            forced_root_block: !1,
            isRootContent: !0
        })
          , a = ((e,t)=>{
            const r = []
              , o = ()=>{
                y.from(r.shift()).fold((()=>e += 1), (e=>setTimeout(e, 0)))
            }
            ;
            return (...n)=>(0 === e ? new Promise((e=>r.push(e))) : (e -= 1,
            Promise.resolve())).then((()=>t(...n))).then((e=>(o(),
            e)), (e=>(o(),
            Promise.reject(e))))
        }
        )(F(e), (t=>((e,t,r=!1)=>t ? T(e, t) : ((e,t)=>k(e, {}, t).then((e=>C(e.status) ? O(e.status) : Promise.resolve(e.blob))))(e, r))(((e,t)=>e + (-1 === e.indexOf("?") ? "?" : "&") + "url=" + encodeURIComponent(t))(r, t), o, !1).then(q, (t=>(e.notificationManager.open({
            type: "error",
            text: t
        }),
        tinymce.Env.transparentSrc)))));
        return Promise.all(v(b(n), (e=>a(e).then((t=>({
            orig: e,
            base64: t
        })))))).then((t=>(_(t, (e=>{
            _(n[e.orig], (t=>{
                t.attr("src", e.base64)
            }
            ))
        }
        )),
        tinymce.html.Serializer({
            validate: !0
        }, e.schema).serialize(i))))
    }
    )).getOrThunk((()=>Promise.resolve(t)))
      , D = e=>{
        const t = e.getContent();
        return ((e,t,r)=>{
            if (r.length <= 0)
                return t;
            const o = tinymce.html.DomParser({}, e.schema);
            o.addNodeFilter(r.join(","), (e=>{
                _(e, (e=>e.remove()))
            }
            ));
            const n = o.parse(t, {
                forced_root_block: !1,
                isRootContent: !0
            });
            return tinymce.html.Serializer({
                validate: !0
            }, e.schema).serialize(n)
        }
        )(e, t, N(e))
    }
      , $ = e=>{
        const t = e.dom.encode
          , r = M(e) ? 'crossorigin="anonymous"' : ""
          , o = y.from(L(e)).map((e=>`<style type="text/css">${e}</style>`));
        return v(e.contentCSS, (o=>`<link type="text/css" rel="stylesheet" href="${t(e.documentBaseURI.toAbsolute(o))}" ${r}>`)).concat(o.toArray()).join("\n")
    }
    ;
    "undefined" != typeof window ? window : Function("return this;")();
    const z = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , H = (e,t)=>{
        const r = (t || document).createElement(e);
        return z(r)
    }
      , V = z
      , K = (e,t)=>{
        const r = URL.createObjectURL(t)
          , o = H("a");
        var n;
        ((e,t)=>{
            const r = e.dom;
            P(t, ((e,t)=>{
                ((e,t,r)=>{
                    if (!(i(r) || l(r) || m(r)))
                        throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", r, ":: Element ", e),
                        new Error("Attribute value was not simple");
                    e.setAttribute(t, r + "")
                }
                )(r, t, e)
            }
            ))
        }
        )(o, {
            download: e,
            href: r
        }),
        ((e,t,r)=>{
            ((e,t,r)=>{
                if (!i(r))
                    throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", r, ":: Element ", e),
                    new Error("CSS value must be a string: " + r);
                (e=>void 0 !== e.style && d(e.style.getPropertyValue))(e) && e.style.setProperty(t, r)
            }
            )(e.dom, "display", "none")
        }
        )(o),
        n = o,
        (e=>{
            const t = e.dom.body;
            if (null == t)
                throw new Error("Body is not available yet");
            return V(t)
        }
        )(V(document)).dom.appendChild(n.dom),
        o.dom.click(),
        (e=>{
            const t = e.dom;
            null !== t.parentNode && t.parentNode.removeChild(t)
        }
        )(o),
        URL.revokeObjectURL(r)
    }
      , G = (e,t,r)=>{
        const o = `${t}/exporters/${r}${e.suffix}.js`;
        return tinymce.Resource.load("export.exporter." + r, o).then((t=>t(e, (e=>({
            downloadAs: K,
            getContent: h(D, e),
            utils: {
                getStyles: h($, e),
                proxyImages: h(B, e)
            }
        }))(e)))).catch((t=>(console.error(t),
        Promise.reject(e.translate(['Failed to load the "{0}" exporter', r])))))
    }
      , J = (e,t,r,o)=>{
        const n = ()=>e.setProgressState(!1);
        return e.setProgressState(!0),
        G(e, t, r).then((e=>o(e).then(e.download))).then(n, (t=>{
            n(),
            e.notificationManager.open({
                type: "error",
                text: t
            })
        }
        ))
    }
    ;
    tinymce.PluginManager.requireLangPack("export", "ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW"),
    tinymce.PluginManager.add("export", ((e,r)=>{
        if (!((e,r)=>!!e && -1 === ((e,r)=>{
            const o = t(e.major, r.major);
            if (0 !== o)
                return o;
            const n = t(e.minor, r.minor);
            if (0 !== n)
                return n;
            const s = t(e.patch, r.patch);
            return 0 !== s ? s : 0
        }
        )((e=>o((e=>[e.majorVersion, e.minorVersion].join(".").split(".").slice(0, 3).join("."))(e)))(e), o(r)))(tinymce, "6.0.0"))
            return (e=>{
                const t = e.options.register
                  , r = e=>v(e, (e=>{
                    const t = e.split("=");
                    return {
                        name: t[0],
                        text: A(t[1] || t[0])
                    }
                }
                ));
                t("export_formats", {
                    processor: e=>((e,t)=>{
                        if (a(e)) {
                            for (let r = 0, o = e.length; r < o; ++r)
                                if (!t(e[r]))
                                    return !1;
                            return !0
                        }
                        return !1
                    }
                    )(e, i) ? {
                        value: r(e),
                        valid: !0
                    } : i(e) ? {
                        value: r(e.split(/[\s,]+/)),
                        valid: !0
                    } : {
                        valid: !1,
                        message: "Must be a string or an array of strings."
                    },
                    default: "clientpdf"
                }),
                t("export_ignore_elements", {
                    processor: "string[]",
                    default: []
                }),
                t("export_image_proxy", {
                    processor: "string"
                }),
                t("export_image_proxy_service_url", {
                    processor: "string"
                }),
                t("export_image_proxy_max_in_flight", {
                    processor: "number",
                    default: 5
                }),
                t("export_cors_hosts", {
                    processor: "string[]"
                }),
                t("export_api_key", {
                    processor: "string"
                })
            }
            )(e),
            ((e,t)=>{
                const r = v(E(e), (r=>({
                    type: "menuitem",
                    text: r.text,
                    onAction: ()=>{
                        J(e, t, r.name, (()=>Promise.resolve({})))
                    }
                })));
                e.ui.registry.addMenuButton("export", {
                    icon: "export",
                    tooltip: "Export",
                    fetch: e=>e(r)
                }),
                e.ui.registry.addNestedMenuItem("export", {
                    text: "Export",
                    icon: "export",
                    getSubmenuItems: p(r)
                })
            }
            )(e, r),
            ((e,t)=>{
                e.addCommand("mceExportDownload", ((r,o)=>{
                    const n = y.from(o.settings).getOr({});
                    J(e, t, o.format, (()=>Promise.resolve(n)))
                }
                ))
            }
            )(e, r),
            ((e,t)=>({
                convert: (r,o)=>G(e, t, r).then((e=>e.convert(o))),
                download: (r,o)=>{
                    G(e, t, r).then((e=>{
                        e.download(o)
                    }
                    ))
                }
            }))(e, r);
        console.error('The "export" plugin requires at least version 6.0.0 of TinyMCE.')
    }
    ))
}();
