/*!
 * Tiny Comments plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 3.1.0-66
 */

!function() {
    "use strict";
    const e = Object.getPrototypeOf
      , t = (e,t,n)=>{
        var o;
        return !!n(e, t.prototype) || (null === (o = e.constructor) || void 0 === o ? void 0 : o.name) === t.name
    }
      , n = e=>n=>(e=>{
        const n = typeof e;
        return null === e ? "null" : "object" === n && Array.isArray(e) ? "array" : "object" === n && t(e, String, ((e,t)=>t.isPrototypeOf(e))) ? "string" : n
    }
    )(n) === e
      , o = e=>t=>typeof t === e
      , r = n("string")
      , s = n("object")
      , a = n=>((n,o)=>s(n) && t(n, o, ((t,n)=>e(t) === n)))(n, Object)
      , i = n("array")
      , c = o("boolean")
      , l = (void 0,
    e=>undefined === e);
    const u = e=>null == e
      , d = e=>!u(e)
      , m = o("function")
      , g = o("number")
      , p = ()=>{}
      , h = (e,t)=>(...n)=>e(t.apply(null, n))
      , v = e=>()=>e
      , f = e=>e
      , b = (e,t)=>e === t;
    function y(e, ...t) {
        return (...n)=>{
            const o = t.concat(n);
            return e.apply(null, o)
        }
    }
    const _ = e=>()=>{
        throw new Error(e)
    }
      , x = e=>e()
      , w = v(!1)
      , O = v(!0)
      , S = v("dismiss.popups")
      , C = v("reposition.popups");
    class E {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new E(!0,e)
        }
        static none() {
            return E.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? E.some(e(this.value)) : E.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : E.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : E.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return d(e) ? E.some(e) : E.none()
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    E.singletonNone = new E(!1);
    const k = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , T = (e,t)=>{
        const n = (t || document).createElement("div");
        if (n.innerHTML = e,
        !n.hasChildNodes() || n.childNodes.length > 1) {
            const t = "HTML does not have a single root node";
            throw console.error(t, e),
            new Error(t)
        }
        return k(n.childNodes[0])
    }
      , A = (e,t)=>{
        const n = (t || document).createElement(e);
        return k(n)
    }
      , M = (e,t)=>{
        const n = (t || document).createTextNode(e);
        return k(n)
    }
      , R = k;
    var N = function(e) {
        if (null === e)
            return "null";
        if (void 0 === e)
            return "undefined";
        var t = typeof e;
        return "object" === t && (Array.prototype.isPrototypeOf(e) || e.constructor && "Array" === e.constructor.name) ? "array" : "object" === t && (String.prototype.isPrototypeOf(e) || e.constructor && "String" === e.constructor.name) ? "string" : t
    }
      , F = function(e) {
        return {
            eq: e
        }
    }
      , B = F((function(e, t) {
        return e === t
    }
    ))
      , D = function(e) {
        return F((function(t, n) {
            if (t.length !== n.length)
                return !1;
            for (var o = t.length, r = 0; r < o; r++)
                if (!e.eq(t[r], n[r]))
                    return !1;
            return !0
        }
        ))
    }
      , H = F((function(e, t) {
        if (e === t)
            return !0;
        var n, o = N(e);
        return o === N(t) && (function(e) {
            return -1 !== ["undefined", "boolean", "number", "string", "function", "xml", "null"].indexOf(e)
        }(o) ? e === t : "array" === o ? D(H).eq(e, t) : "object" === o && (n = H,
        F((function(e, t) {
            var o = Object.keys(e)
              , r = Object.keys(t);
            if (!function(e, t) {
                return function(e, t) {
                    return F((function(n, o) {
                        return e.eq(t(n), t(o))
                    }
                    ))
                }(D(e), (function(e) {
                    return function(e, t) {
                        return Array.prototype.slice.call(e).sort(t)
                    }(e, t)
                }
                ))
            }(B).eq(o, r))
                return !1;
            for (var s = o.length, a = 0; a < s; a++) {
                var i = o[a];
                if (!n.eq(e[i], t[i]))
                    return !1
            }
            return !0
        }
        ))).eq(e, t))
    }
    ));
    const P = Array.prototype.slice
      , I = Array.prototype.indexOf
      , V = Array.prototype.push
      , W = (e,t)=>((e,t)=>I.call(e, t))(e, t) > -1
      , L = (e,t)=>{
        for (let n = 0, o = e.length; n < o; n++)
            if (t(e[n], n))
                return !0;
        return !1
    }
      , U = (e,t)=>{
        const n = e.length
          , o = new Array(n);
        for (let r = 0; r < n; r++) {
            const n = e[r];
            o[r] = t(n, r)
        }
        return o
    }
      , j = (e,t)=>{
        for (let n = 0, o = e.length; n < o; n++)
            t(e[n], n)
    }
      , z = (e,t)=>{
        const n = [];
        for (let o = 0, r = e.length; o < r; o++) {
            const r = e[o];
            t(r, o) && n.push(r)
        }
        return n
    }
      , $ = (e,t,n)=>(((e,t)=>{
        for (let n = e.length - 1; n >= 0; n--)
            t(e[n], n)
    }
    )(e, ((e,o)=>{
        n = t(n, e, o)
    }
    )),
    n)
      , q = (e,t,n)=>(j(e, ((e,o)=>{
        n = t(n, e, o)
    }
    )),
    n)
      , G = (e,t)=>((e,t,n)=>{
        for (let o = 0, r = e.length; o < r; o++) {
            const r = e[o];
            if (t(r, o))
                return E.some(r);
            if (n(r, o))
                break
        }
        return E.none()
    }
    )(e, t, w)
      , K = (e,t)=>{
        for (let n = 0, o = e.length; n < o; n++)
            if (t(e[n], n))
                return E.some(n);
        return E.none()
    }
      , Y = e=>{
        const t = [];
        for (let n = 0, o = e.length; n < o; ++n) {
            if (!i(e[n]))
                throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
            V.apply(t, e[n])
        }
        return t
    }
      , Q = (e,t)=>Y(U(e, t))
      , J = (e,t)=>{
        for (let n = 0, o = e.length; n < o; ++n)
            if (!0 !== t(e[n], n))
                return !1;
        return !0
    }
      , X = e=>{
        const t = P.call(e, 0);
        return t.reverse(),
        t
    }
      , Z = (e,t)=>z(e, (e=>!W(t, e)))
      , ee = (e,t)=>{
        const n = {};
        for (let o = 0, r = e.length; o < r; o++) {
            const r = e[o];
            n[String(r)] = t(r, o)
        }
        return n
    }
      , te = e=>[e]
      , ne = (e,t)=>t >= 0 && t < e.length ? E.some(e[t]) : E.none()
      , oe = e=>ne(e, 0)
      , re = (e,t)=>{
        for (let n = 0; n < e.length; n++) {
            const o = t(e[n], n);
            if (o.isSome())
                return o
        }
        return E.none()
    }
      , se = (e,t)=>{
        const n = e.dom;
        if (1 !== n.nodeType)
            return !1;
        {
            const e = n;
            if (void 0 !== e.matches)
                return e.matches(t);
            if (void 0 !== e.msMatchesSelector)
                return e.msMatchesSelector(t);
            if (void 0 !== e.webkitMatchesSelector)
                return e.webkitMatchesSelector(t);
            if (void 0 !== e.mozMatchesSelector)
                return e.mozMatchesSelector(t);
            throw new Error("Browser lacks native selectors")
        }
    }
      , ae = e=>1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount
      , ie = (e,t)=>e.dom === t.dom;
    "undefined" != typeof window ? window : Function("return this;")();
    const ce = e=>e.dom.nodeName.toLowerCase()
      , le = e=>t=>(e=>e.dom.nodeType)(t) === e
      , ue = le(1)
      , de = le(3)
      , me = le(9)
      , ge = le(11)
      , pe = e=>t=>ue(t) && ce(t) === e
      , he = e=>R(e.dom.ownerDocument)
      , ve = e=>me(e) ? e : he(e)
      , fe = e=>R(ve(e).dom.defaultView)
      , be = e=>E.from(e.dom.parentNode).map(R)
      , ye = e=>U(e.dom.childNodes, R)
      , _e = (e,t)=>{
        const n = e.dom.childNodes;
        return E.from(n[t]).map(R)
    }
      , xe = e=>_e(e, 0)
      , we = e=>ge(e) && d(e.dom.host)
      , Oe = m(Element.prototype.attachShadow) && m(Node.prototype.getRootNode)
      , Se = v(Oe)
      , Ce = Oe ? e=>R(e.dom.getRootNode()) : ve
      , Ee = e=>R(e.dom.host)
      , ke = e=>{
        const t = R((e=>{
            if (Se() && d(e.target)) {
                const t = R(e.target);
                if (ue(t) && (e=>d(e.dom.shadowRoot))(t) && e.composed && e.composedPath) {
                    const t = e.composedPath();
                    if (t)
                        return oe(t)
                }
            }
            return E.from(e.target)
        }
        )(e).getOr(e.target))
          , n = ()=>e.stopPropagation()
          , o = ()=>e.preventDefault()
          , r = h(o, n);
        return ((e,t,n,o,r,s,a)=>({
            target: e,
            x: t,
            y: n,
            stop: o,
            prevent: r,
            kill: s,
            raw: a
        }))(t, e.clientX, e.clientY, n, o, r, e)
    }
      , Te = (e,t,n,o)=>{
        e.dom.removeEventListener(t, n, o)
    }
      , Ae = O
      , Me = (e,t,n)=>((e,t,n,o)=>((e,t,n,o,r)=>{
        const s = ((e,t)=>n=>{
            e(n) && t(ke(n))
        }
        )(n, o);
        return e.dom.addEventListener(t, s, r),
        {
            unbind: y(Te, e, t, s, r)
        }
    }
    )(e, t, n, o, !1))(e, t, Ae, n)
      , Re = (e,t)=>{
        be(e).each((n=>{
            n.dom.insertBefore(t.dom, e.dom)
        }
        ))
    }
      , Ne = (e,t)=>{
        xe(e).fold((()=>{
            Fe(e, t)
        }
        ), (n=>{
            e.dom.insertBefore(t.dom, n.dom)
        }
        ))
    }
      , Fe = (e,t)=>{
        e.dom.appendChild(t.dom)
    }
      , Be = Object.keys
      , De = Object.hasOwnProperty
      , He = (e,t)=>{
        const n = Be(e);
        for (let o = 0, r = n.length; o < r; o++) {
            const r = n[o];
            t(e[r], r)
        }
    }
      , Pe = (e,t)=>Ie(e, ((e,n)=>({
        k: n,
        v: t(e, n)
    })))
      , Ie = (e,t)=>{
        const n = {};
        return He(e, ((e,o)=>{
            const r = t(e, o);
            n[r.k] = r.v
        }
        )),
        n
    }
      , Ve = e=>(t,n)=>{
        e[n] = t
    }
      , We = (e,t,n,o)=>(He(e, ((e,r)=>{
        (t(e, r) ? n : o)(e, r)
    }
    )),
    {})
      , Le = (e,t)=>{
        const n = {};
        return We(e, t, Ve(n), p),
        n
    }
      , Ue = (e,t)=>{
        const n = [];
        return He(e, ((e,o)=>{
            n.push(t(e, o))
        }
        )),
        n
    }
      , je = (e,t)=>{
        const n = Be(e);
        for (let o = 0, r = n.length; o < r; o++) {
            const r = n[o]
              , s = e[r];
            if (t(s, r, e))
                return E.some(s)
        }
        return E.none()
    }
      , ze = (e,t)=>$e(e, t) ? E.from(e[t]) : E.none()
      , $e = (e,t)=>De.call(e, t)
      , qe = (e,t)=>$e(e, t) && void 0 !== e[t] && null !== e[t]
      , Ge = v("tinycomments")
      , Ke = v("data-mce-annotation")
      , Ye = e=>{
        let t = E.none()
          , n = [];
        const o = e=>{
            r() ? s(e) : n.push(e)
        }
          , r = ()=>t.isSome()
          , s = e=>{
            t.each((t=>{
                setTimeout((()=>{
                    e(t)
                }
                ), 0)
            }
            ))
        }
        ;
        return e((e=>{
            r() || (t = E.some(e),
            j(n, s),
            n = [])
        }
        )),
        {
            get: o,
            map: e=>Ye((t=>{
                o((n=>{
                    t(e(n))
                }
                ))
            }
            )),
            isReady: r
        }
    }
      , Qe = {
        nu: Ye,
        pure: e=>Ye((t=>{
            t(e)
        }
        ))
    }
      , Je = e=>{
        setTimeout((()=>{
            throw e
        }
        ), 0)
    }
      , Xe = e=>{
        const t = t=>{
            e().then(t, Je)
        }
        ;
        return {
            map: t=>Xe((()=>e().then(t))),
            bind: t=>Xe((()=>e().then((e=>t(e).toPromise())))),
            anonBind: t=>Xe((()=>e().then((()=>t.toPromise())))),
            toLazy: ()=>Qe.nu(t),
            toCached: ()=>{
                let t = null;
                return Xe((()=>(null === t && (t = e()),
                t)))
            }
            ,
            toPromise: e,
            get: t
        }
    }
      , Ze = e=>Xe((()=>new Promise(e)))
      , et = e=>Xe((()=>Promise.resolve(e)))
      , tt = e=>{
        const t = t=>t(e)
          , n = v(e)
          , o = ()=>r
          , r = {
            tag: !0,
            inner: e,
            fold: (t,n)=>n(e),
            isValue: O,
            isError: w,
            map: t=>ot.value(t(e)),
            mapError: o,
            bind: t,
            exists: t,
            forall: t,
            getOr: n,
            or: o,
            getOrThunk: n,
            orThunk: o,
            getOrDie: n,
            each: t=>{
                t(e)
            }
            ,
            toOptional: ()=>E.some(e)
        };
        return r
    }
      , nt = e=>{
        const t = ()=>n
          , n = {
            tag: !1,
            inner: e,
            fold: (t,n)=>t(e),
            isValue: w,
            isError: O,
            map: t,
            mapError: t=>ot.error(t(e)),
            bind: t,
            exists: w,
            forall: O,
            getOr: f,
            or: f,
            getOrThunk: x,
            orThunk: x,
            getOrDie: _(String(e)),
            each: p,
            toOptional: E.none
        };
        return n
    }
      , ot = {
        value: tt,
        error: nt,
        fromOption: (e,t)=>e.fold((()=>nt(t)), tt)
    }
      , rt = e=>({
        ...e,
        toCached: ()=>rt(e.toCached()),
        bindFuture: t=>rt(e.bind((e=>e.fold((e=>et(ot.error(e))), (e=>t(e)))))),
        bindResult: t=>rt(e.map((e=>e.bind(t)))),
        mapResult: t=>rt(e.map((e=>e.map(t)))),
        mapError: t=>rt(e.map((e=>e.mapError(t)))),
        foldResult: (t,n)=>e.map((e=>e.fold(t, n))),
        withTimeout: (t,n)=>rt(Ze((o=>{
            let r = !1;
            const s = setTimeout((()=>{
                r = !0,
                o(ot.error(n()))
            }
            ), t);
            e.get((e=>{
                r || (clearTimeout(s),
                o(e))
            }
            ))
        }
        )))
    })
      , st = e=>rt(Ze(e))
      , at = e=>rt(et(ot.value(e)))
      , it = {
        nu: st,
        wrap: rt,
        pure: at,
        value: at,
        error: e=>rt(et(ot.error(e))),
        fromResult: e=>rt(et(e)),
        fromFuture: e=>rt(e.map(ot.value)),
        fromPromise: e=>st((t=>{
            e.then((e=>{
                t(ot.value(e))
            }
            ), (e=>{
                t(ot.error(e))
            }
            ))
        }
        ))
    }
      , ct = e=>{
        const t = de(e) ? e.dom.parentNode : e.dom;
        if (null == t || null === t.ownerDocument)
            return !1;
        const n = t.ownerDocument;
        return (e=>{
            const t = Ce(e);
            return we(t) ? E.some(t) : E.none()
        }
        )(R(t)).fold((()=>n.body.contains(t)), (o = ct,
        r = Ee,
        e=>o(r(e))));
        var o, r
    }
      , lt = (e,t)=>((e,t)=>{
        const n = void 0 === t ? document : t.dom;
        return ae(n) ? [] : U(n.querySelectorAll(e), R)
    }
    )(t, e);
    var ut;
    !function(e) {
        e[e.Change = 0] = "Change",
        e[e.NoChange = 1] = "NoChange"
    }(ut || (ut = {}));
    const dt = (e,t,n,o)=>{
        let r = {
            readonly: !1,
            saving: !1
        };
        const s = (e,t)=>{
            n.notificationManager.open({
                text: e,
                type: "error"
            }),
            t && console.error(e, t)
        }
          , a = (e,t)=>({
            view: {
                type: "splash"
            },
            grabFocus: ()=>1 === e || t
        })
          , i = (e,t,n)=>({
            view: {
                type: "comments",
                conversation: n
            },
            grabFocus: ()=>t || W([1, 3, 4], e)
        })
          , c = (n,r)=>{
            t.set(n),
            t.get().fold((()=>it.pure({
                response: ut.Change,
                update: a(r, o.hasFocus())
            })), (n=>e.lookup({
                conversationUid: n
            }).foldResult((()=>ot.value({
                response: ut.Change,
                update: a(r, o.hasFocus())
            })), (e=>{
                const n = t.get().forall((t=>t !== e.conversation.uid));
                return ot.value(n ? {
                    response: ut.NoChange
                } : {
                    response: ut.Change,
                    update: i(r, o.hasFocus(), e.conversation)
                })
            }
            )))).get((e=>e.fold((e=>{
                s("An error occurred reading the conversation. See the Console for details.", e)
            }
            ), (e=>{
                e.response === ut.Change && (o.update(e.update),
                m())
            }
            ))))
        }
          , l = e=>{
            r = {
                ...r,
                readonly: e
            },
            o.sendGlobalUiState(r)
        }
          , d = pe("hr")
          , m = ()=>{
            if (t.get().isSome() || u(n.selection))
                l(!1);
            else {
                const e = R(n.selection.getNode())
                  , t = R(n.selection.getStart())
                  , o = d(e) || d(t);
                l(o || (()=>{
                    const e = (e,t,n)=>{
                        const o = t.createRange();
                        return o.selectNode(n.dom),
                        o.compareBoundaryPoints(window.Range.END_TO_START, e) < 0 && o.compareBoundaryPoints(window.Range.START_TO_END, e) > 0
                    }
                    ;
                    if (n.selection) {
                        const t = n.selection.getRng()
                          , o = lt(R(t.commonAncestorContainer), `[${Ke()}="${Ge()}"]`);
                        return L(o, y(e, t, n.getDoc()))
                    }
                    return !1
                }
                )())
            }
            return r.readonly
        }
        ;
        return {
            refreshSidebar: c,
            refreshView: e=>{
                e.fold((()=>{
                    c(E.none(), 0)
                }
                ), (({uid: e})=>{
                    c(E.some(e), 0)
                }
                ))
            }
            ,
            setReadonly: l,
            setSaving: e=>{
                r = {
                    ...r,
                    saving: e
                },
                o.sendGlobalUiState(r)
            }
            ,
            showError: s,
            refreshReadonly: m
        }
    }
      , mt = e=>{
        let t = e;
        return {
            get: ()=>t,
            set: e=>{
                t = e
            }
        }
    }
      , gt = ()=>(new Date).toISOString()
      , pt = 36e5
      , ht = 864e5
      , vt = 6048e5
      , ft = 24192e5
      , bt = 290304e5;
    var yt;
    !function(e) {
        e[e.LessThanMinute = 0] = "LessThanMinute",
        e[e.Minute = 1] = "Minute",
        e[e.Hour = 2] = "Hour",
        e[e.Day = 3] = "Day",
        e[e.Week = 4] = "Week",
        e[e.Month = 5] = "Month",
        e[e.Year = 6] = "Year"
    }(yt || (yt = {}));
    const _t = y(((e,t)=>{
        const n = e() - Date.parse(t);
        return n < 6e4 ? {
            interval: yt.LessThanMinute,
            intervalUnits: n,
            intervalMs: n
        } : n < pt ? {
            interval: yt.Minute,
            intervalUnits: Math.floor(n / 6e4),
            intervalMs: n
        } : n < ht ? {
            interval: yt.Hour,
            intervalUnits: Math.floor(n / pt),
            intervalMs: n
        } : n < vt ? {
            interval: yt.Day,
            intervalUnits: Math.floor(n / ht),
            intervalMs: n
        } : n < ft ? {
            interval: yt.Week,
            intervalUnits: Math.floor(n / vt),
            intervalMs: n
        } : n < bt ? {
            interval: yt.Month,
            intervalUnits: Math.floor(n / ft),
            intervalMs: n
        } : {
            interval: yt.Year,
            intervalUnits: Math.floor(n / bt),
            intervalMs: n
        }
    }
    ), (()=>Date.now()))
      , xt = (e,t="")=>{
        const n = e.get()
          , o = "" === t ? 0 : Date.parse(t);
        return {
            timestamp: gt(),
            events: o > 0 ? z(n, (e=>Date.parse(e.timestamp) > o)) : n
        }
    }
      , wt = "comments.globalUiState"
      , Ot = "comments.resize";
    var St;
    !function(e) {
        e[e.Error = 0] = "Error",
        e[e.Value = 1] = "Value"
    }(St || (St = {}));
    const Ct = (e,t,n)=>e.stype === St.Error ? t(e.serror) : n(e.svalue)
      , Et = e=>({
        stype: St.Value,
        svalue: e
    })
      , kt = e=>({
        stype: St.Error,
        serror: e
    })
      , Tt = Et
      , At = kt
      , Mt = Ct
      , Rt = (e,t,n,o)=>({
        tag: "field",
        key: e,
        newKey: t,
        presence: n,
        prop: o
    })
      , Nt = (e,t,n)=>{
        switch (e.tag) {
        case "field":
            return t(e.key, e.newKey, e.presence, e.prop);
        case "custom":
            return n(e.newKey, e.instantiator)
        }
    }
      , Ft = e=>(...t)=>{
        if (0 === t.length)
            throw new Error("Can't merge zero objects");
        const n = {};
        for (let o = 0; o < t.length; o++) {
            const r = t[o];
            for (const t in r)
                $e(r, t) && (n[t] = e(n[t], r[t]))
        }
        return n
    }
      , Bt = Ft(((e,t)=>a(e) && a(t) ? Bt(e, t) : t))
      , Dt = Ft(((e,t)=>t))
      , Ht = e=>{
        let t, n = !1;
        return (...o)=>(n || (n = !0,
        t = e.apply(null, o)),
        t)
    }
      , Pt = e=>({
        tag: "defaultedThunk",
        process: e
    })
      , It = e=>Pt(v(e))
      , Vt = e=>({
        tag: "mergeWithThunk",
        process: e
    })
      , Wt = e=>{
        const t = (e=>{
            const t = []
              , n = [];
            return j(e, (e=>{
                Ct(e, (e=>n.push(e)), (e=>t.push(e)))
            }
            )),
            {
                values: t,
                errors: n
            }
        }
        )(e);
        return t.errors.length > 0 ? (n = t.errors,
        h(At, Y)(n)) : Tt(t.values);
        var n
    }
      , Lt = e=>s(e) && Be(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2)
      , Ut = (e,t)=>At([{
        path: e,
        getErrorInfo: t
    }])
      , jt = e=>({
        extract: (t,n)=>((e,t)=>e.stype === St.Error ? t(e.serror) : e)(e(n), (e=>((e,t)=>Ut(e, v(t)))(t, e))),
        toString: v("val")
    })
      , zt = jt(Tt)
      , $t = (e,t,n,o)=>o(ze(e, t).getOrThunk((()=>n(e))))
      , qt = (e,t,n,o,r)=>{
        const s = e=>r.extract(t.concat([o]), e)
          , a = e=>e.fold((()=>Tt(E.none())), (e=>((e,t)=>e.stype === St.Value ? {
            stype: St.Value,
            svalue: t(e.svalue)
        } : e)(r.extract(t.concat([o]), e), E.some)));
        switch (e.tag) {
        case "required":
            return ((e,t,n,o)=>ze(t, n).fold((()=>((e,t,n)=>Ut(e, (()=>'Could not find valid *required* value for "' + t + '" in ' + Lt(n))))(e, n, t)), o))(t, n, o, s);
        case "defaultedThunk":
            return $t(n, o, e.process, s);
        case "option":
            return ((e,t,n)=>n(ze(e, t)))(n, o, a);
        case "defaultedOptionThunk":
            return ((e,t,n,o)=>o(ze(e, t).map((t=>!0 === t ? n(e) : t))))(n, o, e.process, a);
        case "mergeWithThunk":
            return $t(n, o, v({}), (t=>{
                const o = Bt(e.process(n), t);
                return s(o)
            }
            ))
        }
    }
      , Gt = e=>Be(Le(e, d))
      , Kt = e=>{
        const t = Yt(e)
          , n = $(e, ((e,t)=>Nt(t, (t=>Bt(e, {
            [t]: !0
        })), v(e))), {});
        return {
            extract: (e,o)=>{
                const r = c(o) ? [] : Gt(o)
                  , s = z(r, (e=>!qe(n, e)));
                return 0 === s.length ? t.extract(e, o) : ((e,t)=>Ut(e, (()=>"There are unsupported fields: [" + t.join(", ") + "] specified")))(e, s)
            }
            ,
            toString: t.toString
        }
    }
      , Yt = e=>({
        extract: (t,n)=>((e,t,n)=>{
            const o = {}
              , r = [];
            for (const s of n)
                Nt(s, ((n,s,a,i)=>{
                    const c = qt(a, e, t, n, i);
                    Mt(c, (e=>{
                        r.push(...e)
                    }
                    ), (e=>{
                        o[s] = e
                    }
                    ))
                }
                ), ((e,n)=>{
                    o[e] = n(t)
                }
                ));
            return r.length > 0 ? At(r) : Tt(o)
        }
        )(t, n, e),
        toString: ()=>{
            const t = U(e, (e=>Nt(e, ((e,t,n,o)=>e + " -> " + o.toString()), ((e,t)=>"state(" + e + ")"))));
            return "obj{\n" + t.join("\n") + "}"
        }
    })
      , Qt = e=>({
        extract: (t,n)=>{
            const o = U(n, ((n,o)=>e.extract(t.concat(["[" + o + "]"]), n)));
            return Wt(o)
        }
        ,
        toString: ()=>"array(" + e.toString() + ")"
    })
      , Jt = (e,t)=>({
        extract: (n,o)=>{
            const r = Be(o)
              , s = ((t,n)=>Qt(jt(e)).extract(t, n))(n, r);
            return ((e,t)=>e.stype === St.Value ? t(e.svalue) : e)(s, (e=>{
                const r = U(e, (e=>Rt(e, e, {
                    tag: "required",
                    process: {}
                }, t)));
                return Yt(r).extract(n, o)
            }
            ))
        }
        ,
        toString: ()=>"setOf(" + t.toString() + ")"
    })
      , Xt = v(zt)
      , Zt = (e,t)=>jt((n=>{
        const o = typeof n;
        return e(n) ? Tt(n) : At(`Expected type: ${t} but got: ${o}`)
    }
    ))
      , en = Zt(r, "string")
      , tn = Zt(c, "boolean")
      , nn = Zt(m, "function")
      , on = (e,t)=>({
        extract: (n,o)=>ze(o, e).fold((()=>((e,t)=>Ut(e, (()=>'Choice schema did not contain choice key: "' + t + '"')))(n, e)), (e=>((e,t,n,o)=>ze(n, o).fold((()=>((e,t,n)=>Ut(e, (()=>'The chosen schema: "' + n + '" did not exist in branches: ' + Lt(t))))(e, n, o)), (n=>n.extract(e.concat(["branch: " + o]), t))))(n, o, t, e))),
        toString: ()=>"chooseOn(" + e + "). Possible values: " + Be(t)
    })
      , rn = e=>jt((t=>e(t).fold(At, Tt)))
      , sn = (e,t)=>Jt((t=>e(t).fold(kt, Et)), t)
      , an = (e,t,n)=>{
        return o = ((e,t,n)=>((e,t)=>e.stype === St.Error ? {
            stype: St.Error,
            serror: t(e.serror)
        } : e)(t.extract([e], n), (e=>({
            input: n,
            errors: e
        }))))(e, t, n),
        Ct(o, ot.error, ot.value);
        var o
    }
      , cn = e=>e.fold((e=>{
        throw new Error(un(e))
    }
    ), f)
      , ln = (e,t,n)=>cn(an(e, t, n))
      , un = e=>"Errors: \n" + (e=>{
        const t = e.length > 10 ? e.slice(0, 10).concat([{
            path: [],
            getErrorInfo: v("... (only showing first ten failures)")
        }]) : e;
        return U(t, (e=>"Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()))
    }
    )(e.errors).join("\n") + "\n\nInput object: " + Lt(e.input)
      , dn = (e,t)=>on(e, Pe(t, Yt))
      , mn = Rt
      , gn = (e,t)=>({
        tag: "custom",
        newKey: e,
        instantiator: t
    })
      , pn = e=>mn(e, e, {
        tag: "required",
        process: {}
    }, Xt())
      , hn = (e,t)=>mn(e, e, {
        tag: "required",
        process: {}
    }, t)
      , vn = e=>hn(e, tn)
      , fn = (e,t)=>mn(e, e, {
        tag: "required",
        process: {}
    }, Yt(t))
      , bn = e=>mn(e, e, {
        tag: "option",
        process: {}
    }, Xt())
      , yn = (e,t)=>mn(e, e, {
        tag: "option",
        process: {}
    }, t)
      , _n = (e,t)=>yn(e, Yt(t))
      , xn = (e,t)=>yn(e, Kt(t))
      , wn = (e,t)=>mn(e, e, It(t), Xt())
      , On = (e,t,n)=>mn(e, e, It(t), n)
      , Sn = {
        init: ()=>Cn({
            readState: v("No State required")
        })
    }
      , Cn = e=>e
      , En = e=>{
        if (!i(e))
            throw new Error("cases must be an array");
        if (0 === e.length)
            throw new Error("there must be at least one case");
        const t = []
          , n = {};
        return j(e, ((o,r)=>{
            const s = Be(o);
            if (1 !== s.length)
                throw new Error("one and only one name per case");
            const a = s[0]
              , c = o[a];
            if (void 0 !== n[a])
                throw new Error("duplicate key detected:" + a);
            if ("cata" === a)
                throw new Error("cannot have a case named cata (sorry)");
            if (!i(c))
                throw new Error("case arguments must be an array");
            t.push(a),
            n[a] = (...n)=>{
                const o = n.length;
                if (o !== c.length)
                    throw new Error("Wrong number of arguments to case " + a + ". Expected " + c.length + " (" + c + "), got " + o);
                return {
                    fold: (...t)=>{
                        if (t.length !== e.length)
                            throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                        return t[r].apply(null, n)
                    }
                    ,
                    match: e=>{
                        const o = Be(e);
                        if (t.length !== o.length)
                            throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + o.join(","));
                        if (!J(t, (e=>W(o, e))))
                            throw new Error("Not all branches were specified when using match. Specified: " + o.join(", ") + "\nRequired: " + t.join(", "));
                        return e[a].apply(null, n)
                    }
                    ,
                    log: e=>{
                        console.log(e, {
                            constructors: t,
                            constructor: a,
                            params: n
                        })
                    }
                }
            }
        }
        )),
        n
    }
    ;
    En([{
        bothErrors: ["error1", "error2"]
    }, {
        firstError: ["error1", "value2"]
    }, {
        secondError: ["value1", "error2"]
    }, {
        bothValues: ["value1", "value2"]
    }]);
    const kn = (e,t)=>((e,t)=>({
        [e]: t
    }))(e, t)
      , Tn = e=>(e=>{
        const t = {};
        return j(e, (e=>{
            t[e.key] = e.value
        }
        )),
        t
    }
    )(e)
      , An = e=>m(e) ? e : w
      , Mn = (e,t)=>ie(e.element, t.event.target)
      , Rn = {
        can: O,
        abort: w,
        run: p
    }
      , Nn = e=>{
        if (!qe(e, "can") && !qe(e, "abort") && !qe(e, "run"))
            throw new Error("EventHandler defined by: " + JSON.stringify(e, null, 2) + " does not have can, abort, or run!");
        return {
            ...Rn,
            ...e
        }
    }
      , Fn = ()=>Bn(0, 0)
      , Bn = (e,t)=>({
        major: e,
        minor: t
    })
      , Dn = {
        nu: Bn,
        detect: (e,t)=>{
            const n = String(t).toLowerCase();
            return 0 === e.length ? Fn() : ((e,t)=>{
                const n = ((e,t)=>{
                    for (let n = 0; n < e.length; n++) {
                        const o = e[n];
                        if (o.test(t))
                            return o
                    }
                }
                )(e, t);
                if (!n)
                    return {
                        major: 0,
                        minor: 0
                    };
                const o = e=>Number(t.replace(n, "$" + e));
                return Bn(o(1), o(2))
            }
            )(e, n)
        }
        ,
        unknown: Fn
    }
      , Hn = (e,t)=>{
        const n = String(t).toLowerCase();
        return G(e, (e=>e.search(n)))
    }
      , Pn = (e,t)=>-1 !== e.indexOf(t)
      , In = (e,t)=>((e,t,n)=>"" === t || e.length >= t.length && e.substr(n, n + t.length) === t)(e, t, e.length - t.length)
      , Vn = (e=>t=>t.replace(e, ""))(/^\s+|\s+$/g)
      , Wn = e=>e.length > 0
      , Ln = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/
      , Un = e=>t=>Pn(t, e)
      , jn = [{
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: e=>Pn(e, "edge/") && Pn(e, "chrome") && Pn(e, "safari") && Pn(e, "applewebkit")
    }, {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Ln],
        search: e=>Pn(e, "chrome") && !Pn(e, "chromeframe")
    }, {
        name: "IE",
        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
        search: e=>Pn(e, "msie") || Pn(e, "trident")
    }, {
        name: "Opera",
        versionRegexes: [Ln, /.*?opera\/([0-9]+)\.([0-9]+).*/],
        search: Un("opera")
    }, {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: Un("firefox")
    }, {
        name: "Safari",
        versionRegexes: [Ln, /.*?cpu os ([0-9]+)_([0-9]+).*/],
        search: e=>(Pn(e, "safari") || Pn(e, "mobile/")) && Pn(e, "applewebkit")
    }]
      , zn = [{
        name: "Windows",
        search: Un("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "iOS",
        search: e=>Pn(e, "iphone") || Pn(e, "ipad"),
        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
    }, {
        name: "Android",
        search: Un("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "macOS",
        search: Un("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    }, {
        name: "Linux",
        search: Un("linux"),
        versionRegexes: []
    }, {
        name: "Solaris",
        search: Un("sunos"),
        versionRegexes: []
    }, {
        name: "FreeBSD",
        search: Un("freebsd"),
        versionRegexes: []
    }, {
        name: "ChromeOS",
        search: Un("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }]
      , $n = {
        browsers: v(jn),
        oses: v(zn)
    }
      , qn = "Edge"
      , Gn = "Chromium"
      , Kn = "Opera"
      , Yn = "Firefox"
      , Qn = "Safari"
      , Jn = e=>{
        const t = e.current
          , n = e.version
          , o = e=>()=>t === e;
        return {
            current: t,
            version: n,
            isEdge: o(qn),
            isChromium: o(Gn),
            isIE: o("IE"),
            isOpera: o(Kn),
            isFirefox: o(Yn),
            isSafari: o(Qn)
        }
    }
      , Xn = ()=>Jn({
        current: void 0,
        version: Dn.unknown()
    })
      , Zn = Jn
      , eo = (v(qn),
    v(Gn),
    v("IE"),
    v(Kn),
    v(Yn),
    v(Qn),
    "Windows")
      , to = "Android"
      , no = "Linux"
      , oo = "macOS"
      , ro = "Solaris"
      , so = "FreeBSD"
      , ao = "ChromeOS"
      , io = e=>{
        const t = e.current
          , n = e.version
          , o = e=>()=>t === e;
        return {
            current: t,
            version: n,
            isWindows: o(eo),
            isiOS: o("iOS"),
            isAndroid: o(to),
            isMacOS: o(oo),
            isLinux: o(no),
            isSolaris: o(ro),
            isFreeBSD: o(so),
            isChromeOS: o(ao)
        }
    }
      , co = ()=>io({
        current: void 0,
        version: Dn.unknown()
    })
      , lo = io
      , uo = (v(eo),
    v("iOS"),
    v(to),
    v(no),
    v(oo),
    v(ro),
    v(so),
    v(ao),
    e=>window.matchMedia(e).matches);
    let mo = Ht((()=>((e,t,n)=>{
        const o = $n.browsers()
          , r = $n.oses()
          , s = t.bind((e=>((e,t)=>re(t.brands, (t=>{
            const n = t.brand.toLowerCase();
            return G(e, (e=>{
                var t;
                return n === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
            }
            )).map((e=>({
                current: e.name,
                version: Dn.nu(parseInt(t.version, 10), 0)
            })))
        }
        )))(o, e))).orThunk((()=>((e,t)=>Hn(e, t).map((e=>{
            const n = Dn.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: n
            }
        }
        )))(o, e))).fold(Xn, Zn)
          , a = ((e,t)=>Hn(e, t).map((e=>{
            const n = Dn.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: n
            }
        }
        )))(r, e).fold(co, lo)
          , i = ((e,t,n,o)=>{
            const r = e.isiOS() && !0 === /ipad/i.test(n)
              , s = e.isiOS() && !r
              , a = e.isiOS() || e.isAndroid()
              , i = a || o("(pointer:coarse)")
              , c = r || !s && a && o("(min-device-width:768px)")
              , l = s || a && !c
              , u = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n)
              , d = !l && !c && !u;
            return {
                isiPad: v(r),
                isiPhone: v(s),
                isTablet: v(c),
                isPhone: v(l),
                isTouch: v(i),
                isAndroid: e.isAndroid,
                isiOS: e.isiOS,
                isWebView: v(u),
                isDesktop: v(d)
            }
        }
        )(a, s, e, n);
        return {
            browser: s,
            os: a,
            deviceType: i
        }
    }
    )(navigator.userAgent, E.from(navigator.userAgentData), uo)));
    const go = ()=>mo()
      , po = v
      , ho = po("touchstart")
      , vo = po("touchmove")
      , fo = po("touchend")
      , bo = po("mousedown")
      , yo = po("mouseover")
      , _o = po("keydown")
      , xo = po("keyup")
      , wo = po("input")
      , Oo = po("click")
      , So = po("transitioncancel")
      , Co = po("transitionend")
      , Eo = po("transitionstart")
      , ko = e=>v("alloy." + e)
      , To = {
        tap: ko("tap")
    }
      , Ao = ko("focus")
      , Mo = ko("blur.post")
      , Ro = ko("paste.post")
      , No = ko("receive")
      , Fo = ko("execute")
      , Bo = ko("focus.item")
      , Do = To.tap
      , Ho = ko("longpress")
      , Po = ko("sandbox.close")
      , Io = ko("system.init")
      , Vo = ko("system.attached")
      , Wo = ko("system.detached")
      , Lo = ko("system.dismissRequested")
      , Uo = ko("system.repositionRequested")
      , jo = ko("focusmanager.shifted")
      , zo = ko("highlight")
      , $o = ko("dehighlight")
      , qo = (e,t)=>{
        Qo(e, e.element, t, {})
    }
      , Go = (e,t,n)=>{
        Qo(e, e.element, t, n)
    }
      , Ko = e=>{
        qo(e, Fo())
    }
      , Yo = (e,t,n)=>{
        Qo(e, t, n, {})
    }
      , Qo = (e,t,n,o)=>{
        const r = {
            target: t,
            ...o
        };
        e.getSystem().triggerEvent(n, t, r)
    }
      , Jo = e=>Tn(e)
      , Xo = (e,t)=>({
        key: e,
        value: Nn({
            abort: t
        })
    })
      , Zo = (e,t)=>({
        key: e,
        value: Nn({
            run: t
        })
    })
      , er = e=>t=>({
        key: e,
        value: Nn({
            run: (e,n)=>{
                Mn(e, n) && t(e, n)
            }
        })
    })
      , tr = e=>Zo(e, ((e,t)=>{
        t.cut()
    }
    ))
      , nr = e=>Zo(e, ((e,t)=>{
        t.stop()
    }
    ))
      , or = (e,t)=>er(e)(t)
      , rr = er(Vo())
      , sr = er(Wo())
      , ar = er(Io())
      , ir = (e=>t=>Zo(e, t))(Fo())
      , cr = (e,t,n=b)=>e.exists((e=>n(e, t)))
      , lr = e=>{
        const t = []
          , n = e=>{
            t.push(e)
        }
        ;
        for (let t = 0; t < e.length; t++)
            e[t].each(n);
        return t
    }
      , ur = (e,t,n)=>e.isSome() && t.isSome() ? E.some(n(e.getOrDie(), t.getOrDie())) : E.none()
      , dr = e=>U(e, (e=>In(e, "/*") ? e.substring(0, e.length - "/*".length) : e))
      , mr = (e,t)=>{
        const n = e.toString()
          , o = n.indexOf(")") + 1
          , r = n.indexOf("(")
          , s = n.substring(r + 1, o - 1).split(/,\s*/);
        return e.toFunctionAnnotation = ()=>({
            name: t,
            parameters: dr(s)
        }),
        e
    }
      , gr = e=>({
        classes: l(e.classes) ? [] : e.classes,
        attributes: l(e.attributes) ? {} : e.attributes,
        styles: l(e.styles) ? {} : e.styles
    })
      , pr = (e,t,n)=>ar(((o,r)=>{
        n(o, e, t)
    }
    ))
      , hr = e=>({
        key: e,
        value: void 0
    })
      , vr = (e,t,n,o,r,s,a)=>{
        const i = e=>qe(e, n) ? e[n]() : E.none()
          , c = Pe(r, ((e,t)=>((e,t,n)=>((e,t,n)=>{
            const o = n.toString()
              , r = o.indexOf(")") + 1
              , s = o.indexOf("(")
              , a = o.substring(s + 1, r - 1).split(/,\s*/);
            return e.toFunctionAnnotation = ()=>({
                name: t,
                parameters: dr(a.slice(0, 1).concat(a.slice(3)))
            }),
            e
        }
        )(((o,...r)=>{
            const s = [o].concat(r);
            return o.config({
                name: v(e)
            }).fold((()=>{
                throw new Error("We could not find any behaviour configuration for: " + e + ". Using API: " + n)
            }
            ), (e=>{
                const n = Array.prototype.slice.call(s, 1);
                return t.apply(void 0, [o, e.config, e.state].concat(n))
            }
            ))
        }
        ), n, t))(n, e, t)))
          , l = {
            ...Pe(s, ((e,t)=>mr(e, t))),
            ...c,
            revoke: y(hr, n),
            config: t=>{
                const o = ln(n + "-config", e, t);
                return {
                    key: n,
                    value: {
                        config: o,
                        me: l,
                        configAsRaw: Ht((()=>ln(n + "-config", e, t))),
                        initialConfig: t,
                        state: a
                    }
                }
            }
            ,
            schema: v(t),
            exhibit: (e,t)=>ur(i(e), ze(o, "exhibit"), ((e,n)=>n(t, e.config, e.state))).getOrThunk((()=>gr({}))),
            name: v(n),
            handlers: e=>i(e).map((e=>ze(o, "events").getOr((()=>({})))(e.config, e.state))).getOr({})
        };
        return l
    }
      , fr = e=>Tn(e)
      , br = Kt([pn("fields"), pn("name"), wn("active", {}), wn("apis", {}), wn("state", Sn), wn("extra", {})])
      , yr = e=>{
        const t = ln("Creating behaviour: " + e.name, br, e);
        return ((e,t,n,o,r,s)=>{
            const a = Kt(e)
              , i = _n(t, [xn("config", e)]);
            return vr(a, i, t, n, o, r, s)
        }
        )(t.fields, t.name, t.active, t.apis, t.extra, t.state)
    }
      , _r = Kt([pn("branchKey"), pn("branches"), pn("name"), wn("active", {}), wn("apis", {}), wn("state", Sn), wn("extra", {})])
      , xr = v(void 0)
      , wr = (e,t)=>{
        const n = ((e,t)=>{
            const n = Jo(t);
            return yr({
                fields: [pn("enabled")],
                name: e,
                active: {
                    events: v(n)
                }
            })
        }
        )(e, t);
        return {
            key: e,
            value: {
                config: {},
                me: n,
                configAsRaw: v({}),
                initialConfig: {},
                state: Sn
            }
        }
    }
      , Or = ()=>R(document)
      , Sr = e=>e.dom.focus()
      , Cr = (e=Or())=>E.from(e.dom.activeElement).map(R)
      , Er = e=>Cr(Ce(e)).filter((t=>e.dom.contains(t.dom)))
      , kr = (e,t)=>{
        j(t, (t=>{
            Fe(e, t)
        }
        ))
    }
      , Tr = e=>{
        e.dom.textContent = "",
        j(ye(e), (e=>{
            Ar(e)
        }
        ))
    }
      , Ar = e=>{
        const t = e.dom;
        null !== t.parentNode && t.parentNode.removeChild(t)
    }
      , Mr = e=>e.dom.innerHTML
      , Rr = (e,t)=>{
        const n = he(e).dom
          , o = R(n.createDocumentFragment())
          , r = ((e,t)=>{
            const n = (t || document).createElement("div");
            return n.innerHTML = e,
            ye(R(n))
        }
        )(t, n);
        kr(o, r),
        Tr(e),
        Fe(e, o)
    }
      , Nr = (e,t,n)=>{
        if (!(r(n) || c(n) || g(n)))
            throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e),
            new Error("Attribute value was not simple");
        e.setAttribute(t, n + "")
    }
      , Fr = (e,t,n)=>{
        Nr(e.dom, t, n)
    }
      , Br = (e,t)=>{
        const n = e.dom;
        He(t, ((e,t)=>{
            Nr(n, t, e)
        }
        ))
    }
      , Dr = (e,t)=>{
        const n = e.dom.getAttribute(t);
        return null === n ? void 0 : n
    }
      , Hr = (e,t)=>E.from(Dr(e, t))
      , Pr = (e,t)=>{
        const n = e.dom;
        return !(!n || !n.hasAttribute) && n.hasAttribute(t)
    }
      , Ir = (e,t)=>{
        e.dom.removeAttribute(t)
    }
      , Vr = e=>we(e) ? "#shadow-root" : (e=>{
        const t = A("div")
          , n = R(e.dom.cloneNode(!0));
        return Fe(t, n),
        Mr(t)
    }
    )((e=>((e,t)=>R(e.dom.cloneNode(!1)))(e))(e))
      , Wr = e=>Vr(e);
    var Lr;
    !function(e) {
        e[e.STOP = 0] = "STOP",
        e[e.NORMAL = 1] = "NORMAL",
        e[e.LOGGING = 2] = "LOGGING"
    }(Lr || (Lr = {}));
    const Ur = mt({})
      , jr = ["alloy/data/Fields", "alloy/debugging/Debugging"]
      , zr = (e,t,n)=>((e,t,n)=>{
        switch (ze(Ur.get(), e).orThunk((()=>{
            const t = Be(Ur.get());
            return re(t, (t=>e.indexOf(t) > -1 ? E.some(Ur.get()[t]) : E.none()))
        }
        )).getOr(Lr.NORMAL)) {
        case Lr.NORMAL:
            return n($r());
        case Lr.LOGGING:
            {
                const o = ((e,t)=>{
                    const n = []
                      , o = (new Date).getTime();
                    return {
                        logEventCut: (e,t,o)=>{
                            n.push({
                                outcome: "cut",
                                target: t,
                                purpose: o
                            })
                        }
                        ,
                        logEventStopped: (e,t,o)=>{
                            n.push({
                                outcome: "stopped",
                                target: t,
                                purpose: o
                            })
                        }
                        ,
                        logNoParent: (e,t,o)=>{
                            n.push({
                                outcome: "no-parent",
                                target: t,
                                purpose: o
                            })
                        }
                        ,
                        logEventNoHandlers: (e,t)=>{
                            n.push({
                                outcome: "no-handlers-left",
                                target: t
                            })
                        }
                        ,
                        logEventResponse: (e,t,o)=>{
                            n.push({
                                outcome: "response",
                                purpose: o,
                                target: t
                            })
                        }
                        ,
                        write: ()=>{
                            const r = (new Date).getTime();
                            W(["mousemove", "mouseover", "mouseout", Io()], e) || console.log(e, {
                                event: e,
                                time: r - o,
                                target: t.dom,
                                sequence: U(n, (e=>W(["cut", "stopped", "response"], e.outcome) ? "{" + e.purpose + "} " + e.outcome + " at (" + Wr(e.target) + ")" : e.outcome))
                            })
                        }
                    }
                }
                )(e, t)
                  , r = n(o);
                return o.write(),
                r
            }
        case Lr.STOP:
            return !0
        }
    }
    )(e, t, n)
      , $r = v({
        logEventCut: p,
        logEventStopped: p,
        logNoParent: p,
        logEventNoHandlers: p,
        logEventResponse: p,
        write: p
    })
      , qr = e=>e.cHandler
      , Gr = e=>{
        const t = mt(E.none())
          , n = ()=>t.get().each(e);
        return {
            clear: ()=>{
                n(),
                t.set(E.none())
            }
            ,
            isSet: ()=>t.get().isSome(),
            get: ()=>t.get(),
            set: e=>{
                n(),
                t.set(E.some(e))
            }
        }
    }
      , Kr = ()=>Gr((e=>e.unbind()))
      , Yr = ()=>{
        const e = Gr(p);
        return {
            ...e,
            on: t=>e.get().each(t)
        }
    }
    ;
    var Qr = (e,t,n,o,r)=>e(n, o) ? E.some(n) : m(r) && r(n) ? E.none() : t(n, o, r);
    const Jr = (e,t,n)=>{
        let o = e.dom;
        const r = m(n) ? n : w;
        for (; o.parentNode; ) {
            o = o.parentNode;
            const e = R(o);
            if (t(e))
                return E.some(e);
            if (r(e))
                break
        }
        return E.none()
    }
      , Xr = (e,t,n)=>Qr(((e,t)=>t(e)), Jr, e, t, n)
      , Zr = (e,t,n)=>Jr(e, (e=>se(e, t)), n)
      , es = (e,t)=>((e,t)=>{
        const n = void 0 === t ? document : t.dom;
        return ae(n) ? E.none() : E.from(n.querySelector(e)).map(R)
    }
    )(t, e)
      , ts = (e,t,n)=>Qr(((e,t)=>se(e, t)), Zr, e, t, n)
      , ns = [8]
      , os = [9]
      , rs = [13]
      , ss = [27]
      , as = [32]
      , is = [37]
      , cs = [38]
      , ls = [39]
      , us = [40]
      , ds = e=>{
        const t = e.raw;
        return void 0 === t.touches || 1 !== t.touches.length ? E.none() : E.some(t.touches[0])
    }
      , ms = e=>{
        const t = Yr()
          , n = mt(!1)
          , o = ((e,t)=>{
            let n = null;
            return {
                cancel: ()=>{
                    null !== n && (clearTimeout(n),
                    n = null)
                }
                ,
                schedule: (...t)=>{
                    n = setTimeout((()=>{
                        e.apply(null, t),
                        n = null
                    }
                    ), 400)
                }
            }
        }
        )((t=>{
            e.triggerEvent(Ho(), t),
            n.set(!0)
        }
        ))
          , r = Tn([{
            key: ho(),
            value: e=>(ds(e).each((r=>{
                o.cancel();
                const s = {
                    x: r.clientX,
                    y: r.clientY,
                    target: e.target
                };
                o.schedule(e),
                n.set(!1),
                t.set(s)
            }
            )),
            E.none())
        }, {
            key: vo(),
            value: e=>(o.cancel(),
            ds(e).each((e=>{
                t.on((n=>{
                    ((e,t)=>{
                        const n = Math.abs(e.clientX - t.x)
                          , o = Math.abs(e.clientY - t.y);
                        return n > 5 || o > 5
                    }
                    )(e, n) && t.clear()
                }
                ))
            }
            )),
            E.none())
        }, {
            key: fo(),
            value: r=>(o.cancel(),
            t.get().filter((e=>ie(e.target, r.target))).map((t=>n.get() ? (r.prevent(),
            !1) : e.triggerEvent(Do(), r))))
        }]);
        return {
            fireIfReady: (e,t)=>ze(r, t).bind((t=>t(e)))
        }
    }
      , gs = (e,t)=>{
        const n = ze(e, "target").getOr(t);
        return mt(n)
    }
      , ps = En([{
        stopped: []
    }, {
        resume: ["element"]
    }, {
        complete: []
    }])
      , hs = (e,t,n,o,r,s)=>{
        const a = e(t, o)
          , i = ((e,t)=>{
            const n = mt(!1)
              , o = mt(!1);
            return {
                stop: ()=>{
                    n.set(!0)
                }
                ,
                cut: ()=>{
                    o.set(!0)
                }
                ,
                isStopped: n.get,
                isCut: o.get,
                event: e,
                setSource: t.set,
                getSource: t.get
            }
        }
        )(n, r);
        return a.fold((()=>(s.logEventNoHandlers(t, o),
        ps.complete())), (e=>{
            const n = e.descHandler;
            return qr(n)(i),
            i.isStopped() ? (s.logEventStopped(t, e.element, n.purpose),
            ps.stopped()) : i.isCut() ? (s.logEventCut(t, e.element, n.purpose),
            ps.complete()) : be(e.element).fold((()=>(s.logNoParent(t, e.element, n.purpose),
            ps.complete())), (o=>(s.logEventResponse(t, e.element, n.purpose),
            ps.resume(o))))
        }
        ))
    }
      , vs = (e,t,n,o,r,s)=>hs(e, t, n, o, r, s).fold(O, (o=>vs(e, t, n, o, r, s)), w)
      , fs = (e,t,n,o,r)=>{
        const s = gs(n, o);
        return vs(e, t, n, o, s, r)
    }
    ;
    let bs = 0;
    const ys = e=>{
        const t = (new Date).getTime()
          , n = Math.floor(1e9 * Math.random());
        return bs++,
        e + "_" + n + bs + String(t)
    }
      , _s = v("alloy-id-")
      , xs = v("data-alloy-id")
      , ws = _s()
      , Os = xs()
      , Ss = (e,t)=>{
        Object.defineProperty(e.dom, Os, {
            value: t,
            writable: !0
        })
    }
      , Cs = e=>{
        const t = ue(e) ? e.dom[Os] : null;
        return E.from(t)
    }
      , Es = e=>ys(e)
      , ks = ()=>{
        const e = {};
        return {
            registerId: (t,n,o)=>{
                He(o, ((o,r)=>{
                    const s = void 0 !== e[r] ? e[r] : {};
                    s[n] = ((e,t)=>({
                        cHandler: y.apply(void 0, [e.handler].concat(t)),
                        purpose: e.purpose
                    }))(o, t),
                    e[r] = s
                }
                ))
            }
            ,
            unregisterId: t=>{
                He(e, ((e,n)=>{
                    $e(e, t) && delete e[t]
                }
                ))
            }
            ,
            filterByType: t=>ze(e, t).map((e=>Ue(e, ((e,t)=>((e,t)=>({
                id: e,
                descHandler: t
            }))(t, e))))).getOr([]),
            find: (t,n,o)=>ze(e, n).bind((e=>((e,t,n)=>{
                const o = t(e)
                  , r = An(n);
                return o.orThunk((()=>r(e) ? E.none() : ((e,t,n)=>{
                    let o = e.dom;
                    const r = An(n);
                    for (; o.parentNode; ) {
                        o = o.parentNode;
                        const e = R(o)
                          , n = t(e);
                        if (n.isSome())
                            return n;
                        if (r(e))
                            break
                    }
                    return E.none()
                }
                )(e, t, r)))
            }
            )(o, (t=>((e,t)=>Cs(t).bind((t=>ze(e, t))).map((e=>((e,t)=>({
                element: e,
                descHandler: t
            }))(t, e))))(e, t)), t)))
        }
    }
      , Ts = ()=>{
        const e = ks()
          , t = {}
          , n = n=>{
            Cs(n.element).each((n=>{
                delete t[n],
                e.unregisterId(n)
            }
            ))
        }
        ;
        return {
            find: (t,n,o)=>e.find(t, n, o),
            filter: t=>e.filterByType(t),
            register: o=>{
                const r = (e=>{
                    const t = e.element;
                    return Cs(t).getOrThunk((()=>((e,t)=>{
                        const n = ys(ws + "uid-");
                        return Ss(t, n),
                        n
                    }
                    )(0, e.element)))
                }
                )(o);
                qe(t, r) && ((e,o)=>{
                    const r = t[o];
                    if (r !== e)
                        throw new Error('The tagId "' + o + '" is already used by: ' + Wr(r.element) + "\nCannot use it for: " + Wr(e.element) + "\nThe conflicting element is" + (ct(r.element) ? " " : " not ") + "already in the DOM");
                    n(e)
                }
                )(o, r);
                const s = [o];
                e.registerId(s, r, o.events),
                t[r] = o
            }
            ,
            unregister: n,
            getById: e=>ze(t, e)
        }
    }
      , As = Jo([((e,t)=>({
        key: e,
        value: Nn({
            can: (e,t)=>{
                const n = t.event
                  , o = n.originator
                  , r = n.target;
                return !((e,t,n)=>ie(t, e.element) && !ie(t, n))(e, o, r) || (console.warn(Ao() + " did not get interpreted by the desired target. \nOriginator: " + Wr(o) + "\nTarget: " + Wr(r) + "\nCheck the " + Ao() + " event handlers"),
                !1)
            }
        })
    }))(Ao())]);
    var Ms = Object.freeze({
        __proto__: null,
        events: As
    });
    const Rs = f
      , Ns = e=>{
        const t = t=>`The component must be in a context to execute: ${t}` + (e ? "\n" + Wr(e().element) + " is not in context." : "")
          , n = e=>()=>{
            throw new Error(t(e))
        }
          , o = e=>()=>{
            console.warn(t(e))
        }
        ;
        return {
            debugInfo: v("fake"),
            triggerEvent: o("triggerEvent"),
            triggerFocus: o("triggerFocus"),
            triggerEscape: o("triggerEscape"),
            broadcast: o("broadcast"),
            broadcastOn: o("broadcastOn"),
            broadcastEvent: o("broadcastEvent"),
            build: n("build"),
            buildOrPatch: n("buildOrPatch"),
            addToWorld: n("addToWorld"),
            removeFromWorld: n("removeFromWorld"),
            addToGui: n("addToGui"),
            removeFromGui: n("removeFromGui"),
            getByUid: n("getByUid"),
            getByDom: n("getByDom"),
            isConnected: w
        }
    }
      , Fs = Ns()
      , Bs = ys("alloy-premade")
      , Ds = e=>(Object.defineProperty(e.element.dom, Bs, {
        value: e.uid,
        writable: !0
    }),
    kn(Bs, e))
      , Hs = e=>ze(e, Bs)
      , Ps = e=>((e,t)=>{
        const n = t.toString()
          , o = n.indexOf(")") + 1
          , r = n.indexOf("(")
          , s = n.substring(r + 1, o - 1).split(/,\s*/);
        return e.toFunctionAnnotation = ()=>({
            name: "OVERRIDE",
            parameters: dr(s.slice(1))
        }),
        e
    }
    )(((t,...n)=>e(t.getApis(), t, ...n)), e)
      , Is = (e,t)=>{
        const n = {};
        return He(e, ((e,o)=>{
            He(e, ((e,r)=>{
                const s = ze(n, r).getOr([]);
                n[r] = s.concat([t(o, e)])
            }
            ))
        }
        )),
        n
    }
      , Vs = (e,t,n,o)=>{
        try {
            const r = ((n,r)=>{
                const s = P.call(n, 0);
                return s.sort(((n,r)=>{
                    const s = n[t]
                      , a = r[t]
                      , i = o.indexOf(s)
                      , c = o.indexOf(a);
                    if (-1 === i)
                        throw new Error("The ordering for " + e + " does not have an entry for " + s + ".\nOrder specified: " + JSON.stringify(o, null, 2));
                    if (-1 === c)
                        throw new Error("The ordering for " + e + " does not have an entry for " + a + ".\nOrder specified: " + JSON.stringify(o, null, 2));
                    return i < c ? -1 : c < i ? 1 : 0
                }
                )),
                s
            }
            )(n);
            return ot.value(r)
        } catch (e) {
            return ot.error([e])
        }
    }
      , Ws = (e,t)=>({
        name: e,
        handler: t
    })
      , Ls = (e,t)=>{
        const n = {};
        return j(e, (e=>{
            n[e.name()] = e.handlers(t)
        }
        )),
        n
    }
      , Us = (e,t,n)=>{
        const o = t[n];
        return o ? Vs("Event: " + n, "name", e, o).map((e=>(e=>{
            const t = ((e,t)=>(...t)=>q(e, ((e,n)=>e && (e=>e.can)(n).apply(void 0, t)), !0))(e)
              , n = ((e,t)=>(...t)=>q(e, ((e,n)=>e || (e=>e.abort)(n).apply(void 0, t)), !1))(e);
            return {
                can: t,
                abort: n,
                run: (...t)=>{
                    j(e, (e=>{
                        e.run.apply(void 0, t)
                    }
                    ))
                }
            }
        }
        )(U(e, (e=>e.handler))))) : ((e,t)=>ot.error(["The event (" + e + ') has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that can trigger it are: ' + JSON.stringify(U(t, (e=>e.name)), null, 2)]))(n, e)
    }
      , js = (e,t)=>{
        const n = Ue(e, ((e,n)=>(1 === e.length ? ot.value(e[0].handler) : Us(e, t, n)).map((o=>{
            const r = (e=>{
                const t = (e=>m(e) ? {
                    can: O,
                    abort: w,
                    run: e
                } : e)(e);
                return (e,n,...o)=>{
                    const r = [e, n].concat(o);
                    t.abort.apply(void 0, r) ? n.stop() : t.can.apply(void 0, r) && t.run.apply(void 0, r)
                }
            }
            )(o)
              , s = e.length > 1 ? z(t[n], (t=>L(e, (e=>e.name === t)))).join(" > ") : e[0].name;
            return kn(n, ((e,t)=>({
                handler: e,
                purpose: t
            }))(r, s))
        }
        ))));
        return ((e,t)=>{
            const n = (e=>{
                const t = []
                  , n = [];
                return j(e, (e=>{
                    e.fold((e=>{
                        t.push(e)
                    }
                    ), (e=>{
                        n.push(e)
                    }
                    ))
                }
                )),
                {
                    errors: t,
                    values: n
                }
            }
            )(e);
            return n.errors.length > 0 ? (o = n.errors,
            ot.error(Y(o))) : ((e,t)=>0 === e.length ? ot.value(t) : ot.value(Bt(t, Dt.apply(void 0, e))))(n.values, t);
            var o
        }
        )(n, {})
    }
      , zs = "alloy.base.behaviour"
      , $s = Yt([mn("dom", "dom", {
        tag: "required",
        process: {}
    }, Yt([pn("tag"), wn("styles", {}), wn("classes", []), wn("attributes", {}), bn("value"), bn("innerHtml")])), pn("components"), pn("uid"), wn("events", {}), wn("apis", {}), mn("eventOrder", "eventOrder", (Fa = {
        [Fo()]: ["disabling", zs, "toggling", "typeaheadevents"],
        [Ao()]: [zs, "focusing", "keying"],
        [Io()]: [zs, "disabling", "toggling", "representing"],
        [wo()]: [zs, "representing", "streaming", "invalidating"],
        [Wo()]: [zs, "representing", "item-events", "tooltipping"],
        [bo()]: ["focusing", zs, "item-type-events"],
        [ho()]: ["focusing", zs, "item-type-events"],
        [yo()]: ["item-type-events", "tooltipping"],
        [No()]: ["receiving", "reflecting", "tooltipping"]
    },
    Vt(v(Fa))), Xt()), bn("domModification")])
      , qs = e=>e.events
      , Gs = (e,t)=>{
        const n = Dr(e, t);
        return void 0 === n || "" === n ? [] : n.split(" ")
    }
      , Ks = e=>void 0 !== e.dom.classList
      , Ys = e=>Gs(e, "class")
      , Qs = (e,t)=>{
        Ks(e) ? e.dom.classList.add(t) : ((e,t)=>{
            ((e,t,n)=>{
                const o = Gs(e, t).concat([n]);
                Fr(e, t, o.join(" "))
            }
            )(e, "class", t)
        }
        )(e, t)
    }
      , Js = (e,t)=>{
        Ks(e) ? e.dom.classList.remove(t) : ((e,t)=>{
            ((e,t,n)=>{
                const o = z(Gs(e, t), (e=>e !== n));
                o.length > 0 ? Fr(e, t, o.join(" ")) : Ir(e, t)
            }
            )(e, "class", t)
        }
        )(e, t),
        (e=>{
            0 === (Ks(e) ? e.dom.classList : Ys(e)).length && Ir(e, "class")
        }
        )(e)
    }
      , Xs = (e,t)=>Ks(e) && e.dom.classList.contains(t)
      , Zs = (e,t)=>{
        j(t, (t=>{
            Qs(e, t)
        }
        ))
    }
      , ea = (e,t)=>{
        j(t, (t=>{
            Js(e, t)
        }
        ))
    }
      , ta = e=>void 0 !== e.style && m(e.style.getPropertyValue)
      , na = (e,t,n)=>{
        if (!r(n))
            throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e),
            new Error("CSS value must be a string: " + n);
        ta(e) && e.style.setProperty(t, n)
    }
      , oa = (e,t)=>{
        ta(e) && e.style.removeProperty(t)
    }
      , ra = (e,t,n)=>{
        const o = e.dom;
        na(o, t, n)
    }
      , sa = (e,t)=>{
        const n = e.dom;
        He(t, ((e,t)=>{
            na(n, t, e)
        }
        ))
    }
      , aa = (e,t)=>{
        const n = e.dom;
        He(t, ((e,t)=>{
            e.fold((()=>{
                oa(n, t)
            }
            ), (e=>{
                na(n, t, e)
            }
            ))
        }
        ))
    }
      , ia = (e,t)=>{
        const n = e.dom
          , o = window.getComputedStyle(n).getPropertyValue(t);
        return "" !== o || ct(e) ? o : ca(n, t)
    }
      , ca = (e,t)=>ta(e) ? e.style.getPropertyValue(t) : ""
      , la = (e,t)=>{
        const n = e.dom
          , o = ca(n, t);
        return E.from(o).filter((e=>e.length > 0))
    }
      , ua = (e,t)=>{
        const n = e.dom;
        oa(n, t),
        cr(Hr(e, "style").map(Vn), "") && Ir(e, "style")
    }
      , da = e=>e.dom.offsetWidth
      , ma = e=>e.dom.value
      , ga = (e,t)=>{
        if (void 0 === t)
            throw new Error("Value.set was undefined");
        e.dom.value = t
    }
      , pa = (e,t,n)=>{
        n.fold((()=>Fe(e, t)), (e=>{
            ie(e, t) || (Re(e, t),
            Ar(e))
        }
        ))
    }
      , ha = (e,t,n)=>{
        const o = U(t, n)
          , r = ye(e);
        return j(r.slice(o.length), Ar),
        o
    }
      , va = (e,t,n,o)=>{
        const r = _e(e, t)
          , s = o(n, r)
          , a = ((e,t,n)=>_e(e, t).map((e=>{
            if (n.exists((t=>!ie(t, e)))) {
                const t = n.map(ce).getOr("span")
                  , o = A(t);
                return Re(e, o),
                o
            }
            return e
        }
        )))(e, t, r);
        return pa(e, s.element, a),
        s
    }
      , fa = (e,t)=>{
        const n = Be(e)
          , o = Be(t)
          , r = Z(o, n)
          , s = ((e,n)=>{
            const o = {}
              , r = {};
            return We(e, ((e,n)=>!$e(t, n) || e !== t[n]), Ve(o), Ve(r)),
            {
                t: o,
                f: r
            }
        }
        )(e).t;
        return {
            toRemove: r,
            toSet: s
        }
    }
      , ba = (e,t)=>{
        const {class: n, style: o, ...r} = (e=>q(e.dom.attributes, ((e,t)=>(e[t.name] = t.value,
        e)), {}))(t)
          , {toSet: s, toRemove: a} = fa(e.attributes, r)
          , i = (e=>{
            const t = {}
              , n = e.dom;
            if (ta(n))
                for (let e = 0; e < n.style.length; e++) {
                    const o = n.style.item(e);
                    t[o] = n.style[o]
                }
            return t
        }
        )(t)
          , {toSet: c, toRemove: l} = fa(e.styles, i)
          , u = (e=>Ks(e) ? (e=>{
            const t = e.dom.classList
              , n = new Array(t.length);
            for (let e = 0; e < t.length; e++) {
                const o = t.item(e);
                null !== o && (n[e] = o)
            }
            return n
        }
        )(e) : Ys(e))(t)
          , d = Z(u, e.classes)
          , m = Z(e.classes, u);
        return j(a, (e=>Ir(t, e))),
        Br(t, s),
        Zs(t, m),
        ea(t, d),
        j(l, (e=>ua(t, e))),
        sa(t, c),
        e.innerHtml.fold((()=>{
            const n = e.domChildren;
            ((e,t)=>{
                ha(e, t, ((t,n)=>{
                    const o = _e(e, n);
                    return pa(e, t, o),
                    t
                }
                ))
            }
            )(t, n)
        }
        ), (e=>{
            Rr(t, e)
        }
        )),
        (()=>{
            const n = t
              , o = e.value.getOrUndefined();
            o !== ma(n) && ga(n, null != o ? o : "")
        }
        )(),
        t
    }
      , ya = e=>{
        const t = (e=>{
            const t = ze(e, "behaviours").getOr({});
            return Q(Be(t), (e=>{
                const n = t[e];
                return d(n) ? [n.me] : []
            }
            ))
        }
        )(e);
        return ((e,t)=>((e,t)=>{
            const n = U(t, (e=>_n(e.name(), [pn("config"), wn("state", Sn)])))
              , o = an("component.behaviours", Yt(n), e.behaviours).fold((t=>{
                throw new Error(un(t) + "\nComplete spec:\n" + JSON.stringify(e, null, 2))
            }
            ), f);
            return {
                list: t,
                data: Pe(o, (e=>{
                    const t = e.map((e=>({
                        config: e.config,
                        state: e.state.init(e.config)
                    })));
                    return v(t)
                }
                ))
            }
        }
        )(e, t))(e, t)
    }
      , _a = (e,t)=>{
        const n = ()=>g
          , o = mt(Fs)
          , r = cn((e=>an("custom.definition", $s, e))(e))
          , s = ya(e)
          , a = (e=>e.list)(s)
          , i = (e=>e.data)(s)
          , c = ((e,t,n)=>{
            const o = {
                ...(r = e).dom,
                uid: r.uid,
                domChildren: U(r.components, (e=>e.element))
            };
            var r;
            const s = (e=>e.domModification.fold((()=>gr({})), gr))(e)
              , a = {
                "alloy.base.modification": s
            }
              , i = t.length > 0 ? ((e,t,n,o)=>{
                const r = {
                    ...t
                };
                j(n, (t=>{
                    r[t.name()] = t.exhibit(e, o)
                }
                ));
                const s = Is(r, ((e,t)=>({
                    name: e,
                    modification: t
                })))
                  , a = e=>$(e, ((e,t)=>({
                    ...t.modification,
                    ...e
                })), {})
                  , i = $(s.classes, ((e,t)=>t.modification.concat(e)), [])
                  , c = a(s.attributes)
                  , l = a(s.styles);
                return gr({
                    classes: i,
                    attributes: c,
                    styles: l
                })
            }
            )(n, a, t, o) : s;
            return c = o,
            l = i,
            {
                ...c,
                attributes: {
                    ...c.attributes,
                    ...l.attributes
                },
                styles: {
                    ...c.styles,
                    ...l.styles
                },
                classes: c.classes.concat(l.classes)
            };
            var c, l
        }
        )(r, a, i)
          , l = ((e,t)=>{
            const n = t.filter((t=>ce(t) === e.tag && !(e=>e.innerHtml.isSome() && e.domChildren.length > 0)(e) && !(e=>$e(e.dom, Bs))(t))).bind((t=>((e,t)=>{
                try {
                    const n = ba(e, t);
                    return E.some(n)
                } catch (e) {
                    return E.none()
                }
            }
            )(e, t))).getOrThunk((()=>(e=>{
                const t = A(e.tag);
                Br(t, e.attributes),
                Zs(t, e.classes),
                sa(t, e.styles),
                e.innerHtml.each((e=>Rr(t, e)));
                const n = e.domChildren;
                return kr(t, n),
                e.value.each((e=>{
                    ga(t, e)
                }
                )),
                t
            }
            )(e)));
            return Ss(n, e.uid),
            n
        }
        )(c, t)
          , u = ((e,t,n)=>{
            const o = {
                "alloy.base.behaviour": qs(e)
            };
            return ((e,t,n,o)=>{
                const r = ((e,t,n)=>{
                    const o = {
                        ...n,
                        ...Ls(t, e)
                    };
                    return Is(o, Ws)
                }
                )(e, n, o);
                return js(r, t)
            }
            )(n, e.eventOrder, t, o).getOrDie()
        }
        )(r, a, i)
          , d = mt(r.components)
          , g = {
            uid: e.uid,
            getSystem: o.get,
            config: t=>{
                const n = i;
                return (m(n[t.name()]) ? n[t.name()] : ()=>{
                    throw new Error("Could not find " + t.name() + " in " + JSON.stringify(e, null, 2))
                }
                )()
            }
            ,
            hasConfigured: e=>m(i[e.name()]),
            spec: e,
            readState: e=>i[e]().map((e=>e.state.readState())).getOr("not enabled"),
            getApis: ()=>r.apis,
            connect: e=>{
                o.set(e)
            }
            ,
            disconnect: ()=>{
                o.set(Ns(n))
            }
            ,
            element: l,
            syncComponents: ()=>{
                const e = ye(l)
                  , t = Q(e, (e=>o.get().getByDom(e).fold((()=>[]), te)));
                d.set(t)
            }
            ,
            components: d.get,
            events: u
        };
        return g
    }
      , xa = e=>{
        const t = M(e);
        return wa({
            element: t
        })
    }
      , wa = e=>{
        const t = ln("external.component", Kt([pn("element"), bn("uid")]), e)
          , n = mt(Ns())
          , o = t.uid.getOrThunk((()=>Es("external")));
        Ss(t.element, o);
        const r = {
            uid: o,
            getSystem: n.get,
            config: E.none,
            hasConfigured: w,
            connect: e=>{
                n.set(e)
            }
            ,
            disconnect: ()=>{
                n.set(Ns((()=>r)))
            }
            ,
            getApis: ()=>({}),
            element: t.element,
            spec: e,
            readState: v("No state"),
            syncComponents: p,
            components: v([]),
            events: {}
        };
        return Ds(r)
    }
      , Oa = Es
      , Sa = (e,t)=>Hs(e).getOrThunk((()=>((e,t)=>{
        const {events: n, ...o} = Rs(e)
          , r = ((e,t)=>{
            const n = ze(e, "components").getOr([]);
            return t.fold((()=>U(n, Ca)), (e=>U(n, ((t,n)=>Sa(t, _e(e, n))))))
        }
        )(o, t)
          , s = {
            ...o,
            events: {
                ...Ms,
                ...n
            },
            components: r
        };
        return ot.value(_a(s, t))
    }
    )((e=>$e(e, "uid"))(e) ? e : {
        uid: Oa(""),
        ...e
    }, t).getOrDie()))
      , Ca = e=>Sa(e, E.none())
      , Ea = Ds
      , ka = (e,t)=>((e,t,n)=>On(e, {}, Yt(n)))(e, 0, U(t, (t=>{
        return n = t.name(),
        o = "Cannot configure " + t.name() + " for " + e,
        mn(n, n, {
            tag: "option",
            process: {}
        }, jt((e=>At("The field: " + n + " is forbidden. " + o))));
        var n, o
    }
    )).concat([gn("dump", f)]))
      , Ta = (e,t)=>({
        ...fr(t),
        ...e.dump
    })
      , Aa = ka
      , Ma = Ta
      , Ra = v([pn("menu"), pn("selectedMenu")])
      , Na = v([pn("item"), pn("selectedItem")]);
    var Fa;
    v(Yt(Na().concat(Ra())));
    const Ba = v(Yt(Na()))
      , Da = fn("initSize", [pn("numColumns"), pn("numRows")])
      , Ha = ()=>fn("markers", [pn("backgroundMenu")].concat(Ra()).concat(Na()))
      , Pa = (e,t,n)=>((()=>{
        const e = new Error;
        if (void 0 !== e.stack) {
            const t = e.stack.split("\n");
            G(t, (e=>e.indexOf("alloy") > 0 && !L(jr, (t=>e.indexOf(t) > -1)))).getOr("unknown")
        }
    }
    )(),
    mn(t, t, n, rn((e=>ot.value(((...t)=>e.apply(void 0, t)))))))
      , Ia = e=>Pa(0, e, It(p))
      , Va = e=>Pa(0, e, It(E.none))
      , Wa = e=>Pa(0, e, {
        tag: "required",
        process: {}
    })
      , La = e=>Pa(0, e, {
        tag: "required",
        process: {}
    })
      , Ua = (e,t)=>gn(e, v(t))
      , ja = e=>gn(e, f)
      , za = v(Da)
      , $a = "placeholder"
      , qa = En([{
        single: ["required", "valueThunk"]
    }, {
        multiple: ["required", "valueThunks"]
    }])
      , Ga = e=>$e(e, "uiType")
      , Ka = (e,t,n,o)=>((e,t,n,o)=>Ga(n) && n.uiType === $a ? ((e,t,n,o)=>e.exists((e=>e !== n.owner)) ? qa.single(!0, v(n)) : ze(o, n.name).fold((()=>{
        throw new Error("Unknown placeholder component: " + n.name + "\nKnown: [" + Be(o) + "]\nNamespace: " + e.getOr("none") + "\nSpec: " + JSON.stringify(n, null, 2))
    }
    ), (e=>e.replace())))(e, 0, n, o) : qa.single(!1, v(n)))(e, 0, n, o).fold(((r,s)=>{
        const a = Ga(n) ? s(t, n.config, n.validated) : s(t)
          , i = ze(a, "components").getOr([])
          , c = Q(i, (n=>Ka(e, t, n, o)));
        return [{
            ...a,
            components: c
        }]
    }
    ), ((e,o)=>{
        if (Ga(n)) {
            const e = o(t, n.config, n.validated);
            return n.validated.preprocess.getOr(f)(e)
        }
        return o(t)
    }
    ))
      , Ya = qa.single
      , Qa = qa.multiple
      , Ja = v($a)
      , Xa = En([{
        required: ["data"]
    }, {
        external: ["data"]
    }, {
        optional: ["data"]
    }, {
        group: ["data"]
    }])
      , Za = wn("factory", {
        sketch: f
    })
      , ei = wn("schema", [])
      , ti = pn("name")
      , ni = mn("pname", "pname", Pt((e=>"<alloy." + ys(e.name) + ">")), Xt())
      , oi = gn("schema", (()=>[bn("preprocess")]))
      , ri = wn("defaults", v({}))
      , si = wn("overrides", v({}))
      , ai = Yt([Za, ei, ti, ni, ri, si])
      , ii = Yt([Za, ei, ti, ri, si])
      , ci = Yt([Za, ei, ti, ni, ri, si])
      , li = Yt([Za, oi, ti, pn("unit"), ni, ri, si])
      , ui = e=>{
        const t = e=>e.name;
        return e.fold(t, t, t, t)
    }
      , di = (e,t)=>n=>{
        const o = ln("Converting part type", t, n);
        return e(o)
    }
      , mi = di(Xa.required, ai)
      , gi = di(Xa.external, ii)
      , pi = di(Xa.optional, ci)
      , hi = di(Xa.group, li)
      , vi = v("entirety")
      , fi = (e,t,n,o)=>Bt(t.defaults(e, n, o), n, {
        uid: e.partUids[t.name]
    }, t.overrides(e, n, o))
      , bi = (e,t)=>({
        uiType: Ja(),
        owner: e,
        name: t
    })
      , yi = (e,t,n)=>((e,t,n)=>{
        const o = {}
          , r = {};
        return j(n, (e=>{
            e.fold((e=>{
                o[e.pname] = Ya(!0, ((t,n,o)=>e.factory.sketch(fi(t, e, n, o))))
            }
            ), (e=>{
                const n = t.parts[e.name];
                r[e.name] = v(e.factory.sketch(fi(t, e, n[vi()]), n))
            }
            ), (e=>{
                o[e.pname] = Ya(!1, ((t,n,o)=>e.factory.sketch(fi(t, e, n, o))))
            }
            ), (e=>{
                o[e.pname] = Qa(!0, ((t,n,o)=>{
                    const r = t[e.name];
                    return U(r, (n=>e.factory.sketch(Bt(e.defaults(t, n, o), n, e.overrides(t, n)))))
                }
                ))
            }
            ))
        }
        )),
        {
            internals: v(o),
            externals: v(r)
        }
    }
    )(0, t, n)
      , _i = (e,t,n)=>((e,t,n,o)=>{
        const r = Pe(o, ((e,t)=>((e,t)=>{
            let n = !1;
            return {
                name: v(e),
                required: ()=>t.fold(((e,t)=>e), ((e,t)=>e)),
                used: ()=>n,
                replace: ()=>{
                    if (n)
                        throw new Error("Trying to use the same placeholder more than once: " + e);
                    return n = !0,
                    t
                }
            }
        }
        )(t, e)))
          , s = ((e,t,n,o)=>Q(n, (n=>Ka(e, t, n, o))))(e, t, n, r);
        return He(r, (n=>{
            if (!1 === n.used() && n.required())
                throw new Error("Placeholder: " + n.name() + " was not found in components list\nNamespace: " + e.getOr("none") + "\nComponents: " + JSON.stringify(t.components, null, 2))
        }
        )),
        s
    }
    )(E.some(e), t, t.components, n)
      , xi = e=>mn("partUids", "partUids", Vt((t=>((e,t)=>{
        const n = (e=>U(e, ui))(t);
        return Tn(U(n, (t=>({
            key: t,
            value: e + "-" + t
        }))))
    }
    )(t.uid, e))), Xt())
      , wi = (e,t,n,o,r)=>{
        const s = ((e,t)=>(e.length > 0 ? [fn("parts", e)] : []).concat([pn("uid"), wn("dom", {}), wn("components", []), ja("originalSpec"), wn("debug.sketcher", {})]).concat(t))(o, r);
        return ln(e + " [SpecSchema]", Kt(s.concat(t)), n)
    }
      , Oi = e=>(e=>$e(e, "uid"))(e) ? e : {
        ...e,
        uid: Es("uid")
    }
      , Si = Kt([pn("name"), pn("factory"), pn("configFields"), wn("apis", {}), wn("extraApis", {})])
      , Ci = Kt([pn("name"), pn("factory"), pn("configFields"), pn("partFields"), wn("apis", {}), wn("extraApis", {})])
      , Ei = e=>{
        const t = ln("Sketcher for " + e.name, Si, e)
          , n = Pe(t.apis, Ps)
          , o = Pe(t.extraApis, ((e,t)=>mr(e, t)));
        return {
            name: t.name,
            configFields: t.configFields,
            sketch: e=>((e,t,n,o)=>{
                const r = Oi(o);
                return n(wi(e, t, r, [], []), r)
            }
            )(t.name, t.configFields, t.factory, e),
            ...n,
            ...o
        }
    }
      , ki = e=>{
        const t = ln("Sketcher for " + e.name, Ci, e)
          , n = ((e,t)=>{
            const n = {};
            return j(t, (t=>{
                (e=>e.fold(E.some, E.none, E.some, E.some))(t).each((t=>{
                    const o = bi(e, t.pname);
                    n[t.name] = n=>{
                        const r = ln("Part: " + t.name + " in " + e, Yt(t.schema), n);
                        return {
                            ...o,
                            config: n,
                            validated: r
                        }
                    }
                }
                ))
            }
            )),
            n
        }
        )(t.name, t.partFields)
          , o = Pe(t.apis, Ps)
          , r = Pe(t.extraApis, ((e,t)=>mr(e, t)));
        return {
            name: t.name,
            partFields: t.partFields,
            configFields: t.configFields,
            sketch: e=>((e,t,n,o,r)=>{
                const s = Oi(r)
                  , a = (e=>Q(e, (e=>e.fold(E.none, E.some, E.none, E.none).map((e=>fn(e.name, e.schema.concat([ja(vi())])))).toArray())))(n)
                  , i = xi(n)
                  , c = wi(e, t, s, a, [i])
                  , l = yi(0, c, n);
                return o(c, _i(e, c, l.internals()), s, l.externals())
            }
            )(t.name, t.configFields, t.partFields, t.factory, e),
            parts: n,
            ...o,
            ...r
        }
    }
    ;
    Ei({
        name: "Container",
        factory: e=>{
            const {attributes: t, ...n} = e.dom;
            return {
                uid: e.uid,
                dom: {
                    tag: "div",
                    attributes: {
                        role: "presentation",
                        ...t
                    },
                    ...n
                },
                components: e.components,
                behaviours: (o = e.containerBehaviours,
                o.dump),
                events: e.events,
                domModification: e.domModification,
                eventOrder: e.eventOrder
            };
            var o
        }
        ,
        configFields: [wn("components", []), ka("containerBehaviours", []), wn("events", {}), wn("domModification", {}), wn("eventOrder", {})]
    });
    const Ti = e=>e.getSystem().isConnected()
      , Ai = e=>{
        qo(e, Wo());
        const t = e.components();
        j(t, Ai)
    }
      , Mi = e=>{
        const t = e.components();
        j(t, Mi),
        qo(e, Vo())
    }
      , Ri = (e,t)=>{
        e.getSystem().addToWorld(t),
        ct(e.element) && Mi(t)
    }
      , Ni = e=>{
        Ai(e),
        e.getSystem().removeFromWorld(e)
    }
      , Fi = (e,t)=>{
        Fe(e.element, t.element)
    }
      , Bi = (e,t)=>{
        Di(e, t, Fe)
    }
      , Di = (e,t,n)=>{
        e.getSystem().addToWorld(t),
        n(e.element, t.element),
        ct(e.element) && Mi(t),
        e.syncComponents()
    }
      , Hi = e=>{
        Ai(e),
        Ar(e.element),
        e.getSystem().removeFromWorld(e)
    }
      , Pi = e=>{
        const t = be(e.element).bind((t=>e.getSystem().getByDom(t).toOptional()));
        Hi(e),
        t.each((e=>{
            e.syncComponents()
        }
        ))
    }
      , Ii = e=>{
        const t = e.components();
        j(t, Hi),
        Tr(e.element),
        e.syncComponents()
    }
      , Vi = e=>{
        const t = t=>be(e.element).fold(O, (e=>ie(t, e)))
          , n = Ts()
          , o = (e,o)=>n.find(t, e, o)
          , r = ((e,t)=>{
            const n = {
                stopBackspace: !0,
                ...t
            }
              , o = ms(n)
              , r = U(["touchstart", "touchmove", "touchend", "touchcancel", "gesturestart", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "click"].concat(["selectstart", "input", "contextmenu", "change", "transitionend", "transitioncancel", "drag", "dragstart", "dragend", "dragenter", "dragleave", "dragover", "drop", "keyup"]), (t=>Me(e, t, (e=>{
                o.fireIfReady(e, t).each((t=>{
                    t && e.kill()
                }
                )),
                n.triggerEvent(t, e) && e.kill()
            }
            ))))
              , s = Yr()
              , a = Me(e, "paste", (e=>{
                o.fireIfReady(e, "paste").each((t=>{
                    t && e.kill()
                }
                )),
                n.triggerEvent("paste", e) && e.kill(),
                s.set(setTimeout((()=>{
                    n.triggerEvent(Ro(), e)
                }
                ), 0))
            }
            ))
              , i = Me(e, "keydown", (e=>{
                n.triggerEvent("keydown", e) ? e.kill() : n.stopBackspace && (e=>{
                    return e.raw.which === ns[0] && !W(["input", "textarea"], ce(e.target)) && (t = e.target,
                    !ts(t, '[contenteditable="true"]', void 0).isSome());
                    var t
                }
                )(e) && e.prevent()
            }
            ))
              , c = Me(e, "focusin", (e=>{
                n.triggerEvent("focusin", e) && e.kill()
            }
            ))
              , l = Yr()
              , u = Me(e, "focusout", (e=>{
                n.triggerEvent("focusout", e) && e.kill(),
                l.set(setTimeout((()=>{
                    n.triggerEvent(Mo(), e)
                }
                ), 0))
            }
            ));
            return {
                unbind: ()=>{
                    j(r, (e=>{
                        e.unbind()
                    }
                    )),
                    i.unbind(),
                    c.unbind(),
                    u.unbind(),
                    a.unbind(),
                    s.on(clearTimeout),
                    l.on(clearTimeout)
                }
            }
        }
        )(e.element, {
            triggerEvent: (e,t)=>zr(e, t.target, (n=>((e,t,n,o)=>fs(e, t, n, n.target, o))(o, e, t, n)))
        })
          , s = {
            debugInfo: v("real"),
            triggerEvent: (e,t,n)=>{
                zr(e, t, (r=>fs(o, e, n, t, r)))
            }
            ,
            triggerFocus: (e,t)=>{
                Cs(e).fold((()=>{
                    Sr(e)
                }
                ), (n=>{
                    zr(Ao(), e, (n=>(((e,t,n,o,r)=>{
                        const s = gs(n, o);
                        hs(e, t, n, o, s, r)
                    }
                    )(o, Ao(), {
                        originator: t,
                        kill: p,
                        prevent: p,
                        target: e
                    }, e, n),
                    !1)))
                }
                ))
            }
            ,
            triggerEscape: (e,t)=>{
                s.triggerEvent("keydown", e.element, t.event)
            }
            ,
            getByUid: e=>h(e),
            getByDom: e=>f(e),
            build: Ca,
            buildOrPatch: Sa,
            addToGui: e=>{
                c(e)
            }
            ,
            removeFromGui: e=>{
                l(e)
            }
            ,
            addToWorld: e=>{
                a(e)
            }
            ,
            removeFromWorld: e=>{
                i(e)
            }
            ,
            broadcast: e=>{
                d(e)
            }
            ,
            broadcastOn: (e,t)=>{
                m(e, t)
            }
            ,
            broadcastEvent: (e,t)=>{
                g(e, t)
            }
            ,
            isConnected: O
        }
          , a = e=>{
            e.connect(s),
            de(e.element) || (n.register(e),
            j(e.components(), a),
            s.triggerEvent(Io(), e.element, {
                target: e.element
            }))
        }
          , i = e=>{
            de(e.element) || (j(e.components(), i),
            n.unregister(e)),
            e.disconnect()
        }
          , c = t=>{
            Bi(e, t)
        }
          , l = e=>{
            Pi(e)
        }
          , u = e=>{
            const t = n.filter(No());
            j(t, (t=>{
                const n = t.descHandler;
                qr(n)(e)
            }
            ))
        }
          , d = e=>{
            u({
                universal: !0,
                data: e
            })
        }
          , m = (e,t)=>{
            u({
                universal: !1,
                channels: e,
                data: t
            })
        }
          , g = (e,t)=>((e,t,n)=>{
            const o = (e=>{
                const t = mt(!1);
                return {
                    stop: ()=>{
                        t.set(!0)
                    }
                    ,
                    cut: p,
                    isStopped: t.get,
                    isCut: w,
                    event: e,
                    setSource: _("Cannot set source of a broadcasted event"),
                    getSource: _("Cannot get source of a broadcasted event")
                }
            }
            )(t);
            return j(e, (e=>{
                const t = e.descHandler;
                qr(t)(o)
            }
            )),
            o.isStopped()
        }
        )(n.filter(e), t)
          , h = e=>n.getById(e).fold((()=>ot.error(new Error('Could not find component with uid: "' + e + '" in system.'))), ot.value)
          , f = e=>{
            const t = Cs(e).getOr("not found");
            return h(t)
        }
        ;
        return a(e),
        {
            root: e,
            element: e.element,
            destroy: ()=>{
                r.unbind(),
                Ar(e.element)
            }
            ,
            add: c,
            remove: l,
            getByUid: h,
            getByDom: f,
            addToWorld: a,
            removeFromWorld: i,
            broadcast: d,
            broadcastOn: m,
            broadcastEvent: g
        }
    }
      , Wi = e=>{
        const t = (e=>void 0 !== e.uid)(e) && qe(e, "uid") ? e.uid : Es("memento");
        return {
            get: e=>e.getSystem().getByUid(t).getOrDie(),
            getOpt: e=>e.getSystem().getByUid(t).toOptional(),
            asSpec: ()=>({
                ...e,
                uid: t
            })
        }
    }
    ;
    var Li = Object.freeze({
        __proto__: null,
        exhibit: (e,t)=>gr({
            classes: [],
            styles: t.useFixed() ? {} : {
                position: "relative"
            }
        })
    });
    const Ui = (e,t)=>({
        left: e,
        top: t,
        translate: (n,o)=>Ui(e + n, t + o)
    })
      , ji = Ui
      , zi = (e,t)=>void 0 !== e ? e : void 0 !== t ? t : 0
      , $i = e=>{
        const t = e.dom.ownerDocument
          , n = t.body
          , o = t.defaultView
          , r = t.documentElement;
        if (n === e.dom)
            return ji(n.offsetLeft, n.offsetTop);
        const s = zi(null == o ? void 0 : o.pageYOffset, r.scrollTop)
          , a = zi(null == o ? void 0 : o.pageXOffset, r.scrollLeft)
          , i = zi(r.clientTop, n.clientTop)
          , c = zi(r.clientLeft, n.clientLeft);
        return qi(e).translate(a - c, s - i)
    }
      , qi = e=>{
        const t = e.dom
          , n = t.ownerDocument.body;
        return n === t ? ji(n.offsetLeft, n.offsetTop) : ct(e) ? (e=>{
            const t = e.getBoundingClientRect();
            return ji(t.left, t.top)
        }
        )(t) : ji(0, 0)
    }
      , Gi = (e,t)=>{
        const n = n=>{
            const o = t(n);
            if (o <= 0 || null === o) {
                const t = ia(n, e);
                return parseFloat(t) || 0
            }
            return o
        }
          , o = (e,t)=>q(t, ((t,n)=>{
            const o = ia(e, n)
              , r = void 0 === o ? 0 : parseInt(o, 10);
            return isNaN(r) ? t : t + r
        }
        ), 0);
        return {
            set: (t,n)=>{
                if (!g(n) && !n.match(/^[0-9]+$/))
                    throw new Error(e + ".set accepts only positive integer values. Value was " + n);
                const o = t.dom;
                ta(o) && (o.style[e] = n + "px")
            }
            ,
            get: n,
            getOuter: n,
            aggregate: o,
            max: (e,t,n)=>{
                const r = o(e, n);
                return t > r ? t - r : 0
            }
        }
    }
      , Ki = Gi("height", (e=>{
        const t = e.dom;
        return ct(e) ? t.getBoundingClientRect().height : t.offsetHeight
    }
    ))
      , Yi = e=>Ki.get(e)
      , Qi = e=>Ki.getOuter(e)
      , Ji = Gi("width", (e=>e.dom.offsetWidth))
      , Xi = e=>Ji.get(e)
      , Zi = e=>Ji.getOuter(e)
      , ec = e=>{
        const t = void 0 !== e ? e.dom : document
          , n = t.body.scrollLeft || t.documentElement.scrollLeft
          , o = t.body.scrollTop || t.documentElement.scrollTop;
        return ji(n, o)
    }
      , tc = (e,t,n,o)=>({
        x: e,
        y: t,
        width: n,
        height: o,
        right: e + n,
        bottom: t + o
    })
      , nc = (e,t)=>e.view(t).fold(v([]), (t=>{
        const n = e.owner(t)
          , o = nc(e, n);
        return [t].concat(o)
    }
    ));
    var oc = Object.freeze({
        __proto__: null,
        view: e=>{
            var t;
            return (e.dom === document ? E.none() : E.from(null === (t = e.dom.defaultView) || void 0 === t ? void 0 : t.frameElement)).map(R)
        }
        ,
        owner: e=>he(e)
    });
    const rc = e=>{
        const t = Or()
          , n = ec(t)
          , o = ((e,t)=>{
            const n = t.owner(e)
              , o = nc(t, n);
            return E.some(o)
        }
        )(e, oc);
        return o.fold(y($i, e), (t=>{
            const o = qi(e)
              , r = $(t, ((e,t)=>{
                const n = qi(t);
                return {
                    left: e.left + n.left,
                    top: e.top + n.top
                }
            }
            ), {
                left: 0,
                top: 0
            });
            return ji(r.left + o.left + n.left, r.top + o.top + n.top)
        }
        ))
    }
      , sc = (e,t,n,o)=>({
        x: e,
        y: t,
        width: n,
        height: o,
        right: e + n,
        bottom: t + o
    })
      , ac = e=>{
        const t = $i(e)
          , n = Zi(e)
          , o = Qi(e);
        return sc(t.left, t.top, n, o)
    }
      , ic = ()=>(e=>{
        const t = void 0 === e ? window : e
          , n = t.document
          , o = ec(R(n));
        return (e=>{
            const t = void 0 === e ? window : e;
            return go().browser.isFirefox() ? E.none() : E.from(t.visualViewport)
        }
        )(t).fold((()=>{
            const e = t.document.documentElement
              , n = e.clientWidth
              , r = e.clientHeight;
            return tc(o.left, o.top, n, r)
        }
        ), (e=>tc(Math.max(e.pageLeft, o.left), Math.max(e.pageTop, o.top), e.width, e.height)))
    }
    )(window)
      , cc = (e,t)=>{
        const n = Ce(t)
          , o = Cr(n).bind((e=>{
            const n = t=>ie(e, t);
            return n(t) ? E.some(t) : ((e,t)=>{
                const n = e=>{
                    for (let o = 0; o < e.childNodes.length; o++) {
                        const r = R(e.childNodes[o]);
                        if (t(r))
                            return E.some(r);
                        const s = n(e.childNodes[o]);
                        if (s.isSome())
                            return s
                    }
                    return E.none()
                }
                ;
                return n(e.dom)
            }
            )(t, n)
        }
        ))
          , r = e(t);
        return o.each((e=>{
            Cr(n).filter((t=>ie(t, e))).fold((()=>{
                Sr(e)
            }
            ), p)
        }
        )),
        r
    }
      , lc = (e,t,n,o,r)=>{
        const s = e=>e + "px";
        return {
            position: e,
            left: t.map(s),
            top: n.map(s),
            right: o.map(s),
            bottom: r.map(s)
        }
    }
      , uc = En([{
        southeast: []
    }, {
        southwest: []
    }, {
        northeast: []
    }, {
        northwest: []
    }, {
        south: []
    }, {
        north: []
    }, {
        east: []
    }, {
        west: []
    }])
      , dc = uc.southeast
      , mc = uc.southwest
      , gc = uc.northeast
      , pc = uc.northwest
      , hc = uc.south
      , vc = uc.north
      , fc = uc.east
      , bc = uc.west
      , yc = En([{
        none: []
    }, {
        relative: ["x", "y", "width", "height"]
    }, {
        fixed: ["x", "y", "width", "height"]
    }])
      , _c = (e,t,n,o,r,s)=>{
        const a = t.rect
          , i = a.x - n
          , c = a.y - o
          , l = r - (i + a.width)
          , u = s - (c + a.height)
          , d = E.some(i)
          , m = E.some(c)
          , g = E.some(l)
          , p = E.some(u)
          , h = E.none();
        return t.direction.fold((()=>lc(e, d, m, h, h)), (()=>lc(e, h, m, g, h)), (()=>lc(e, d, h, h, p)), (()=>lc(e, h, h, g, p)), (()=>lc(e, d, m, h, h)), (()=>lc(e, d, h, h, p)), (()=>lc(e, d, m, h, h)), (()=>lc(e, h, m, g, h)))
    }
      , xc = (e,t)=>e.fold((()=>{
        const e = t.rect;
        return lc("absolute", E.some(e.x), E.some(e.y), E.none(), E.none())
    }
    ), ((e,n,o,r)=>_c("absolute", t, e, n, o, r)), ((e,n,o,r)=>_c("fixed", t, e, n, o, r)))
      , wc = (e,t)=>{
        const n = y(rc, t)
          , o = e.fold(n, n, (()=>{
            const e = ec();
            return rc(t).translate(-e.left, -e.top)
        }
        ))
          , r = Zi(t)
          , s = Qi(t);
        return sc(o.left, o.top, r, s)
    }
      , Oc = (e,t)=>t.fold((()=>e.fold(ic, ic, sc)), (t=>e.fold(t, t, (()=>{
        const n = t()
          , o = Sc(e, n.x, n.y);
        return sc(o.left, o.top, n.width, n.height)
    }
    ))))
      , Sc = (e,t,n)=>{
        const o = ji(t, n);
        return e.fold(v(o), v(o), (()=>{
            const e = ec();
            return o.translate(-e.left, -e.top)
        }
        ))
    }
    ;
    yc.none;
    const Cc = yc.relative
      , Ec = yc.fixed
      , kc = "data-alloy-placement"
      , Tc = (e,t,n,o)=>{
        const r = e + t;
        return r > o ? n : r < n ? o : r
    }
      , Ac = (e,t,n)=>Math.min(Math.max(e, t), n)
      , Mc = (e,t)=>ee(["left", "right", "top", "bottom"], (n=>ze(t, n).map((t=>((e,t)=>{
        switch (t) {
        case 1:
            return e.x;
        case 0:
            return e.x + e.width;
        case 2:
            return e.y;
        case 3:
            return e.y + e.height
        }
    }
    )(e, t)))))
      , Rc = En([{
        fit: ["reposition"]
    }, {
        nofit: ["reposition", "visibleW", "visibleH", "isVisible"]
    }])
      , Nc = (e,t,n,o)=>{
        const r = e.bubble
          , s = r.offset
          , a = ((e,t,n)=>{
            const o = (o,r)=>t[o].map((t=>{
                const s = "top" === o || "bottom" === o
                  , a = s ? n.top : n.left
                  , i = ("left" === o || "top" === o ? Math.max : Math.min)(t, r) + a;
                return s ? Ac(i, e.y, e.bottom) : Ac(i, e.x, e.right)
            }
            )).getOr(r)
              , r = o("left", e.x)
              , s = o("top", e.y)
              , a = o("right", e.right)
              , i = o("bottom", e.bottom);
            return sc(r, s, a - r, i - s)
        }
        )(o, e.restriction, s)
          , i = e.x + s.left
          , c = e.y + s.top
          , l = sc(i, c, t, n)
          , {originInBounds: u, sizeInBounds: d, visibleW: m, visibleH: g} = ((e,t)=>{
            const {x: n, y: o, right: r, bottom: s} = t
              , {x: a, y: i, right: c, bottom: l, width: u, height: d} = e;
            return {
                originInBounds: a >= n && a <= r && i >= o && i <= s,
                sizeInBounds: c <= r && c >= n && l <= s && l >= o,
                visibleW: Math.min(u, a >= n ? r - a : c - n),
                visibleH: Math.min(d, i >= o ? s - i : l - o)
            }
        }
        )(l, a)
          , p = u && d
          , h = p ? l : ((e,t)=>{
            const {x: n, y: o, right: r, bottom: s} = t
              , {x: a, y: i, width: c, height: l} = e
              , u = Math.max(n, r - c)
              , d = Math.max(o, s - l)
              , m = Ac(a, n, u)
              , g = Ac(i, o, d)
              , p = Math.min(m + c, r) - m
              , h = Math.min(g + l, s) - g;
            return sc(m, g, p, h)
        }
        )(l, a)
          , f = h.width > 0 && h.height > 0
          , {maxWidth: b, maxHeight: y} = ((e,t,n)=>{
            const o = v(t.bottom - n.y)
              , r = v(n.bottom - t.y)
              , s = ((e,t,n,o)=>e.fold(t, t, o, o, t, o, n, n))(e, r, r, o)
              , a = v(t.right - n.x)
              , i = v(n.right - t.x)
              , c = ((e,t,n,o)=>e.fold(t, o, t, o, n, n, t, o))(e, i, i, a);
            return {
                maxWidth: c,
                maxHeight: s
            }
        }
        )(e.direction, h, o)
          , _ = {
            rect: h,
            maxHeight: y,
            maxWidth: b,
            direction: e.direction,
            placement: e.placement,
            classes: {
                on: r.classesOn,
                off: r.classesOff
            },
            layout: e.label,
            testY: c
        };
        return p || e.alwaysFit ? Rc.fit(_) : Rc.nofit(_, m, g, f)
    }
      , Fc = ["top", "bottom", "right", "left"]
      , Bc = "data-alloy-transition-timer"
      , Dc = (e,t,n,o,s,a)=>{
        const i = ((e,t,n)=>n.exists((n=>{
            const o = e.mode;
            return "all" === o || n[o] !== t[o]
        }
        )))(o, s, a);
        if (i || ((e,t)=>((e,t)=>J(t, (t=>Xs(e, t))))(e, t.classes))(e, o)) {
            ra(e, "position", n.position);
            const a = wc(t, e)
              , c = xc(t, {
                ...s,
                rect: a
            })
              , l = ee(Fc, (e=>c[e]));
            ((e,t)=>{
                const n = e=>parseFloat(e).toFixed(3);
                return je(t, ((t,o)=>!((e,t,n=b)=>ur(e, t, n).getOr(e.isNone() && t.isNone()))(e[o].map(n), t.map(n)))).isSome()
            }
            )(n, l) && (aa(e, l),
            i && ((e,t)=>{
                Zs(e, t.classes),
                Hr(e, Bc).each((t=>{
                    clearTimeout(parseInt(t, 10)),
                    Ir(e, Bc)
                }
                )),
                ((e,t)=>{
                    const n = Kr()
                      , o = Kr();
                    let s;
                    const a = t=>{
                        var n;
                        const o = null !== (n = t.raw.pseudoElement) && void 0 !== n ? n : "";
                        return ie(t.target, e) && !Wn(o) && W(Fc, t.raw.propertyName)
                    }
                      , i = r=>{
                        if (u(r) || a(r)) {
                            n.clear(),
                            o.clear();
                            const a = null == r ? void 0 : r.raw.type;
                            (u(a) || a === Co()) && (clearTimeout(s),
                            Ir(e, Bc),
                            ea(e, t.classes))
                        }
                    }
                      , c = Me(e, Eo(), (t=>{
                        a(t) && (c.unbind(),
                        n.set(Me(e, Co(), i)),
                        o.set(Me(e, So(), i)))
                    }
                    ))
                      , l = (e=>{
                        const t = t=>{
                            const n = ia(e, t).split(/\s*,\s*/);
                            return z(n, Wn)
                        }
                          , n = e=>{
                            if (r(e) && /^[\d.]+/.test(e)) {
                                const t = parseFloat(e);
                                return In(e, "ms") ? t : 1e3 * t
                            }
                            return 0
                        }
                          , o = t("transition-delay")
                          , s = t("transition-duration");
                        return q(s, ((e,t,r)=>{
                            const s = n(o[r]) + n(t);
                            return Math.max(e, s)
                        }
                        ), 0)
                    }
                    )(e);
                    requestAnimationFrame((()=>{
                        s = setTimeout(i, l + 17),
                        Fr(e, Bc, s)
                    }
                    ))
                }
                )(e, t)
            }
            )(e, o),
            da(e))
        } else
            ea(e, o.classes)
    }
      , Hc = v(((e,t)=>{
        ((e,t)=>{
            ((e,t)=>{
                const n = Ki.max(e, t, ["margin-top", "border-top-width", "padding-top", "padding-bottom", "border-bottom-width", "margin-bottom"]);
                ra(e, "max-height", n + "px")
            }
            )(e, Math.floor(t))
        }
        )(e, t),
        sa(e, {
            "overflow-x": "hidden",
            "overflow-y": "auto"
        })
    }
    ))
      , Pc = (e,t,n)=>void 0 === e[t] ? n : e[t]
      , Ic = (e,t,n,o)=>{
        const r = ((e,t,n,o)=>{
            ua(t, "max-height"),
            ua(t, "max-width");
            const r = {
                width: Zi(s = t),
                height: Qi(s)
            };
            var s;
            return ((e,t,n,o,r,s)=>{
                const a = o.width
                  , i = o.height
                  , c = (t,c,l,u,d)=>{
                    const m = t(n, o, r, e, s)
                      , g = Nc(m, a, i, s);
                    return g.fold(v(g), ((e,t,n,o)=>(d === o ? n > u || t > l : !d && o) ? g : Rc.nofit(c, l, u, d)))
                }
                ;
                return q(t, ((e,t)=>{
                    const n = y(c, t);
                    return e.fold(v(e), n)
                }
                ), Rc.nofit({
                    rect: n,
                    maxHeight: o.height,
                    maxWidth: o.width,
                    direction: dc(),
                    placement: "southeast",
                    classes: {
                        on: [],
                        off: []
                    },
                    layout: "none",
                    testY: n.y
                }, -1, -1, !1)).fold(f, f)
            }
            )(t, o.preference, e, r, n, o.bounds)
        }
        )(e, t, n, o);
        return ((e,t,n)=>{
            const o = xc(n.origin, t);
            n.transition.each((r=>{
                Dc(e, n.origin, o, r, t, n.lastPlacement)
            }
            )),
            ((e,t)=>{
                aa(e, (e=>({
                    ...e,
                    position: E.some(e.position)
                }))(t))
            }
            )(e, o)
        }
        )(t, r, o),
        ((e,t)=>{
            ((e,t)=>{
                Fr(e, kc, t)
            }
            )(e, t.placement)
        }
        )(t, r),
        ((e,t)=>{
            const n = t.classes;
            ea(e, n.off),
            Zs(e, n.on)
        }
        )(t, r),
        ((e,t,n)=>{
            (0,
            n.maxHeightFunction)(e, t.maxHeight)
        }
        )(t, r, o),
        ((e,t,n)=>{
            (0,
            n.maxWidthFunction)(e, t.maxWidth)
        }
        )(t, r, o),
        {
            layout: r.layout,
            placement: r.placement
        }
    }
      , Vc = ["valignCentre", "alignLeft", "alignRight", "alignCentre", "top", "bottom", "left", "right", "inset"]
      , Wc = ()=>((e,t,n,o=1)=>{
        const r = e * o
          , s = t * o
          , a = e=>ze(n, e).getOr([])
          , i = (e,t,n)=>{
            const o = Z(Vc, n);
            return {
                offset: ji(e, t),
                classesOn: Q(n, a),
                classesOff: Q(o, a)
            }
        }
        ;
        return {
            southeast: ()=>i(-e, t, ["top", "alignLeft"]),
            southwest: ()=>i(e, t, ["top", "alignRight"]),
            south: ()=>i(-e / 2, t, ["top", "alignCentre"]),
            northeast: ()=>i(-e, -t, ["bottom", "alignLeft"]),
            northwest: ()=>i(e, -t, ["bottom", "alignRight"]),
            north: ()=>i(-e / 2, -t, ["bottom", "alignCentre"]),
            east: ()=>i(e, -t / 2, ["valignCentre", "left"]),
            west: ()=>i(-e, -t / 2, ["valignCentre", "right"]),
            insetNortheast: ()=>i(r, s, ["top", "alignLeft", "inset"]),
            insetNorthwest: ()=>i(-r, s, ["top", "alignRight", "inset"]),
            insetNorth: ()=>i(-r / 2, s, ["top", "alignCentre", "inset"]),
            insetSoutheast: ()=>i(r, -s, ["bottom", "alignLeft", "inset"]),
            insetSouthwest: ()=>i(-r, -s, ["bottom", "alignRight", "inset"]),
            insetSouth: ()=>i(-r / 2, -s, ["bottom", "alignCentre", "inset"]),
            insetEast: ()=>i(-r, -s / 2, ["valignCentre", "right", "inset"]),
            insetWest: ()=>i(r, -s / 2, ["valignCentre", "left", "inset"])
        }
    }
    )(0, 0, {})
      , Lc = (e,t,n,o,r,s,a,i=!1)=>({
        x: e,
        y: t,
        bubble: n,
        direction: o,
        placement: r,
        restriction: s,
        label: `${a}-${r}`,
        alwaysFit: i
    })
      , Uc = "layout"
      , jc = e=>e.x
      , zc = (e,t)=>e.x + e.width / 2 - t.width / 2
      , $c = (e,t)=>e.x + e.width - t.width
      , qc = (e,t)=>e.y - t.height
      , Gc = e=>e.y + e.height
      , Kc = (e,t)=>e.y + e.height / 2 - t.height / 2
      , Yc = (e,t,n)=>Lc(jc(e), Gc(e), n.southeast(), dc(), "southeast", Mc(e, {
        left: 1,
        top: 3
    }), Uc)
      , Qc = (e,t,n)=>Lc($c(e, t), Gc(e), n.southwest(), mc(), "southwest", Mc(e, {
        right: 0,
        top: 3
    }), Uc)
      , Jc = (e,t,n)=>Lc(jc(e), qc(e, t), n.northeast(), gc(), "northeast", Mc(e, {
        left: 1,
        bottom: 2
    }), Uc)
      , Xc = (e,t,n)=>Lc($c(e, t), qc(e, t), n.northwest(), pc(), "northwest", Mc(e, {
        right: 0,
        bottom: 2
    }), Uc)
      , Zc = (e,t,n)=>Lc(zc(e, t), qc(e, t), n.north(), vc(), "north", Mc(e, {
        bottom: 2
    }), Uc)
      , el = (e,t,n)=>Lc(zc(e, t), Gc(e), n.south(), hc(), "south", Mc(e, {
        top: 3
    }), Uc)
      , tl = (e,t,n)=>Lc((e=>e.x + e.width)(e), Kc(e, t), n.east(), fc(), "east", Mc(e, {
        left: 0
    }), Uc)
      , nl = (e,t,n)=>Lc(((e,t)=>e.x - t.width)(e, t), Kc(e, t), n.west(), bc(), "west", Mc(e, {
        right: 1
    }), Uc)
      , ol = ()=>[Yc, Qc, Jc, Xc, el, Zc, tl, nl]
      , rl = ()=>[Qc, Yc, Xc, Jc, el, Zc, tl, nl]
      , sl = ()=>[Jc, Xc, Yc, Qc, Zc, el]
      , al = ()=>[Xc, Jc, Qc, Yc, Zc, el]
      , il = ()=>[Yc, Qc, Jc, Xc, el, Zc]
      , cl = ()=>[Qc, Yc, Xc, Jc, el, Zc]
      , ll = f
      , ul = (e,t)=>n=>"rtl" === dl(n) ? t : e
      , dl = e=>"rtl" === ia(e, "direction") ? "rtl" : "ltr"
      , ml = (e,t,n)=>Xr(e, t, n).isSome();
    var gl;
    !function(e) {
        e.TopToBottom = "toptobottom",
        e.BottomToTop = "bottomtotop"
    }(gl || (gl = {}));
    const pl = e=>ml(e, (e=>ue(e) && Dr(e, "data-alloy-vertical-dir") === gl.BottomToTop))
      , hl = ()=>_n("layouts", [pn("onLtr"), pn("onRtl"), bn("onBottomLtr"), bn("onBottomRtl")])
      , vl = (e,t,n,o,r,s,a)=>{
        const i = a.map(pl).getOr(!1)
          , c = t.layouts.map((t=>t.onLtr(e)))
          , l = t.layouts.map((t=>t.onRtl(e)))
          , u = i ? t.layouts.bind((t=>t.onBottomLtr.map((t=>t(e))))).or(c).getOr(r) : c.getOr(n)
          , d = i ? t.layouts.bind((t=>t.onBottomRtl.map((t=>t(e))))).or(l).getOr(s) : l.getOr(o);
        return ul(u, d)(e)
    }
    ;
    var fl = [pn("hotspot"), bn("bubble"), wn("overrides", {}), hl(), Ua("placement", ((e,t,n)=>{
        const o = t.hotspot
          , r = wc(n, o.element)
          , s = vl(e.element, t, il(), cl(), sl(), al(), E.some(t.hotspot.element));
        return E.some(ll({
            anchorBox: r,
            bubble: t.bubble.getOr(Wc()),
            overrides: t.overrides,
            layouts: s,
            placer: E.none()
        }))
    }
    ))]
      , bl = [pn("x"), pn("y"), wn("height", 0), wn("width", 0), wn("bubble", Wc()), wn("overrides", {}), hl(), Ua("placement", ((e,t,n)=>{
        const o = Sc(n, t.x, t.y)
          , r = sc(o.left, o.top, t.width, t.height)
          , s = vl(e.element, t, ol(), rl(), ol(), rl(), E.none());
        return E.some(ll({
            anchorBox: r,
            bubble: t.bubble,
            overrides: t.overrides,
            layouts: s,
            placer: E.none()
        }))
    }
    ))];
    const yl = En([{
        screen: ["point"]
    }, {
        absolute: ["point", "scrollLeft", "scrollTop"]
    }])
      , _l = e=>e.fold(f, ((e,t,n)=>e.translate(-t, -n)))
      , xl = e=>e.fold(f, f)
      , wl = e=>q(e, ((e,t)=>e.translate(t.left, t.top)), ji(0, 0))
      , Ol = e=>{
        const t = U(e, xl);
        return wl(t)
    }
      , Sl = yl.screen
      , Cl = yl.absolute
      , El = (e,t,n)=>{
        const o = he(e.element)
          , r = ec(o)
          , s = ((e,t,n)=>{
            const o = fe(n.root).dom;
            return E.from(o.frameElement).map(R).filter((t=>{
                const n = he(t)
                  , o = he(e.element);
                return ie(n, o)
            }
            )).map($i)
        }
        )(e, 0, n).getOr(r);
        return Cl(s, r.left, r.top)
    }
      , kl = (e,t,n,o)=>{
        const r = Sl(ji(e, t));
        return E.some(((e,t,n)=>({
            point: e,
            width: t,
            height: n
        }))(r, n, o))
    }
      , Tl = (e,t,n,o,r)=>e.map((e=>{
        const s = [t, e.point]
          , a = (i = ()=>Ol(s),
        c = ()=>Ol(s),
        l = ()=>(e=>{
            const t = U(e, _l);
            return wl(t)
        }
        )(s),
        o.fold(i, c, l));
        var i, c, l;
        const u = {
            x: a.left,
            y: a.top,
            width: e.width,
            height: e.height
        };
        const d = n.showAbove ? sl() : il()
          , m = n.showAbove ? al() : cl()
          , g = vl(r, n, d, m, d, m, E.none());
        return ll({
            anchorBox: u,
            bubble: n.bubble.getOr(Wc()),
            overrides: n.overrides,
            layouts: g,
            placer: E.none()
        })
    }
    ));
    var Al = [pn("node"), pn("root"), bn("bubble"), hl(), wn("overrides", {}), wn("showAbove", !1), Ua("placement", ((e,t,n)=>{
        const o = El(e, 0, t);
        return t.node.filter(ct).bind((r=>{
            const s = r.dom.getBoundingClientRect()
              , a = kl(s.left, s.top, s.width, s.height)
              , i = t.node.getOr(e.element);
            return Tl(a, o, t, n, i)
        }
        ))
    }
    ))];
    const Ml = (e,t,n,o)=>({
        start: e,
        soffset: t,
        finish: n,
        foffset: o
    })
      , Rl = En([{
        before: ["element"]
    }, {
        on: ["element", "offset"]
    }, {
        after: ["element"]
    }])
      , Nl = (Rl.before,
    Rl.on,
    Rl.after,
    e=>e.fold(f, f, f))
      , Fl = En([{
        domRange: ["rng"]
    }, {
        relative: ["startSitu", "finishSitu"]
    }, {
        exact: ["start", "soffset", "finish", "foffset"]
    }])
      , Bl = {
        domRange: Fl.domRange,
        relative: Fl.relative,
        exact: Fl.exact,
        exactFromRange: e=>Fl.exact(e.start, e.soffset, e.finish, e.foffset),
        getWin: e=>{
            const t = (e=>e.match({
                domRange: e=>R(e.startContainer),
                relative: (e,t)=>Nl(e),
                exact: (e,t,n,o)=>e
            }))(e);
            return fe(t)
        }
        ,
        range: Ml
    }
      , Dl = (e,t,n)=>{
        const o = e.document.createRange();
        var r;
        return r = o,
        t.fold((e=>{
            r.setStartBefore(e.dom)
        }
        ), ((e,t)=>{
            r.setStart(e.dom, t)
        }
        ), (e=>{
            r.setStartAfter(e.dom)
        }
        )),
        ((e,t)=>{
            t.fold((t=>{
                e.setEndBefore(t.dom)
            }
            ), ((t,n)=>{
                e.setEnd(t.dom, n)
            }
            ), (t=>{
                e.setEndAfter(t.dom)
            }
            ))
        }
        )(o, n),
        o
    }
      , Hl = (e,t,n,o,r)=>{
        const s = e.document.createRange();
        return s.setStart(t.dom, n),
        s.setEnd(o.dom, r),
        s
    }
      , Pl = e=>({
        left: e.left,
        top: e.top,
        right: e.right,
        bottom: e.bottom,
        width: e.width,
        height: e.height
    })
      , Il = En([{
        ltr: ["start", "soffset", "finish", "foffset"]
    }, {
        rtl: ["start", "soffset", "finish", "foffset"]
    }])
      , Vl = (e,t,n)=>t(R(n.startContainer), n.startOffset, R(n.endContainer), n.endOffset)
      , Wl = (e,t)=>((e,t)=>{
        const n = ((e,t)=>t.match({
            domRange: e=>({
                ltr: v(e),
                rtl: E.none
            }),
            relative: (t,n)=>({
                ltr: Ht((()=>Dl(e, t, n))),
                rtl: Ht((()=>E.some(Dl(e, n, t))))
            }),
            exact: (t,n,o,r)=>({
                ltr: Ht((()=>Hl(e, t, n, o, r))),
                rtl: Ht((()=>E.some(Hl(e, o, r, t, n))))
            })
        }))(e, t);
        return ((e,t)=>{
            const n = t.ltr();
            return n.collapsed ? t.rtl().filter((e=>!1 === e.collapsed)).map((e=>Il.rtl(R(e.endContainer), e.endOffset, R(e.startContainer), e.startOffset))).getOrThunk((()=>Vl(0, Il.ltr, n))) : Vl(0, Il.ltr, n)
        }
        )(0, n)
    }
    )(e, t).match({
        ltr: (t,n,o,r)=>{
            const s = e.document.createRange();
            return s.setStart(t.dom, n),
            s.setEnd(o.dom, r),
            s
        }
        ,
        rtl: (t,n,o,r)=>{
            const s = e.document.createRange();
            return s.setStart(o.dom, r),
            s.setEnd(t.dom, n),
            s
        }
    });
    Il.ltr,
    Il.rtl;
    const Ll = e=>{
        if (e.rangeCount > 0) {
            const t = e.getRangeAt(0)
              , n = e.getRangeAt(e.rangeCount - 1);
            return E.some(Ml(R(t.startContainer), t.startOffset, R(n.endContainer), n.endOffset))
        }
        return E.none()
    }
      , Ul = e=>{
        if (null === e.anchorNode || null === e.focusNode)
            return Ll(e);
        {
            const t = R(e.anchorNode)
              , n = R(e.focusNode);
            return ((e,t,n,o)=>{
                const r = ((e,t,n,o)=>{
                    const r = he(e).dom.createRange();
                    return r.setStart(e.dom, t),
                    r.setEnd(n.dom, o),
                    r
                }
                )(e, t, n, o)
                  , s = ie(e, n) && t === o;
                return r.collapsed && !s
            }
            )(t, e.anchorOffset, n, e.focusOffset) ? E.some(Ml(t, e.anchorOffset, n, e.focusOffset)) : Ll(e)
        }
    }
      , jl = ((e,t)=>{
        const n = t=>e(t) ? E.from(t.dom.nodeValue) : E.none();
        return {
            get: t=>{
                if (!e(t))
                    throw new Error("Can only get text value of a text node");
                return n(t).getOr("")
            }
            ,
            getOption: n,
            set: (t,n)=>{
                if (!e(t))
                    throw new Error("Can only set raw text value of a text node");
                t.dom.nodeValue = n
            }
        }
    }
    )(de)
      , zl = (e,t)=>({
        element: e,
        offset: t
    })
      , $l = (e,t)=>de(e) ? zl(e, t) : ((e,t)=>{
        const n = ye(e);
        if (0 === n.length)
            return zl(e, t);
        if (t < n.length)
            return zl(n[t], 0);
        {
            const e = n[n.length - 1]
              , t = de(e) ? (e=>jl.get(e))(e).length : ye(e).length;
            return zl(e, t)
        }
    }
    )(e, t)
      , ql = (e,t)=>t.getSelection.getOrThunk((()=>()=>(e=>(e=>E.from(e.getSelection()))(e).filter((e=>e.rangeCount > 0)).bind(Ul))(e)))().map((e=>{
        const t = $l(e.start, e.soffset)
          , n = $l(e.finish, e.foffset);
        return Bl.range(t.element, t.offset, n.element, n.offset)
    }
    ));
    var Gl = [bn("getSelection"), pn("root"), bn("bubble"), hl(), wn("overrides", {}), wn("showAbove", !1), Ua("placement", ((e,t,n)=>{
        const o = fe(t.root).dom
          , r = El(e, 0, t)
          , s = ql(o, t).bind((e=>{
            const t = ((e,t)=>(e=>{
                const t = e.getBoundingClientRect();
                return t.width > 0 || t.height > 0 ? E.some(t).map(Pl) : E.none()
            }
            )(Wl(e, t)))(o, Bl.exactFromRange(e)).orThunk((()=>{
                const t = M("\ufeff");
                Re(e.start, t);
                const n = ((e,t)=>(e=>{
                    const t = e.getClientRects()
                      , n = t.length > 0 ? t[0] : e.getBoundingClientRect();
                    return n.width > 0 || n.height > 0 ? E.some(n).map(Pl) : E.none()
                }
                )(Wl(e, t)))(o, Bl.exact(t, 0, t, 1));
                return Ar(t),
                n
            }
            ));
            return t.bind((e=>kl(e.left, e.top, e.width, e.height)))
        }
        ))
          , a = ql(o, t).bind((e=>ue(e.start) ? E.some(e.start) : (e=>E.from(e.dom.parentElement).map(R))(e.start)))
          , i = a.getOr(e.element);
        return Tl(s, r, t, n, i)
    }
    ))];
    const Kl = "link-layout"
      , Yl = e=>e.x + e.width
      , Ql = (e,t)=>e.x - t.width
      , Jl = (e,t)=>e.y - t.height + e.height
      , Xl = e=>e.y
      , Zl = (e,t,n)=>Lc(Yl(e), Xl(e), n.southeast(), dc(), "southeast", Mc(e, {
        left: 0,
        top: 2
    }), Kl)
      , eu = (e,t,n)=>Lc(Ql(e, t), Xl(e), n.southwest(), mc(), "southwest", Mc(e, {
        right: 1,
        top: 2
    }), Kl)
      , tu = (e,t,n)=>Lc(Yl(e), Jl(e, t), n.northeast(), gc(), "northeast", Mc(e, {
        left: 0,
        bottom: 3
    }), Kl)
      , nu = (e,t,n)=>Lc(Ql(e, t), Jl(e, t), n.northwest(), pc(), "northwest", Mc(e, {
        right: 1,
        bottom: 3
    }), Kl)
      , ou = ()=>[Zl, eu, tu, nu]
      , ru = ()=>[eu, Zl, nu, tu];
    var su = [pn("item"), hl(), wn("overrides", {}), Ua("placement", ((e,t,n)=>{
        const o = wc(n, t.item.element)
          , r = vl(e.element, t, ou(), ru(), ou(), ru(), E.none());
        return E.some(ll({
            anchorBox: o,
            bubble: Wc(),
            overrides: t.overrides,
            layouts: r,
            placer: E.none()
        }))
    }
    ))]
      , au = dn("type", {
        selection: Gl,
        node: Al,
        hotspot: fl,
        submenu: su,
        makeshift: bl
    });
    const iu = [((e,t)=>mn(e, e, {
        tag: "required",
        process: {}
    }, Qt(t)))("classes", en), On("mode", "all", (gu = ["all", "layout", "placement"],
    rn((e=>W(gu, e) ? ot.value(e) : ot.error(`Unsupported value: "${e}", choose one of "${gu.join(", ")}".`)))))]
      , cu = [wn("useFixed", w), bn("getBounds")]
      , lu = [hn("anchor", au), _n("transition", iu)]
      , uu = (e,t,n,o,r,s,a)=>((e,t,n,o,r,s,a,i)=>{
        const c = Pc(a, "maxHeightFunction", Hc())
          , l = Pc(a, "maxWidthFunction", p)
          , u = e.anchorBox
          , d = e.origin
          , m = {
            bounds: Oc(d, s),
            origin: d,
            preference: o,
            maxHeightFunction: c,
            maxWidthFunction: l,
            lastPlacement: r,
            transition: i
        };
        return Ic(u, t, n, m)
    }
    )(((e,t)=>((e,t)=>({
        anchorBox: e,
        origin: t
    }))(e, t))(n.anchorBox, t), r.element, n.bubble, n.layouts, s, o, n.overrides, a)
      , du = (e,t,n,o,r,s)=>{
        const a = s.map(ac);
        return mu(e, t, n, o, r, a)
    }
      , mu = (e,t,n,o,r,s)=>{
        const a = ln("placement.info", Yt(lu), r)
          , i = a.anchor
          , c = o.element
          , l = n.get(o.uid);
        cc((()=>{
            ra(c, "position", "fixed");
            const r = la(c, "visibility");
            ra(c, "visibility", "hidden");
            const u = t.useFixed() ? (()=>{
                const e = document.documentElement;
                return Ec(0, 0, e.clientWidth, e.clientHeight)
            }
            )() : (e=>{
                const t = $i(e.element)
                  , n = e.element.dom.getBoundingClientRect();
                return Cc(t.left, t.top, n.width, n.height)
            }
            )(e)
              , d = i.placement
              , m = s.map(v).or(t.getBounds);
            d(e, i, u).each((t=>{
                const r = t.placer.getOr(uu)(e, u, t, m, o, l, a.transition);
                n.set(o.uid, r)
            }
            )),
            r.fold((()=>{
                ua(c, "visibility")
            }
            ), (e=>{
                ra(c, "visibility", e)
            }
            )),
            la(c, "left").isNone() && la(c, "top").isNone() && la(c, "right").isNone() && la(c, "bottom").isNone() && cr(la(c, "position"), "fixed") && ua(c, "position")
        }
        ), c)
    }
    ;
    var gu, pu = Object.freeze({
        __proto__: null,
        position: (e,t,n,o,r)=>{
            du(e, t, n, o, r, E.none())
        }
        ,
        positionWithin: du,
        positionWithinBounds: mu,
        getMode: (e,t,n)=>t.useFixed() ? "fixed" : "absolute",
        reset: (e,t,n,o)=>{
            const r = o.element;
            j(["position", "left", "right", "top", "bottom"], (e=>ua(r, e))),
            (e=>{
                Ir(e, kc)
            }
            )(r),
            n.clear(o.uid)
        }
    });
    const hu = yr({
        fields: cu,
        name: "positioning",
        active: Li,
        apis: pu,
        state: Object.freeze({
            __proto__: null,
            init: ()=>{
                let e = {};
                return Cn({
                    readState: ()=>e,
                    clear: t=>{
                        d(t) ? delete e[t] : e = {}
                    }
                    ,
                    set: (t,n)=>{
                        e[t] = n
                    }
                    ,
                    get: t=>ze(e, t)
                })
            }
        })
    })
      , vu = (e,t)=>{
        cc((()=>{
            ((e,t,n)=>{
                const o = e.components();
                (e=>{
                    j(e.components(), (e=>Ar(e.element))),
                    Tr(e.element),
                    e.syncComponents()
                }
                )(e);
                const r = n(t)
                  , s = Z(o, r);
                j(s, (t=>{
                    Ai(t),
                    e.getSystem().removeFromWorld(t)
                }
                )),
                j(r, (t=>{
                    Ti(t) ? Fi(e, t) : (e.getSystem().addToWorld(t),
                    Fi(e, t),
                    ct(e.element) && Mi(t))
                }
                )),
                e.syncComponents()
            }
            )(e, t, (()=>U(t, e.getSystem().build)))
        }
        ), e.element)
    }
      , fu = (e,t)=>{
        cc((()=>{
            ((n,o,r)=>{
                const s = n.components()
                  , a = Q(o, (e=>Hs(e).toArray()));
                j(s, (e=>{
                    W(a, e) || Ni(e)
                }
                ));
                const i = ((e,t,n)=>ha(e, t, ((t,o)=>va(e, o, t, n))))(e.element, t, e.getSystem().buildOrPatch)
                  , c = Z(s, i);
                j(c, (e=>{
                    Ti(e) && Ni(e)
                }
                )),
                j(i, (e=>{
                    Ti(e) || Ri(n, e)
                }
                )),
                n.syncComponents()
            }
            )(e, t)
        }
        ), e.element)
    }
      , bu = (e,t,n,o)=>{
        Ni(t);
        const r = va(e.element, n, o, e.getSystem().buildOrPatch);
        Ri(e, r),
        e.syncComponents()
    }
      , yu = (e,t,n)=>{
        const o = e.getSystem().build(n);
        Di(e, o, t)
    }
      , _u = (e,t,n,o)=>{
        Pi(t),
        yu(e, ((e,t)=>((e,t,n)=>{
            _e(e, n).fold((()=>{
                Fe(e, t)
            }
            ), (e=>{
                Re(e, t)
            }
            ))
        }
        )(e, t, n)), o)
    }
      , xu = (e,t)=>e.components()
      , wu = (e,t,n,o,r)=>{
        const s = xu(e);
        return E.from(s[o]).map((n=>(r.fold((()=>Pi(n)), (r=>{
            (t.reuseDom ? bu : _u)(e, n, o, r)
        }
        )),
        n)))
    }
    ;
    var Ou = Object.freeze({
        __proto__: null,
        append: (e,t,n,o)=>{
            yu(e, Fe, o)
        }
        ,
        prepend: (e,t,n,o)=>{
            yu(e, Ne, o)
        }
        ,
        remove: (e,t,n,o)=>{
            const r = xu(e)
              , s = G(r, (e=>ie(o.element, e.element)));
            s.each(Pi)
        }
        ,
        replaceAt: wu,
        replaceBy: (e,t,n,o,r)=>{
            const s = xu(e);
            return K(s, o).bind((n=>wu(e, t, 0, n, r)))
        }
        ,
        set: (e,t,n,o)=>(t.reuseDom ? fu : vu)(e, o),
        contents: xu
    });
    const Su = yr({
        fields: [On("reuseDom", !0, tn)],
        name: "replacing",
        apis: Ou
    })
      , Cu = e=>!(e=>e.offsetWidth <= 0 && e.offsetHeight <= 0)(e.dom);
    var Eu, ku = {
        exports: {}
    };
    (Eu = ku).exports && (Eu.exports = function() {
        var e = 3
          , t = 4
          , n = 12
          , o = 13
          , r = 16
          , s = 17;
        function a(e, t) {
            void 0 === t && (t = 0);
            var n = e.charCodeAt(t);
            if (55296 <= n && n <= 56319 && t < e.length - 1) {
                var o = n;
                return 56320 <= (r = e.charCodeAt(t + 1)) && r <= 57343 ? 1024 * (o - 55296) + (r - 56320) + 65536 : o
            }
            if (56320 <= n && n <= 57343 && t >= 1) {
                var r = n;
                return 55296 <= (o = e.charCodeAt(t - 1)) && o <= 56319 ? 1024 * (o - 55296) + (r - 56320) + 65536 : r
            }
            return n
        }
        function i(a, i, c) {
            var l = [a].concat(i).concat([c])
              , u = l[l.length - 2]
              , d = c
              , m = l.lastIndexOf(14);
            if (m > 1 && l.slice(1, m).every((function(t) {
                return t == e
            }
            )) && -1 == [e, o, s].indexOf(a))
                return 2;
            var g = l.lastIndexOf(t);
            if (g > 0 && l.slice(1, g).every((function(e) {
                return e == t
            }
            )) && -1 == [n, t].indexOf(u))
                return l.filter((function(e) {
                    return e == t
                }
                )).length % 2 == 1 ? 3 : 4;
            if (0 == u && 1 == d)
                return 0;
            if (2 == u || 0 == u || 1 == u)
                return 14 == d && i.every((function(t) {
                    return t == e
                }
                )) ? 2 : 1;
            if (2 == d || 0 == d || 1 == d)
                return 1;
            if (6 == u && (6 == d || 7 == d || 9 == d || 10 == d))
                return 0;
            if (!(9 != u && 7 != u || 7 != d && 8 != d))
                return 0;
            if ((10 == u || 8 == u) && 8 == d)
                return 0;
            if (d == e || 15 == d)
                return 0;
            if (5 == d)
                return 0;
            if (u == n)
                return 0;
            var p = -1 != l.indexOf(e) ? l.lastIndexOf(e) - 1 : l.length - 2;
            return -1 != [o, s].indexOf(l[p]) && l.slice(p + 1, -1).every((function(t) {
                return t == e
            }
            )) && 14 == d || 15 == u && -1 != [r, s].indexOf(d) ? 0 : -1 != i.indexOf(t) ? 2 : u == t && d == t ? 0 : 1
        }
        function c(a) {
            return 1536 <= a && a <= 1541 || 1757 == a || 1807 == a || 2274 == a || 3406 == a || 69821 == a || 70082 <= a && a <= 70083 || 72250 == a || 72326 <= a && a <= 72329 || 73030 == a ? n : 13 == a ? 0 : 10 == a ? 1 : 0 <= a && a <= 9 || 11 <= a && a <= 12 || 14 <= a && a <= 31 || 127 <= a && a <= 159 || 173 == a || 1564 == a || 6158 == a || 8203 == a || 8206 <= a && a <= 8207 || 8232 == a || 8233 == a || 8234 <= a && a <= 8238 || 8288 <= a && a <= 8292 || 8293 == a || 8294 <= a && a <= 8303 || 55296 <= a && a <= 57343 || 65279 == a || 65520 <= a && a <= 65528 || 65529 <= a && a <= 65531 || 113824 <= a && a <= 113827 || 119155 <= a && a <= 119162 || 917504 == a || 917505 == a || 917506 <= a && a <= 917535 || 917632 <= a && a <= 917759 || 918e3 <= a && a <= 921599 ? 2 : 768 <= a && a <= 879 || 1155 <= a && a <= 1159 || 1160 <= a && a <= 1161 || 1425 <= a && a <= 1469 || 1471 == a || 1473 <= a && a <= 1474 || 1476 <= a && a <= 1477 || 1479 == a || 1552 <= a && a <= 1562 || 1611 <= a && a <= 1631 || 1648 == a || 1750 <= a && a <= 1756 || 1759 <= a && a <= 1764 || 1767 <= a && a <= 1768 || 1770 <= a && a <= 1773 || 1809 == a || 1840 <= a && a <= 1866 || 1958 <= a && a <= 1968 || 2027 <= a && a <= 2035 || 2070 <= a && a <= 2073 || 2075 <= a && a <= 2083 || 2085 <= a && a <= 2087 || 2089 <= a && a <= 2093 || 2137 <= a && a <= 2139 || 2260 <= a && a <= 2273 || 2275 <= a && a <= 2306 || 2362 == a || 2364 == a || 2369 <= a && a <= 2376 || 2381 == a || 2385 <= a && a <= 2391 || 2402 <= a && a <= 2403 || 2433 == a || 2492 == a || 2494 == a || 2497 <= a && a <= 2500 || 2509 == a || 2519 == a || 2530 <= a && a <= 2531 || 2561 <= a && a <= 2562 || 2620 == a || 2625 <= a && a <= 2626 || 2631 <= a && a <= 2632 || 2635 <= a && a <= 2637 || 2641 == a || 2672 <= a && a <= 2673 || 2677 == a || 2689 <= a && a <= 2690 || 2748 == a || 2753 <= a && a <= 2757 || 2759 <= a && a <= 2760 || 2765 == a || 2786 <= a && a <= 2787 || 2810 <= a && a <= 2815 || 2817 == a || 2876 == a || 2878 == a || 2879 == a || 2881 <= a && a <= 2884 || 2893 == a || 2902 == a || 2903 == a || 2914 <= a && a <= 2915 || 2946 == a || 3006 == a || 3008 == a || 3021 == a || 3031 == a || 3072 == a || 3134 <= a && a <= 3136 || 3142 <= a && a <= 3144 || 3146 <= a && a <= 3149 || 3157 <= a && a <= 3158 || 3170 <= a && a <= 3171 || 3201 == a || 3260 == a || 3263 == a || 3266 == a || 3270 == a || 3276 <= a && a <= 3277 || 3285 <= a && a <= 3286 || 3298 <= a && a <= 3299 || 3328 <= a && a <= 3329 || 3387 <= a && a <= 3388 || 3390 == a || 3393 <= a && a <= 3396 || 3405 == a || 3415 == a || 3426 <= a && a <= 3427 || 3530 == a || 3535 == a || 3538 <= a && a <= 3540 || 3542 == a || 3551 == a || 3633 == a || 3636 <= a && a <= 3642 || 3655 <= a && a <= 3662 || 3761 == a || 3764 <= a && a <= 3769 || 3771 <= a && a <= 3772 || 3784 <= a && a <= 3789 || 3864 <= a && a <= 3865 || 3893 == a || 3895 == a || 3897 == a || 3953 <= a && a <= 3966 || 3968 <= a && a <= 3972 || 3974 <= a && a <= 3975 || 3981 <= a && a <= 3991 || 3993 <= a && a <= 4028 || 4038 == a || 4141 <= a && a <= 4144 || 4146 <= a && a <= 4151 || 4153 <= a && a <= 4154 || 4157 <= a && a <= 4158 || 4184 <= a && a <= 4185 || 4190 <= a && a <= 4192 || 4209 <= a && a <= 4212 || 4226 == a || 4229 <= a && a <= 4230 || 4237 == a || 4253 == a || 4957 <= a && a <= 4959 || 5906 <= a && a <= 5908 || 5938 <= a && a <= 5940 || 5970 <= a && a <= 5971 || 6002 <= a && a <= 6003 || 6068 <= a && a <= 6069 || 6071 <= a && a <= 6077 || 6086 == a || 6089 <= a && a <= 6099 || 6109 == a || 6155 <= a && a <= 6157 || 6277 <= a && a <= 6278 || 6313 == a || 6432 <= a && a <= 6434 || 6439 <= a && a <= 6440 || 6450 == a || 6457 <= a && a <= 6459 || 6679 <= a && a <= 6680 || 6683 == a || 6742 == a || 6744 <= a && a <= 6750 || 6752 == a || 6754 == a || 6757 <= a && a <= 6764 || 6771 <= a && a <= 6780 || 6783 == a || 6832 <= a && a <= 6845 || 6846 == a || 6912 <= a && a <= 6915 || 6964 == a || 6966 <= a && a <= 6970 || 6972 == a || 6978 == a || 7019 <= a && a <= 7027 || 7040 <= a && a <= 7041 || 7074 <= a && a <= 7077 || 7080 <= a && a <= 7081 || 7083 <= a && a <= 7085 || 7142 == a || 7144 <= a && a <= 7145 || 7149 == a || 7151 <= a && a <= 7153 || 7212 <= a && a <= 7219 || 7222 <= a && a <= 7223 || 7376 <= a && a <= 7378 || 7380 <= a && a <= 7392 || 7394 <= a && a <= 7400 || 7405 == a || 7412 == a || 7416 <= a && a <= 7417 || 7616 <= a && a <= 7673 || 7675 <= a && a <= 7679 || 8204 == a || 8400 <= a && a <= 8412 || 8413 <= a && a <= 8416 || 8417 == a || 8418 <= a && a <= 8420 || 8421 <= a && a <= 8432 || 11503 <= a && a <= 11505 || 11647 == a || 11744 <= a && a <= 11775 || 12330 <= a && a <= 12333 || 12334 <= a && a <= 12335 || 12441 <= a && a <= 12442 || 42607 == a || 42608 <= a && a <= 42610 || 42612 <= a && a <= 42621 || 42654 <= a && a <= 42655 || 42736 <= a && a <= 42737 || 43010 == a || 43014 == a || 43019 == a || 43045 <= a && a <= 43046 || 43204 <= a && a <= 43205 || 43232 <= a && a <= 43249 || 43302 <= a && a <= 43309 || 43335 <= a && a <= 43345 || 43392 <= a && a <= 43394 || 43443 == a || 43446 <= a && a <= 43449 || 43452 == a || 43493 == a || 43561 <= a && a <= 43566 || 43569 <= a && a <= 43570 || 43573 <= a && a <= 43574 || 43587 == a || 43596 == a || 43644 == a || 43696 == a || 43698 <= a && a <= 43700 || 43703 <= a && a <= 43704 || 43710 <= a && a <= 43711 || 43713 == a || 43756 <= a && a <= 43757 || 43766 == a || 44005 == a || 44008 == a || 44013 == a || 64286 == a || 65024 <= a && a <= 65039 || 65056 <= a && a <= 65071 || 65438 <= a && a <= 65439 || 66045 == a || 66272 == a || 66422 <= a && a <= 66426 || 68097 <= a && a <= 68099 || 68101 <= a && a <= 68102 || 68108 <= a && a <= 68111 || 68152 <= a && a <= 68154 || 68159 == a || 68325 <= a && a <= 68326 || 69633 == a || 69688 <= a && a <= 69702 || 69759 <= a && a <= 69761 || 69811 <= a && a <= 69814 || 69817 <= a && a <= 69818 || 69888 <= a && a <= 69890 || 69927 <= a && a <= 69931 || 69933 <= a && a <= 69940 || 70003 == a || 70016 <= a && a <= 70017 || 70070 <= a && a <= 70078 || 70090 <= a && a <= 70092 || 70191 <= a && a <= 70193 || 70196 == a || 70198 <= a && a <= 70199 || 70206 == a || 70367 == a || 70371 <= a && a <= 70378 || 70400 <= a && a <= 70401 || 70460 == a || 70462 == a || 70464 == a || 70487 == a || 70502 <= a && a <= 70508 || 70512 <= a && a <= 70516 || 70712 <= a && a <= 70719 || 70722 <= a && a <= 70724 || 70726 == a || 70832 == a || 70835 <= a && a <= 70840 || 70842 == a || 70845 == a || 70847 <= a && a <= 70848 || 70850 <= a && a <= 70851 || 71087 == a || 71090 <= a && a <= 71093 || 71100 <= a && a <= 71101 || 71103 <= a && a <= 71104 || 71132 <= a && a <= 71133 || 71219 <= a && a <= 71226 || 71229 == a || 71231 <= a && a <= 71232 || 71339 == a || 71341 == a || 71344 <= a && a <= 71349 || 71351 == a || 71453 <= a && a <= 71455 || 71458 <= a && a <= 71461 || 71463 <= a && a <= 71467 || 72193 <= a && a <= 72198 || 72201 <= a && a <= 72202 || 72243 <= a && a <= 72248 || 72251 <= a && a <= 72254 || 72263 == a || 72273 <= a && a <= 72278 || 72281 <= a && a <= 72283 || 72330 <= a && a <= 72342 || 72344 <= a && a <= 72345 || 72752 <= a && a <= 72758 || 72760 <= a && a <= 72765 || 72767 == a || 72850 <= a && a <= 72871 || 72874 <= a && a <= 72880 || 72882 <= a && a <= 72883 || 72885 <= a && a <= 72886 || 73009 <= a && a <= 73014 || 73018 == a || 73020 <= a && a <= 73021 || 73023 <= a && a <= 73029 || 73031 == a || 92912 <= a && a <= 92916 || 92976 <= a && a <= 92982 || 94095 <= a && a <= 94098 || 113821 <= a && a <= 113822 || 119141 == a || 119143 <= a && a <= 119145 || 119150 <= a && a <= 119154 || 119163 <= a && a <= 119170 || 119173 <= a && a <= 119179 || 119210 <= a && a <= 119213 || 119362 <= a && a <= 119364 || 121344 <= a && a <= 121398 || 121403 <= a && a <= 121452 || 121461 == a || 121476 == a || 121499 <= a && a <= 121503 || 121505 <= a && a <= 121519 || 122880 <= a && a <= 122886 || 122888 <= a && a <= 122904 || 122907 <= a && a <= 122913 || 122915 <= a && a <= 122916 || 122918 <= a && a <= 122922 || 125136 <= a && a <= 125142 || 125252 <= a && a <= 125258 || 917536 <= a && a <= 917631 || 917760 <= a && a <= 917999 ? e : 127462 <= a && a <= 127487 ? t : 2307 == a || 2363 == a || 2366 <= a && a <= 2368 || 2377 <= a && a <= 2380 || 2382 <= a && a <= 2383 || 2434 <= a && a <= 2435 || 2495 <= a && a <= 2496 || 2503 <= a && a <= 2504 || 2507 <= a && a <= 2508 || 2563 == a || 2622 <= a && a <= 2624 || 2691 == a || 2750 <= a && a <= 2752 || 2761 == a || 2763 <= a && a <= 2764 || 2818 <= a && a <= 2819 || 2880 == a || 2887 <= a && a <= 2888 || 2891 <= a && a <= 2892 || 3007 == a || 3009 <= a && a <= 3010 || 3014 <= a && a <= 3016 || 3018 <= a && a <= 3020 || 3073 <= a && a <= 3075 || 3137 <= a && a <= 3140 || 3202 <= a && a <= 3203 || 3262 == a || 3264 <= a && a <= 3265 || 3267 <= a && a <= 3268 || 3271 <= a && a <= 3272 || 3274 <= a && a <= 3275 || 3330 <= a && a <= 3331 || 3391 <= a && a <= 3392 || 3398 <= a && a <= 3400 || 3402 <= a && a <= 3404 || 3458 <= a && a <= 3459 || 3536 <= a && a <= 3537 || 3544 <= a && a <= 3550 || 3570 <= a && a <= 3571 || 3635 == a || 3763 == a || 3902 <= a && a <= 3903 || 3967 == a || 4145 == a || 4155 <= a && a <= 4156 || 4182 <= a && a <= 4183 || 4228 == a || 6070 == a || 6078 <= a && a <= 6085 || 6087 <= a && a <= 6088 || 6435 <= a && a <= 6438 || 6441 <= a && a <= 6443 || 6448 <= a && a <= 6449 || 6451 <= a && a <= 6456 || 6681 <= a && a <= 6682 || 6741 == a || 6743 == a || 6765 <= a && a <= 6770 || 6916 == a || 6965 == a || 6971 == a || 6973 <= a && a <= 6977 || 6979 <= a && a <= 6980 || 7042 == a || 7073 == a || 7078 <= a && a <= 7079 || 7082 == a || 7143 == a || 7146 <= a && a <= 7148 || 7150 == a || 7154 <= a && a <= 7155 || 7204 <= a && a <= 7211 || 7220 <= a && a <= 7221 || 7393 == a || 7410 <= a && a <= 7411 || 7415 == a || 43043 <= a && a <= 43044 || 43047 == a || 43136 <= a && a <= 43137 || 43188 <= a && a <= 43203 || 43346 <= a && a <= 43347 || 43395 == a || 43444 <= a && a <= 43445 || 43450 <= a && a <= 43451 || 43453 <= a && a <= 43456 || 43567 <= a && a <= 43568 || 43571 <= a && a <= 43572 || 43597 == a || 43755 == a || 43758 <= a && a <= 43759 || 43765 == a || 44003 <= a && a <= 44004 || 44006 <= a && a <= 44007 || 44009 <= a && a <= 44010 || 44012 == a || 69632 == a || 69634 == a || 69762 == a || 69808 <= a && a <= 69810 || 69815 <= a && a <= 69816 || 69932 == a || 70018 == a || 70067 <= a && a <= 70069 || 70079 <= a && a <= 70080 || 70188 <= a && a <= 70190 || 70194 <= a && a <= 70195 || 70197 == a || 70368 <= a && a <= 70370 || 70402 <= a && a <= 70403 || 70463 == a || 70465 <= a && a <= 70468 || 70471 <= a && a <= 70472 || 70475 <= a && a <= 70477 || 70498 <= a && a <= 70499 || 70709 <= a && a <= 70711 || 70720 <= a && a <= 70721 || 70725 == a || 70833 <= a && a <= 70834 || 70841 == a || 70843 <= a && a <= 70844 || 70846 == a || 70849 == a || 71088 <= a && a <= 71089 || 71096 <= a && a <= 71099 || 71102 == a || 71216 <= a && a <= 71218 || 71227 <= a && a <= 71228 || 71230 == a || 71340 == a || 71342 <= a && a <= 71343 || 71350 == a || 71456 <= a && a <= 71457 || 71462 == a || 72199 <= a && a <= 72200 || 72249 == a || 72279 <= a && a <= 72280 || 72343 == a || 72751 == a || 72766 == a || 72873 == a || 72881 == a || 72884 == a || 94033 <= a && a <= 94078 || 119142 == a || 119149 == a ? 5 : 4352 <= a && a <= 4447 || 43360 <= a && a <= 43388 ? 6 : 4448 <= a && a <= 4519 || 55216 <= a && a <= 55238 ? 7 : 4520 <= a && a <= 4607 || 55243 <= a && a <= 55291 ? 8 : 44032 == a || 44060 == a || 44088 == a || 44116 == a || 44144 == a || 44172 == a || 44200 == a || 44228 == a || 44256 == a || 44284 == a || 44312 == a || 44340 == a || 44368 == a || 44396 == a || 44424 == a || 44452 == a || 44480 == a || 44508 == a || 44536 == a || 44564 == a || 44592 == a || 44620 == a || 44648 == a || 44676 == a || 44704 == a || 44732 == a || 44760 == a || 44788 == a || 44816 == a || 44844 == a || 44872 == a || 44900 == a || 44928 == a || 44956 == a || 44984 == a || 45012 == a || 45040 == a || 45068 == a || 45096 == a || 45124 == a || 45152 == a || 45180 == a || 45208 == a || 45236 == a || 45264 == a || 45292 == a || 45320 == a || 45348 == a || 45376 == a || 45404 == a || 45432 == a || 45460 == a || 45488 == a || 45516 == a || 45544 == a || 45572 == a || 45600 == a || 45628 == a || 45656 == a || 45684 == a || 45712 == a || 45740 == a || 45768 == a || 45796 == a || 45824 == a || 45852 == a || 45880 == a || 45908 == a || 45936 == a || 45964 == a || 45992 == a || 46020 == a || 46048 == a || 46076 == a || 46104 == a || 46132 == a || 46160 == a || 46188 == a || 46216 == a || 46244 == a || 46272 == a || 46300 == a || 46328 == a || 46356 == a || 46384 == a || 46412 == a || 46440 == a || 46468 == a || 46496 == a || 46524 == a || 46552 == a || 46580 == a || 46608 == a || 46636 == a || 46664 == a || 46692 == a || 46720 == a || 46748 == a || 46776 == a || 46804 == a || 46832 == a || 46860 == a || 46888 == a || 46916 == a || 46944 == a || 46972 == a || 47e3 == a || 47028 == a || 47056 == a || 47084 == a || 47112 == a || 47140 == a || 47168 == a || 47196 == a || 47224 == a || 47252 == a || 47280 == a || 47308 == a || 47336 == a || 47364 == a || 47392 == a || 47420 == a || 47448 == a || 47476 == a || 47504 == a || 47532 == a || 47560 == a || 47588 == a || 47616 == a || 47644 == a || 47672 == a || 47700 == a || 47728 == a || 47756 == a || 47784 == a || 47812 == a || 47840 == a || 47868 == a || 47896 == a || 47924 == a || 47952 == a || 47980 == a || 48008 == a || 48036 == a || 48064 == a || 48092 == a || 48120 == a || 48148 == a || 48176 == a || 48204 == a || 48232 == a || 48260 == a || 48288 == a || 48316 == a || 48344 == a || 48372 == a || 48400 == a || 48428 == a || 48456 == a || 48484 == a || 48512 == a || 48540 == a || 48568 == a || 48596 == a || 48624 == a || 48652 == a || 48680 == a || 48708 == a || 48736 == a || 48764 == a || 48792 == a || 48820 == a || 48848 == a || 48876 == a || 48904 == a || 48932 == a || 48960 == a || 48988 == a || 49016 == a || 49044 == a || 49072 == a || 49100 == a || 49128 == a || 49156 == a || 49184 == a || 49212 == a || 49240 == a || 49268 == a || 49296 == a || 49324 == a || 49352 == a || 49380 == a || 49408 == a || 49436 == a || 49464 == a || 49492 == a || 49520 == a || 49548 == a || 49576 == a || 49604 == a || 49632 == a || 49660 == a || 49688 == a || 49716 == a || 49744 == a || 49772 == a || 49800 == a || 49828 == a || 49856 == a || 49884 == a || 49912 == a || 49940 == a || 49968 == a || 49996 == a || 50024 == a || 50052 == a || 50080 == a || 50108 == a || 50136 == a || 50164 == a || 50192 == a || 50220 == a || 50248 == a || 50276 == a || 50304 == a || 50332 == a || 50360 == a || 50388 == a || 50416 == a || 50444 == a || 50472 == a || 50500 == a || 50528 == a || 50556 == a || 50584 == a || 50612 == a || 50640 == a || 50668 == a || 50696 == a || 50724 == a || 50752 == a || 50780 == a || 50808 == a || 50836 == a || 50864 == a || 50892 == a || 50920 == a || 50948 == a || 50976 == a || 51004 == a || 51032 == a || 51060 == a || 51088 == a || 51116 == a || 51144 == a || 51172 == a || 51200 == a || 51228 == a || 51256 == a || 51284 == a || 51312 == a || 51340 == a || 51368 == a || 51396 == a || 51424 == a || 51452 == a || 51480 == a || 51508 == a || 51536 == a || 51564 == a || 51592 == a || 51620 == a || 51648 == a || 51676 == a || 51704 == a || 51732 == a || 51760 == a || 51788 == a || 51816 == a || 51844 == a || 51872 == a || 51900 == a || 51928 == a || 51956 == a || 51984 == a || 52012 == a || 52040 == a || 52068 == a || 52096 == a || 52124 == a || 52152 == a || 52180 == a || 52208 == a || 52236 == a || 52264 == a || 52292 == a || 52320 == a || 52348 == a || 52376 == a || 52404 == a || 52432 == a || 52460 == a || 52488 == a || 52516 == a || 52544 == a || 52572 == a || 52600 == a || 52628 == a || 52656 == a || 52684 == a || 52712 == a || 52740 == a || 52768 == a || 52796 == a || 52824 == a || 52852 == a || 52880 == a || 52908 == a || 52936 == a || 52964 == a || 52992 == a || 53020 == a || 53048 == a || 53076 == a || 53104 == a || 53132 == a || 53160 == a || 53188 == a || 53216 == a || 53244 == a || 53272 == a || 53300 == a || 53328 == a || 53356 == a || 53384 == a || 53412 == a || 53440 == a || 53468 == a || 53496 == a || 53524 == a || 53552 == a || 53580 == a || 53608 == a || 53636 == a || 53664 == a || 53692 == a || 53720 == a || 53748 == a || 53776 == a || 53804 == a || 53832 == a || 53860 == a || 53888 == a || 53916 == a || 53944 == a || 53972 == a || 54e3 == a || 54028 == a || 54056 == a || 54084 == a || 54112 == a || 54140 == a || 54168 == a || 54196 == a || 54224 == a || 54252 == a || 54280 == a || 54308 == a || 54336 == a || 54364 == a || 54392 == a || 54420 == a || 54448 == a || 54476 == a || 54504 == a || 54532 == a || 54560 == a || 54588 == a || 54616 == a || 54644 == a || 54672 == a || 54700 == a || 54728 == a || 54756 == a || 54784 == a || 54812 == a || 54840 == a || 54868 == a || 54896 == a || 54924 == a || 54952 == a || 54980 == a || 55008 == a || 55036 == a || 55064 == a || 55092 == a || 55120 == a || 55148 == a || 55176 == a ? 9 : 44033 <= a && a <= 44059 || 44061 <= a && a <= 44087 || 44089 <= a && a <= 44115 || 44117 <= a && a <= 44143 || 44145 <= a && a <= 44171 || 44173 <= a && a <= 44199 || 44201 <= a && a <= 44227 || 44229 <= a && a <= 44255 || 44257 <= a && a <= 44283 || 44285 <= a && a <= 44311 || 44313 <= a && a <= 44339 || 44341 <= a && a <= 44367 || 44369 <= a && a <= 44395 || 44397 <= a && a <= 44423 || 44425 <= a && a <= 44451 || 44453 <= a && a <= 44479 || 44481 <= a && a <= 44507 || 44509 <= a && a <= 44535 || 44537 <= a && a <= 44563 || 44565 <= a && a <= 44591 || 44593 <= a && a <= 44619 || 44621 <= a && a <= 44647 || 44649 <= a && a <= 44675 || 44677 <= a && a <= 44703 || 44705 <= a && a <= 44731 || 44733 <= a && a <= 44759 || 44761 <= a && a <= 44787 || 44789 <= a && a <= 44815 || 44817 <= a && a <= 44843 || 44845 <= a && a <= 44871 || 44873 <= a && a <= 44899 || 44901 <= a && a <= 44927 || 44929 <= a && a <= 44955 || 44957 <= a && a <= 44983 || 44985 <= a && a <= 45011 || 45013 <= a && a <= 45039 || 45041 <= a && a <= 45067 || 45069 <= a && a <= 45095 || 45097 <= a && a <= 45123 || 45125 <= a && a <= 45151 || 45153 <= a && a <= 45179 || 45181 <= a && a <= 45207 || 45209 <= a && a <= 45235 || 45237 <= a && a <= 45263 || 45265 <= a && a <= 45291 || 45293 <= a && a <= 45319 || 45321 <= a && a <= 45347 || 45349 <= a && a <= 45375 || 45377 <= a && a <= 45403 || 45405 <= a && a <= 45431 || 45433 <= a && a <= 45459 || 45461 <= a && a <= 45487 || 45489 <= a && a <= 45515 || 45517 <= a && a <= 45543 || 45545 <= a && a <= 45571 || 45573 <= a && a <= 45599 || 45601 <= a && a <= 45627 || 45629 <= a && a <= 45655 || 45657 <= a && a <= 45683 || 45685 <= a && a <= 45711 || 45713 <= a && a <= 45739 || 45741 <= a && a <= 45767 || 45769 <= a && a <= 45795 || 45797 <= a && a <= 45823 || 45825 <= a && a <= 45851 || 45853 <= a && a <= 45879 || 45881 <= a && a <= 45907 || 45909 <= a && a <= 45935 || 45937 <= a && a <= 45963 || 45965 <= a && a <= 45991 || 45993 <= a && a <= 46019 || 46021 <= a && a <= 46047 || 46049 <= a && a <= 46075 || 46077 <= a && a <= 46103 || 46105 <= a && a <= 46131 || 46133 <= a && a <= 46159 || 46161 <= a && a <= 46187 || 46189 <= a && a <= 46215 || 46217 <= a && a <= 46243 || 46245 <= a && a <= 46271 || 46273 <= a && a <= 46299 || 46301 <= a && a <= 46327 || 46329 <= a && a <= 46355 || 46357 <= a && a <= 46383 || 46385 <= a && a <= 46411 || 46413 <= a && a <= 46439 || 46441 <= a && a <= 46467 || 46469 <= a && a <= 46495 || 46497 <= a && a <= 46523 || 46525 <= a && a <= 46551 || 46553 <= a && a <= 46579 || 46581 <= a && a <= 46607 || 46609 <= a && a <= 46635 || 46637 <= a && a <= 46663 || 46665 <= a && a <= 46691 || 46693 <= a && a <= 46719 || 46721 <= a && a <= 46747 || 46749 <= a && a <= 46775 || 46777 <= a && a <= 46803 || 46805 <= a && a <= 46831 || 46833 <= a && a <= 46859 || 46861 <= a && a <= 46887 || 46889 <= a && a <= 46915 || 46917 <= a && a <= 46943 || 46945 <= a && a <= 46971 || 46973 <= a && a <= 46999 || 47001 <= a && a <= 47027 || 47029 <= a && a <= 47055 || 47057 <= a && a <= 47083 || 47085 <= a && a <= 47111 || 47113 <= a && a <= 47139 || 47141 <= a && a <= 47167 || 47169 <= a && a <= 47195 || 47197 <= a && a <= 47223 || 47225 <= a && a <= 47251 || 47253 <= a && a <= 47279 || 47281 <= a && a <= 47307 || 47309 <= a && a <= 47335 || 47337 <= a && a <= 47363 || 47365 <= a && a <= 47391 || 47393 <= a && a <= 47419 || 47421 <= a && a <= 47447 || 47449 <= a && a <= 47475 || 47477 <= a && a <= 47503 || 47505 <= a && a <= 47531 || 47533 <= a && a <= 47559 || 47561 <= a && a <= 47587 || 47589 <= a && a <= 47615 || 47617 <= a && a <= 47643 || 47645 <= a && a <= 47671 || 47673 <= a && a <= 47699 || 47701 <= a && a <= 47727 || 47729 <= a && a <= 47755 || 47757 <= a && a <= 47783 || 47785 <= a && a <= 47811 || 47813 <= a && a <= 47839 || 47841 <= a && a <= 47867 || 47869 <= a && a <= 47895 || 47897 <= a && a <= 47923 || 47925 <= a && a <= 47951 || 47953 <= a && a <= 47979 || 47981 <= a && a <= 48007 || 48009 <= a && a <= 48035 || 48037 <= a && a <= 48063 || 48065 <= a && a <= 48091 || 48093 <= a && a <= 48119 || 48121 <= a && a <= 48147 || 48149 <= a && a <= 48175 || 48177 <= a && a <= 48203 || 48205 <= a && a <= 48231 || 48233 <= a && a <= 48259 || 48261 <= a && a <= 48287 || 48289 <= a && a <= 48315 || 48317 <= a && a <= 48343 || 48345 <= a && a <= 48371 || 48373 <= a && a <= 48399 || 48401 <= a && a <= 48427 || 48429 <= a && a <= 48455 || 48457 <= a && a <= 48483 || 48485 <= a && a <= 48511 || 48513 <= a && a <= 48539 || 48541 <= a && a <= 48567 || 48569 <= a && a <= 48595 || 48597 <= a && a <= 48623 || 48625 <= a && a <= 48651 || 48653 <= a && a <= 48679 || 48681 <= a && a <= 48707 || 48709 <= a && a <= 48735 || 48737 <= a && a <= 48763 || 48765 <= a && a <= 48791 || 48793 <= a && a <= 48819 || 48821 <= a && a <= 48847 || 48849 <= a && a <= 48875 || 48877 <= a && a <= 48903 || 48905 <= a && a <= 48931 || 48933 <= a && a <= 48959 || 48961 <= a && a <= 48987 || 48989 <= a && a <= 49015 || 49017 <= a && a <= 49043 || 49045 <= a && a <= 49071 || 49073 <= a && a <= 49099 || 49101 <= a && a <= 49127 || 49129 <= a && a <= 49155 || 49157 <= a && a <= 49183 || 49185 <= a && a <= 49211 || 49213 <= a && a <= 49239 || 49241 <= a && a <= 49267 || 49269 <= a && a <= 49295 || 49297 <= a && a <= 49323 || 49325 <= a && a <= 49351 || 49353 <= a && a <= 49379 || 49381 <= a && a <= 49407 || 49409 <= a && a <= 49435 || 49437 <= a && a <= 49463 || 49465 <= a && a <= 49491 || 49493 <= a && a <= 49519 || 49521 <= a && a <= 49547 || 49549 <= a && a <= 49575 || 49577 <= a && a <= 49603 || 49605 <= a && a <= 49631 || 49633 <= a && a <= 49659 || 49661 <= a && a <= 49687 || 49689 <= a && a <= 49715 || 49717 <= a && a <= 49743 || 49745 <= a && a <= 49771 || 49773 <= a && a <= 49799 || 49801 <= a && a <= 49827 || 49829 <= a && a <= 49855 || 49857 <= a && a <= 49883 || 49885 <= a && a <= 49911 || 49913 <= a && a <= 49939 || 49941 <= a && a <= 49967 || 49969 <= a && a <= 49995 || 49997 <= a && a <= 50023 || 50025 <= a && a <= 50051 || 50053 <= a && a <= 50079 || 50081 <= a && a <= 50107 || 50109 <= a && a <= 50135 || 50137 <= a && a <= 50163 || 50165 <= a && a <= 50191 || 50193 <= a && a <= 50219 || 50221 <= a && a <= 50247 || 50249 <= a && a <= 50275 || 50277 <= a && a <= 50303 || 50305 <= a && a <= 50331 || 50333 <= a && a <= 50359 || 50361 <= a && a <= 50387 || 50389 <= a && a <= 50415 || 50417 <= a && a <= 50443 || 50445 <= a && a <= 50471 || 50473 <= a && a <= 50499 || 50501 <= a && a <= 50527 || 50529 <= a && a <= 50555 || 50557 <= a && a <= 50583 || 50585 <= a && a <= 50611 || 50613 <= a && a <= 50639 || 50641 <= a && a <= 50667 || 50669 <= a && a <= 50695 || 50697 <= a && a <= 50723 || 50725 <= a && a <= 50751 || 50753 <= a && a <= 50779 || 50781 <= a && a <= 50807 || 50809 <= a && a <= 50835 || 50837 <= a && a <= 50863 || 50865 <= a && a <= 50891 || 50893 <= a && a <= 50919 || 50921 <= a && a <= 50947 || 50949 <= a && a <= 50975 || 50977 <= a && a <= 51003 || 51005 <= a && a <= 51031 || 51033 <= a && a <= 51059 || 51061 <= a && a <= 51087 || 51089 <= a && a <= 51115 || 51117 <= a && a <= 51143 || 51145 <= a && a <= 51171 || 51173 <= a && a <= 51199 || 51201 <= a && a <= 51227 || 51229 <= a && a <= 51255 || 51257 <= a && a <= 51283 || 51285 <= a && a <= 51311 || 51313 <= a && a <= 51339 || 51341 <= a && a <= 51367 || 51369 <= a && a <= 51395 || 51397 <= a && a <= 51423 || 51425 <= a && a <= 51451 || 51453 <= a && a <= 51479 || 51481 <= a && a <= 51507 || 51509 <= a && a <= 51535 || 51537 <= a && a <= 51563 || 51565 <= a && a <= 51591 || 51593 <= a && a <= 51619 || 51621 <= a && a <= 51647 || 51649 <= a && a <= 51675 || 51677 <= a && a <= 51703 || 51705 <= a && a <= 51731 || 51733 <= a && a <= 51759 || 51761 <= a && a <= 51787 || 51789 <= a && a <= 51815 || 51817 <= a && a <= 51843 || 51845 <= a && a <= 51871 || 51873 <= a && a <= 51899 || 51901 <= a && a <= 51927 || 51929 <= a && a <= 51955 || 51957 <= a && a <= 51983 || 51985 <= a && a <= 52011 || 52013 <= a && a <= 52039 || 52041 <= a && a <= 52067 || 52069 <= a && a <= 52095 || 52097 <= a && a <= 52123 || 52125 <= a && a <= 52151 || 52153 <= a && a <= 52179 || 52181 <= a && a <= 52207 || 52209 <= a && a <= 52235 || 52237 <= a && a <= 52263 || 52265 <= a && a <= 52291 || 52293 <= a && a <= 52319 || 52321 <= a && a <= 52347 || 52349 <= a && a <= 52375 || 52377 <= a && a <= 52403 || 52405 <= a && a <= 52431 || 52433 <= a && a <= 52459 || 52461 <= a && a <= 52487 || 52489 <= a && a <= 52515 || 52517 <= a && a <= 52543 || 52545 <= a && a <= 52571 || 52573 <= a && a <= 52599 || 52601 <= a && a <= 52627 || 52629 <= a && a <= 52655 || 52657 <= a && a <= 52683 || 52685 <= a && a <= 52711 || 52713 <= a && a <= 52739 || 52741 <= a && a <= 52767 || 52769 <= a && a <= 52795 || 52797 <= a && a <= 52823 || 52825 <= a && a <= 52851 || 52853 <= a && a <= 52879 || 52881 <= a && a <= 52907 || 52909 <= a && a <= 52935 || 52937 <= a && a <= 52963 || 52965 <= a && a <= 52991 || 52993 <= a && a <= 53019 || 53021 <= a && a <= 53047 || 53049 <= a && a <= 53075 || 53077 <= a && a <= 53103 || 53105 <= a && a <= 53131 || 53133 <= a && a <= 53159 || 53161 <= a && a <= 53187 || 53189 <= a && a <= 53215 || 53217 <= a && a <= 53243 || 53245 <= a && a <= 53271 || 53273 <= a && a <= 53299 || 53301 <= a && a <= 53327 || 53329 <= a && a <= 53355 || 53357 <= a && a <= 53383 || 53385 <= a && a <= 53411 || 53413 <= a && a <= 53439 || 53441 <= a && a <= 53467 || 53469 <= a && a <= 53495 || 53497 <= a && a <= 53523 || 53525 <= a && a <= 53551 || 53553 <= a && a <= 53579 || 53581 <= a && a <= 53607 || 53609 <= a && a <= 53635 || 53637 <= a && a <= 53663 || 53665 <= a && a <= 53691 || 53693 <= a && a <= 53719 || 53721 <= a && a <= 53747 || 53749 <= a && a <= 53775 || 53777 <= a && a <= 53803 || 53805 <= a && a <= 53831 || 53833 <= a && a <= 53859 || 53861 <= a && a <= 53887 || 53889 <= a && a <= 53915 || 53917 <= a && a <= 53943 || 53945 <= a && a <= 53971 || 53973 <= a && a <= 53999 || 54001 <= a && a <= 54027 || 54029 <= a && a <= 54055 || 54057 <= a && a <= 54083 || 54085 <= a && a <= 54111 || 54113 <= a && a <= 54139 || 54141 <= a && a <= 54167 || 54169 <= a && a <= 54195 || 54197 <= a && a <= 54223 || 54225 <= a && a <= 54251 || 54253 <= a && a <= 54279 || 54281 <= a && a <= 54307 || 54309 <= a && a <= 54335 || 54337 <= a && a <= 54363 || 54365 <= a && a <= 54391 || 54393 <= a && a <= 54419 || 54421 <= a && a <= 54447 || 54449 <= a && a <= 54475 || 54477 <= a && a <= 54503 || 54505 <= a && a <= 54531 || 54533 <= a && a <= 54559 || 54561 <= a && a <= 54587 || 54589 <= a && a <= 54615 || 54617 <= a && a <= 54643 || 54645 <= a && a <= 54671 || 54673 <= a && a <= 54699 || 54701 <= a && a <= 54727 || 54729 <= a && a <= 54755 || 54757 <= a && a <= 54783 || 54785 <= a && a <= 54811 || 54813 <= a && a <= 54839 || 54841 <= a && a <= 54867 || 54869 <= a && a <= 54895 || 54897 <= a && a <= 54923 || 54925 <= a && a <= 54951 || 54953 <= a && a <= 54979 || 54981 <= a && a <= 55007 || 55009 <= a && a <= 55035 || 55037 <= a && a <= 55063 || 55065 <= a && a <= 55091 || 55093 <= a && a <= 55119 || 55121 <= a && a <= 55147 || 55149 <= a && a <= 55175 || 55177 <= a && a <= 55203 ? 10 : 9757 == a || 9977 == a || 9994 <= a && a <= 9997 || 127877 == a || 127938 <= a && a <= 127940 || 127943 == a || 127946 <= a && a <= 127948 || 128066 <= a && a <= 128067 || 128070 <= a && a <= 128080 || 128110 == a || 128112 <= a && a <= 128120 || 128124 == a || 128129 <= a && a <= 128131 || 128133 <= a && a <= 128135 || 128170 == a || 128372 <= a && a <= 128373 || 128378 == a || 128400 == a || 128405 <= a && a <= 128406 || 128581 <= a && a <= 128583 || 128587 <= a && a <= 128591 || 128675 == a || 128692 <= a && a <= 128694 || 128704 == a || 128716 == a || 129304 <= a && a <= 129308 || 129310 <= a && a <= 129311 || 129318 == a || 129328 <= a && a <= 129337 || 129341 <= a && a <= 129342 || 129489 <= a && a <= 129501 ? o : 127995 <= a && a <= 127999 ? 14 : 8205 == a ? 15 : 9792 == a || 9794 == a || 9877 <= a && a <= 9878 || 9992 == a || 10084 == a || 127752 == a || 127806 == a || 127859 == a || 127891 == a || 127908 == a || 127912 == a || 127979 == a || 127981 == a || 128139 == a || 128187 <= a && a <= 128188 || 128295 == a || 128300 == a || 128488 == a || 128640 == a || 128658 == a ? r : 128102 <= a && a <= 128105 ? s : 11
        }
        return this.nextBreak = function(e, t) {
            if (void 0 === t && (t = 0),
            t < 0)
                return 0;
            if (t >= e.length - 1)
                return e.length;
            for (var n, o, r = c(a(e, t)), s = [], l = t + 1; l < e.length; l++)
                if (o = l - 1,
                !(55296 <= (n = e).charCodeAt(o) && n.charCodeAt(o) <= 56319 && 56320 <= n.charCodeAt(o + 1) && n.charCodeAt(o + 1) <= 57343)) {
                    var u = c(a(e, l));
                    if (i(r, s, u))
                        return l;
                    s.push(u)
                }
            return e.length
        }
        ,
        this.splitGraphemes = function(e) {
            for (var t, n = [], o = 0; (t = this.nextBreak(e, o)) < e.length; )
                n.push(e.slice(o, t)),
                o = t;
            return o < e.length && n.push(e.slice(o)),
            n
        }
        ,
        this.iterateGraphemes = function(e) {
            var t = 0
              , n = {
                next: function() {
                    var n, o;
                    return (o = this.nextBreak(e, t)) < e.length ? (n = e.slice(t, o),
                    t = o,
                    {
                        value: n,
                        done: !1
                    }) : t < e.length ? (n = e.slice(t),
                    t = e.length,
                    {
                        value: n,
                        done: !1
                    }) : {
                        value: void 0,
                        done: !0
                    }
                }
                .bind(this)
            };
            return "undefined" != typeof Symbol && Symbol.iterator && (n[Symbol.iterator] = function() {
                return n
            }
            ),
            n
        }
        ,
        this.countGraphemes = function(e) {
            for (var t, n = 0, o = 0; (t = this.nextBreak(e, o)) < e.length; )
                o = t,
                n++;
            return o < e.length && n++,
            n
        }
        ,
        this
    }
    );
    var Tu = ku.exports;
    const Au = go().os.isMacOS() ? "\u2318" : "Ctrl"
      , Mu = Pe({
        tc_menu_name: "TinyComments",
        tc_conversations_title: "Comments",
        tc_announce_sidebar_available: `Comment. Sidebar available. Press ${Au} + Alt + M to switch to sidebar`,
        tc_items_addcomment: "Add comment",
        tc_items_showcomments: "Show comments",
        tc_items_deleteall: "Delete all conversations",
        tc_edit_buttons_save: "Save",
        tc_edit_buttons_cancel: "Cancel",
        tc_reply_buttons_comment: "Comment",
        tc_reply_buttons_clear: "Clear",
        tc_reply_placeholders: "Add comment...",
        tc_kebab_delete_conversation: "Delete conversation",
        tc_kebab_resolve_conversation: "Resolve conversation",
        tc_kebab_delete: "Delete",
        tc_kebab_edit: "Edit",
        tc_edit_problem_comment: "An error occurred editing this comment. See the console for details.",
        tc_edit_unauthorised_comment: "You are not allowed to edit this comment",
        tc_delete_buttons_cancel: "Cancel",
        tc_delete_buttons_proceed: "Delete",
        tc_resolve_buttons_proceed: "Resolve",
        tc_create_problem: "An error occurred while creating a comment. See the console for details",
        tc_reply_problem: "An error occurred while replying to a comment. See the console for details",
        tc_delete_prompts_conversation: "Delete this conversation?",
        tc_delete_prompts_conversation_detail_sing: "1 comment will be deleted. You can't undo this action.",
        tc_delete_prompts_conversation_detail_pl: "{0} comments will be deleted. You can't undo this action.",
        tc_delete_prompts_all: "Delete all conversations in the content? This cannot be undone.",
        tc_delete_prompts_comment: "Are you sure you want to delete this comment?",
        tc_resolve_prompts_conversation: "Resolve this conversation?",
        tc_resolve_prompts_conversation_detail_sing: "1 comment will be resolved. You can't undo this action.",
        tc_resolve_prompts_conversation_detail_pl: "{0} comments will be resolved. You can't undo this action.",
        tc_delete_problem_all: "An error occurred deleting all the conversations. See the console for details.",
        tc_delete_problem_conversation: "An error occurred deleting the conversation. See the console for details.",
        tc_delete_problem_comment: "An error occurred deleting the comment. See the console for details.",
        tc_delete_unauthorised_all: "You are not allowed to delete all the conversations",
        tc_delete_unauthorised_conversation: "You are not allowed to delete this conversation",
        tc_delete_unauthorised_comment: "You are not allowed to delete this comment",
        tc_resolve_unauthorised_conversation: "You are not allowed to resolve this conversation",
        tc_resolve_problem_conversation: "An error occurred resolving the conversation. See the console for details.",
        tc_date_less_than_a_minute_ago: "a moment ago",
        tc_date_1_minute_ago: "1 minute ago",
        tc_date_x_minutes_ago: "{0} minutes ago",
        tc_date_1_hour_ago: "1 hour ago",
        tc_date_x_hours_ago: "{0} hours ago",
        tc_date_1_day_ago: "1 day ago",
        tc_date_x_days_ago: "{0} days ago",
        tc_date_1_week_ago: "1 week ago",
        tc_date_x_weeks_ago: "{0} weeks ago",
        tc_date_1_month_ago: "1 month ago",
        tc_date_x_months_ago: "{0} months ago",
        tc_date_1_year_ago: "1 year ago",
        tc_date_x_years_ago: "{0} years ago",
        tc_date_comment_edited: " (edited)",
        tc_comment_buttons_showmore: "SHOW MORE",
        tc_comment_buttons_showless: "SHOW LESS"
    }, f)
      , Ru = "tox-button--kebab"
      , Nu = "tox-comment"
      , Fu = "tox-comment__body"
      , Bu = "tox-textarea"
      , Du = "tox-comment__reply"
      , Hu = "tox-comment__overlay"
      , Pu = "tox-comment__overlaytext"
      , Iu = "tox-comment__buttonspacing"
      , Vu = "tox-button"
      , Wu = "tox-comment__edit"
      , Lu = "tox-comment__scroll"
      , Uu = "tox-collection__item"
      , ju = "tox-conversations"
      , zu = `tox-comment__expander p:contains(${Mu.tc_comment_buttons_showmore})`
      , $u = `tox-comment__expander p:contains(${Mu.tc_comment_buttons_showless})`
      , qu = e=>`.${e}`
      , Gu = e=>t=>[`${qu(Nu)}:contains(${t})`, qu(e)].join(" ")
      , Ku = {
        kebab: qu(Ru),
        cardBody: `${qu(Nu)} ${qu(Fu)}`,
        card: qu(Nu),
        showMore: qu(zu),
        showLess: qu($u),
        editItem: [".tox-menu", `[role="menuitem"]:contains(${Mu.tc_kebab_edit})`].join(" "),
        deleteItem: [".tox-menu", `[role="menuitem"]:contains(${Mu.tc_kebab_delete})`].join(" "),
        deleteConversationItem: [".tox-menu", `[role="menuitem"]:contains(${Mu.tc_kebab_delete_conversation})`].join(" "),
        resolveConversationItem: [".tox-menu", `[role="menuitem"]:contains(${Mu.tc_kebab_resolve_conversation})`].join(" "),
        outerScroll: qu(Lu),
        outerContainer: qu(ju),
        cardFor: e=>`${qu(Nu)}:contains("${e}")`,
        cardN: e=>`${qu(Nu)}:nth-child(${e + 1})`,
        kebabFor: Gu(Ru),
        showMoreFor: Gu(zu),
        showLessFor: Gu($u),
        editSaveButton: `.tox-button:contains(${Mu.tc_edit_buttons_save})`,
        replyCommentButton: `.tox-button:contains(${Mu.tc_reply_buttons_comment})`,
        cancelButton: `.tox-button:contains(${Mu.tc_edit_buttons_cancel})`,
        clearButton: `.tox-button:contains(${Mu.tc_reply_buttons_clear})`,
        deleteButton: `.tox-button:contains(${Mu.tc_delete_buttons_proceed})`,
        resolveButton: `.tox-button:contains(${Mu.tc_resolve_buttons_proceed})`,
        commentText: [qu(ju), qu(Lu), qu(Nu), "textarea"].join(" "),
        editActions: qu(Wu),
        cardOverlay: qu(Hu),
        cardOverlayText: qu(Pu),
        cardOverlayButtons: qu(Iu),
        replyTextarea: `.${Du} textarea`,
        editTextarea: [qu(Nu), "textarea"].join(" "),
        kebabMenu: qu("tox-menu"),
        textarea: qu(Bu)
    }
      , Yu = {
        kebabOpen: `${Ru}--open`,
        bodyExpanded: "tox-comment__body--expanded",
        bodyNotAnimating: "tox-comment__body--pending",
        disappearing: "tox-comment--disappearing",
        commentThreadOverlay: "tox-comment-thread__overlay",
        bodyHasGradient: "tox-comment__gradient",
        editingTextarea: Bu
    }
      , Qu = {
        conversationsTitle: ["tox-conversations__title"],
        conversationsHead: ["tox-conversations__header"],
        showMoreLessContainer: ["tox-comment__expander"],
        outerContainer: [ju],
        date: ["tox-comment__date"],
        replySection: [Du],
        replyTextarea: [Bu],
        textarea: [],
        editTextarea: [],
        kebab: ["tox-button--naked", Ru, Vu, "tox-button--icon"],
        kebabIcon: ["tox-icon"],
        card: [Nu],
        cardHead: ["tox-comment__header"],
        cardHeadMeta: ["tox-comment__meta"],
        cardBody: [Fu],
        cardOverlay: [Hu],
        cardOverlayText: [Pu],
        cardOverlayButtons: [Iu],
        button: [Vu],
        secondaryButton: [Vu, "tox-button--secondary"],
        editActions: [Wu],
        outerScroll: [Lu],
        commentList: ["tox-comment-thread"],
        avatar: ["tox-user__avatar"],
        username: ["tox-user__name"],
        user: ["tox-user"],
        showMoreLess: [],
        kebabItem: [Uu],
        kebabItemLabel: ["tox-collection__item-label"],
        kebabDisabledItem: ["tox-collection__item--state-disabled"],
        kebabMenu: ["tox-menu", "tox-collection", "tox-collection--list"],
        kebabMenuGroup: ["tox-collection__group"],
        roots: [ju]
    }
      , Ju = {
        kebab: {
            backgroundMenu: "tox-menu--background",
            selectedMenu: "tox-menu--active",
            menu: "tox-menu",
            item: Uu,
            selectedItem: "tox-collection__item--active"
        }
    }
      , Xu = ["#2DC26B", "#F1C40F", "#E03E2D", "#B96AD9", "#3598DB", "#169179", "#E67E23", "#BA372A", "#843FA1", "#236FA1", "#95A5A6", "#7E8C8D", "#34495E"]
      , Zu = (e,t)=>E.from(t.authorAvatar).orThunk((()=>e.lookup(t.author))).getOrThunk((()=>{
        const n = ((e,t,n=36)=>{
            const o = n / 2;
            return `<svg height="${n}" width="${n}" xmlns="http://www.w3.org/2000/svg"><circle cx="${o}" cy="${o}" r="${o}" fill="${t}"/><text x="50%" y="50%" text-anchor="middle" dominant-baseline="central" fill="#FFF" font-family="sans-serif" font-size="${o}">` + (e=>(new Tu).splitGraphemes(e)[0])(e) + "</text></svg>"
        }
        )(t.authorName, (()=>{
            const e = Math.floor(Math.random() * Xu.length);
            return Xu[e]
        }
        )())
          , o = "data:image/svg+xml," + encodeURIComponent(n);
        return e.store(t.author, o),
        o
    }
    ));
    var ed = Object.freeze({
        __proto__: null,
        getCurrent: (e,t,n)=>t.find(e)
    });
    const td = [pn("find")]
      , nd = yr({
        fields: td,
        name: "composing",
        apis: ed
    })
      , od = (e,t)=>{
        t.ignore || (Sr(e.element),
        t.onFocus(e))
    }
    ;
    var rd = Object.freeze({
        __proto__: null,
        focus: od,
        blur: (e,t)=>{
            t.ignore || (e=>{
                e.dom.blur()
            }
            )(e.element)
        }
        ,
        isFocused: e=>(e=>{
            const t = Ce(e).dom;
            return e.dom === t.activeElement
        }
        )(e.element)
    })
      , sd = Object.freeze({
        __proto__: null,
        exhibit: (e,t)=>{
            const n = t.ignore ? {} : {
                attributes: {
                    tabindex: "-1"
                }
            };
            return gr(n)
        }
        ,
        events: e=>Jo([Zo(Ao(), ((t,n)=>{
            od(t, e),
            n.stop()
        }
        ))].concat(e.stopMousedown ? [Zo(bo(), ((e,t)=>{
            t.event.prevent()
        }
        ))] : []))
    })
      , ad = [Ia("onFocus"), wn("stopMousedown", !1), wn("ignore", !1)];
    const id = yr({
        fields: ad,
        name: "focusing",
        active: sd,
        apis: rd
    })
      , cd = (e,t,n)=>{
        t.store.manager.onLoad(e, t, n)
    }
      , ld = (e,t,n)=>{
        t.store.manager.onUnload(e, t, n)
    }
    ;
    var ud = Object.freeze({
        __proto__: null,
        onLoad: cd,
        onUnload: ld,
        setValue: (e,t,n,o)=>{
            t.store.manager.setValue(e, t, n, o)
        }
        ,
        getValue: (e,t,n)=>t.store.manager.getValue(e, t, n),
        getState: (e,t,n)=>n
    })
      , dd = Object.freeze({
        __proto__: null,
        events: (e,t)=>{
            const n = e.resetOnDom ? [rr(((n,o)=>{
                cd(n, e, t)
            }
            )), sr(((n,o)=>{
                ld(n, e, t)
            }
            ))] : [pr(e, t, cd)];
            return Jo(n)
        }
    });
    const md = ()=>{
        const e = mt(null);
        return Cn({
            set: e.set,
            get: e.get,
            isNotSet: ()=>null === e.get(),
            clear: ()=>{
                e.set(null)
            }
            ,
            readState: ()=>({
                mode: "memory",
                value: e.get()
            })
        })
    }
      , gd = ()=>{
        const e = mt({})
          , t = mt({});
        return Cn({
            readState: ()=>({
                mode: "dataset",
                dataByValue: e.get(),
                dataByText: t.get()
            }),
            lookup: n=>ze(e.get(), n).orThunk((()=>ze(t.get(), n))),
            update: n=>{
                const o = e.get()
                  , r = t.get()
                  , s = {}
                  , a = {};
                j(n, (e=>{
                    s[e.value] = e,
                    ze(e, "meta").each((t=>{
                        ze(t, "text").each((t=>{
                            a[t] = e
                        }
                        ))
                    }
                    ))
                }
                )),
                e.set({
                    ...o,
                    ...s
                }),
                t.set({
                    ...r,
                    ...a
                })
            }
            ,
            clear: ()=>{
                e.set({}),
                t.set({})
            }
        })
    }
    ;
    var pd = Object.freeze({
        __proto__: null,
        memory: md,
        dataset: gd,
        manual: ()=>Cn({
            readState: p
        }),
        init: e=>e.store.manager.state(e)
    });
    const hd = (e,t,n,o)=>{
        const r = t.store;
        n.update([o]),
        r.setValue(e, o),
        t.onSetValue(e, o)
    }
    ;
    var vd = [bn("initialValue"), pn("getFallbackEntry"), pn("getDataKey"), pn("setValue"), Ua("manager", {
        setValue: hd,
        getValue: (e,t,n)=>{
            const o = t.store
              , r = o.getDataKey(e);
            return n.lookup(r).getOrThunk((()=>o.getFallbackEntry(r)))
        }
        ,
        onLoad: (e,t,n)=>{
            t.store.initialValue.each((o=>{
                hd(e, t, n, o)
            }
            ))
        }
        ,
        onUnload: (e,t,n)=>{
            n.clear()
        }
        ,
        state: gd
    })]
      , fd = [pn("getValue"), wn("setValue", p), bn("initialValue"), Ua("manager", {
        setValue: (e,t,n,o)=>{
            t.store.setValue(e, o),
            t.onSetValue(e, o)
        }
        ,
        getValue: (e,t,n)=>t.store.getValue(e),
        onLoad: (e,t,n)=>{
            t.store.initialValue.each((n=>{
                t.store.setValue(e, n)
            }
            ))
        }
        ,
        onUnload: p,
        state: Sn.init
    })]
      , bd = [bn("initialValue"), Ua("manager", {
        setValue: (e,t,n,o)=>{
            n.set(o),
            t.onSetValue(e, o)
        }
        ,
        getValue: (e,t,n)=>n.get(),
        onLoad: (e,t,n)=>{
            t.store.initialValue.each((e=>{
                n.isNotSet() && n.set(e)
            }
            ))
        }
        ,
        onUnload: (e,t,n)=>{
            n.clear()
        }
        ,
        state: md
    })]
      , yd = [On("store", {
        mode: "memory"
    }, dn("mode", {
        memory: bd,
        manual: fd,
        dataset: vd
    })), Ia("onSetValue"), wn("resetOnDom", !1)];
    const _d = yr({
        fields: yd,
        name: "representing",
        active: dd,
        apis: ud,
        extra: {
            setValueFrom: (e,t)=>{
                const n = _d.getValue(t);
                _d.setValue(e, n)
            }
        },
        state: pd
    });
    var xd = Object.freeze({
        __proto__: null,
        exhibit: (e,t)=>gr({
            attributes: Tn([{
                key: t.tabAttr,
                value: "true"
            }])
        })
    })
      , wd = [wn("tabAttr", "data-alloy-tabstop")];
    const Od = yr({
        fields: wd,
        name: "tabstopping",
        active: xd
    })
      , Sd = (e,t,n,o)=>ze(t.routes, o.start).bind((e=>ze(e, o.destination)))
      , Cd = (e,t,n,o)=>Sd(0, t, 0, o).bind((e=>e.transition.map((t=>({
        transition: t,
        route: e
    })))))
      , Ed = (e,t,n)=>{
        ((e,t,n)=>kd(e, t).bind((e=>Cd(0, t, 0, e))))(e, t).each((n=>{
            const o = n.transition;
            Js(e.element, o.transitionClass),
            Ir(e.element, t.destinationAttr)
        }
        ))
    }
      , kd = (e,t,n)=>{
        const o = e.element;
        return Hr(o, t.destinationAttr).map((n=>({
            start: Dr(e.element, t.stateAttr),
            destination: n
        })))
    }
      , Td = (e,t,n,o)=>{
        Ed(e, t),
        Pr(e.element, t.stateAttr) && Dr(e.element, t.stateAttr) !== o && t.onFinish(e, o),
        Fr(e.element, t.stateAttr, o)
    }
    ;
    var Ad = Object.freeze({
        __proto__: null,
        findRoute: Sd,
        disableTransition: Ed,
        getCurrentRoute: kd,
        jumpTo: Td,
        progressTo: (e,t,n,o)=>{
            ((e,t,n,o)=>{
                Pr(e.element, t.destinationAttr) && (Hr(e.element, t.destinationAttr).each((n=>{
                    Fr(e.element, t.stateAttr, n)
                }
                )),
                Ir(e.element, t.destinationAttr))
            }
            )(e, t);
            const r = ((e,t,n,o)=>({
                start: Dr(e.element, t.stateAttr),
                destination: o
            }))(e, t, 0, o);
            Cd(0, t, 0, r).fold((()=>{
                Td(e, t, 0, o)
            }
            ), (n=>{
                Ed(e, t);
                const r = n.transition;
                Qs(e.element, r.transitionClass),
                Fr(e.element, t.destinationAttr, o)
            }
            ))
        }
        ,
        getState: (e,t,n)=>Hr(e.element, t.stateAttr)
    })
      , Md = Object.freeze({
        __proto__: null,
        events: (e,t)=>Jo([Zo(Co(), ((t,n)=>{
            const o = n.event.raw;
            kd(t, e).each((n=>{
                Sd(0, e, 0, n).each((r=>{
                    r.transition.each((r=>{
                        o.propertyName === r.property && (Td(t, e, 0, n.destination),
                        e.onTransition(t, n))
                    }
                    ))
                }
                ))
            }
            ))
        }
        )), rr(((t,n)=>{
            Td(t, e, 0, e.initialState)
        }
        ))])
    })
      , Rd = [wn("destinationAttr", "data-transitioning-destination"), wn("stateAttr", "data-transitioning-state"), pn("initialState"), Ia("onTransition"), Ia("onFinish"), hn("routes", sn(ot.value, sn(ot.value, Kt([xn("transition", [pn("property"), pn("transitionClass")])]))))];
    const Nd = yr({
        fields: Rd,
        name: "transitioning",
        active: Md,
        apis: Ad,
        extra: {
            createRoutes: e=>{
                const t = {};
                return He(e, ((e,n)=>{
                    const o = n.split("<->");
                    t[o[0]] = kn(o[1], e),
                    t[o[1]] = kn(o[0], e)
                }
                )),
                t
            }
            ,
            createBistate: (e,t,n)=>Tn([{
                key: e,
                value: kn(t, n)
            }, {
                key: t,
                value: kn(e, n)
            }]),
            createTristate: (e,t,n,o)=>Tn([{
                key: e,
                value: Tn([{
                    key: t,
                    value: o
                }, {
                    key: n,
                    value: o
                }])
            }, {
                key: t,
                value: Tn([{
                    key: e,
                    value: o
                }, {
                    key: n,
                    value: o
                }])
            }, {
                key: n,
                value: Tn([{
                    key: e,
                    value: o
                }, {
                    key: t,
                    value: o
                }])
            }])
        }
    })
      , Fd = (e,t,n,o)=>{
        const r = n.get();
        n.set(o),
        ((e,t,n)=>{
            t.toggleClass.each((t=>{
                n.get() ? Qs(e.element, t) : Js(e.element, t)
            }
            ))
        }
        )(e, t, n),
        ((e,t,n)=>{
            const o = t.aria;
            o.update(e, o, n.get())
        }
        )(e, t, n),
        r !== o && t.onToggled(e, o)
    }
      , Bd = (e,t,n)=>{
        Fd(e, t, n, !n.get())
    }
      , Dd = (e,t,n)=>{
        Fd(e, t, n, t.selected)
    }
    ;
    var Hd = Object.freeze({
        __proto__: null,
        onLoad: Dd,
        toggle: Bd,
        isOn: (e,t,n)=>n.get(),
        on: (e,t,n)=>{
            Fd(e, t, n, !0)
        }
        ,
        off: (e,t,n)=>{
            Fd(e, t, n, !1)
        }
        ,
        set: Fd
    })
      , Pd = Object.freeze({
        __proto__: null,
        exhibit: ()=>gr({}),
        events: (e,t)=>{
            const n = (o = e,
            r = t,
            s = Bd,
            ir((e=>{
                s(e, o, r)
            }
            )));
            var o, r, s;
            const a = pr(e, t, Dd);
            return Jo(Y([e.toggleOnExecute ? [n] : [], [a]]))
        }
    });
    const Id = (e,t,n)=>{
        Fr(e.element, "aria-expanded", n)
    }
    ;
    var Vd = [wn("selected", !1), bn("toggleClass"), wn("toggleOnExecute", !0), Ia("onToggled"), On("aria", {
        mode: "none"
    }, dn("mode", {
        pressed: [wn("syncWithExpanded", !1), Ua("update", ((e,t,n)=>{
            Fr(e.element, "aria-pressed", n),
            t.syncWithExpanded && Id(e, 0, n)
        }
        ))],
        checked: [Ua("update", ((e,t,n)=>{
            Fr(e.element, "aria-checked", n)
        }
        ))],
        expanded: [Ua("update", Id)],
        selected: [Ua("update", ((e,t,n)=>{
            Fr(e.element, "aria-selected", n)
        }
        ))],
        none: [Ua("update", p)]
    }))];
    const Wd = yr({
        fields: Vd,
        name: "toggling",
        active: Pd,
        apis: Hd,
        state: (!1,
        {
            init: ()=>{
                const e = mt(false);
                return {
                    get: ()=>e.get(),
                    set: t=>e.set(t),
                    clear: ()=>e.set(false),
                    readState: ()=>e.get()
                }
            }
        })
    });
    const Ld = ()=>{
        const e = (e,t)=>{
            t.stop(),
            Ko(e)
        }
        ;
        return [Zo(Oo(), e), Zo(Do(), e), tr(ho()), tr(bo())]
    }
      , Ud = e=>Jo(Y([e.map((e=>ir(((t,n)=>{
        e(t),
        n.stop()
    }
    )))).toArray(), Ld()]))
      , jd = (e,t,n)=>{
        const o = X(e.slice(0, t))
          , r = X(e.slice(t + 1));
        return G(o.concat(r), n)
    }
      , zd = (e,t,n)=>{
        const o = X(e.slice(0, t));
        return G(o, n)
    }
      , $d = (e,t,n)=>{
        const o = e.slice(0, t)
          , r = e.slice(t + 1);
        return G(r.concat(o), n)
    }
      , qd = (e,t,n)=>{
        const o = e.slice(t + 1);
        return G(o, n)
    }
      , Gd = e=>t=>{
        const n = t.raw;
        return W(e, n.which)
    }
      , Kd = e=>t=>J(e, (e=>e(t)))
      , Yd = e=>!0 === e.raw.shiftKey
      , Qd = e=>!0 === e.raw.ctrlKey
      , Jd = (Xd = Yd,
    e=>!Xd(e));
    var Xd;
    const Zd = (e,t)=>({
        matches: e,
        classification: t
    })
      , em = (e,t,n,o)=>{
        const r = lt(e.element, "." + t.highlightClass);
        j(r, (n=>{
            L(o, (e=>e.element === n)) || (Js(n, t.highlightClass),
            e.getSystem().getByDom(n).each((n=>{
                t.onDehighlight(e, n),
                qo(n, $o())
            }
            )))
        }
        ))
    }
      , tm = (e,t,n,o)=>{
        em(e, t, 0, [o]),
        nm(e, t, n, o) || (Qs(o.element, t.highlightClass),
        t.onHighlight(e, o),
        qo(o, zo()))
    }
      , nm = (e,t,n,o)=>Xs(o.element, t.highlightClass)
      , om = (e,t,n)=>es(e.element, "." + t.itemClass).bind((t=>e.getSystem().getByDom(t).toOptional()))
      , rm = (e,t,n)=>{
        const o = lt(e.element, "." + t.itemClass);
        return (o.length > 0 ? E.some(o[o.length - 1]) : E.none()).bind((t=>e.getSystem().getByDom(t).toOptional()))
    }
      , sm = (e,t,n,o)=>{
        const r = lt(e.element, "." + t.itemClass);
        return K(r, (e=>Xs(e, t.highlightClass))).bind((t=>{
            const n = Tc(t, o, 0, r.length - 1);
            return e.getSystem().getByDom(r[n]).toOptional()
        }
        ))
    }
      , am = (e,t,n)=>{
        const o = lt(e.element, "." + t.itemClass);
        return lr(U(o, (t=>e.getSystem().getByDom(t).toOptional())))
    }
    ;
    var im = Object.freeze({
        __proto__: null,
        dehighlightAll: (e,t,n)=>em(e, t, 0, []),
        dehighlight: (e,t,n,o)=>{
            nm(e, t, n, o) && (Js(o.element, t.highlightClass),
            t.onDehighlight(e, o),
            qo(o, $o()))
        }
        ,
        highlight: tm,
        highlightFirst: (e,t,n)=>{
            om(e, t).each((o=>{
                tm(e, t, n, o)
            }
            ))
        }
        ,
        highlightLast: (e,t,n)=>{
            rm(e, t).each((o=>{
                tm(e, t, n, o)
            }
            ))
        }
        ,
        highlightAt: (e,t,n,o)=>{
            ((e,t,n,o)=>{
                const r = lt(e.element, "." + t.itemClass);
                return E.from(r[o]).fold((()=>ot.error(new Error("No element found with index " + o))), e.getSystem().getByDom)
            }
            )(e, t, 0, o).fold((e=>{
                throw e
            }
            ), (o=>{
                tm(e, t, n, o)
            }
            ))
        }
        ,
        highlightBy: (e,t,n,o)=>{
            const r = am(e, t);
            G(r, o).each((o=>{
                tm(e, t, n, o)
            }
            ))
        }
        ,
        isHighlighted: nm,
        getHighlighted: (e,t,n)=>es(e.element, "." + t.highlightClass).bind((t=>e.getSystem().getByDom(t).toOptional())),
        getFirst: om,
        getLast: rm,
        getPrevious: (e,t,n)=>sm(e, t, 0, -1),
        getNext: (e,t,n)=>sm(e, t, 0, 1),
        getCandidates: am
    })
      , cm = [pn("highlightClass"), pn("itemClass"), Ia("onHighlight"), Ia("onDehighlight")];
    const lm = yr({
        fields: cm,
        name: "highlighting",
        apis: im
    })
      , um = (e,t,n)=>{
        t.exists((e=>n.exists((t=>ie(t, e))))) || Go(e, jo(), {
            prevFocus: t,
            newFocus: n
        })
    }
      , dm = ()=>{
        const e = e=>Er(e.element);
        return {
            get: e,
            set: (t,n)=>{
                const o = e(t);
                t.getSystem().triggerFocus(n, t.element);
                const r = e(t);
                um(t, o, r)
            }
        }
    }
      , mm = ()=>{
        const e = e=>lm.getHighlighted(e).map((e=>e.element));
        return {
            get: e,
            set: (t,n)=>{
                const o = e(t);
                t.getSystem().getByDom(n).fold(p, (e=>{
                    lm.highlight(t, e)
                }
                ));
                const r = e(t);
                um(t, o, r)
            }
        }
    }
    ;
    var gm;
    !function(e) {
        e.OnFocusMode = "onFocus",
        e.OnEnterOrSpaceMode = "onEnterOrSpace",
        e.OnApiMode = "onApi"
    }(gm || (gm = {}));
    const pm = (e,t,n,o,r)=>{
        const s = (e,t,n,o,r)=>((e,t)=>{
            const n = G(e, (e=>e.matches(t)));
            return n.map((e=>e.classification))
        }
        )(n(e, t, o, r), t.event).bind((n=>n(e, t, o, r)))
          , a = {
            schema: ()=>e.concat([wn("focusManager", dm()), On("focusInside", "onFocus", rn((e=>W(["onFocus", "onEnterOrSpace", "onApi"], e) ? ot.value(e) : ot.error("Invalid value for focusInside")))), Ua("handler", a), Ua("state", t), Ua("sendFocusIn", r)]),
            processKey: s,
            toEvents: (e,t)=>{
                const a = e.focusInside !== gm.OnFocusMode ? E.none() : r(e).map((n=>Zo(Ao(), ((o,r)=>{
                    n(o, e, t),
                    r.stop()
                }
                ))))
                  , i = [Zo(_o(), ((o,a)=>{
                    s(o, a, n, e, t).fold((()=>{
                        ((n,o)=>{
                            const s = Gd(as.concat(rs))(o.event);
                            e.focusInside === gm.OnEnterOrSpaceMode && s && Mn(n, o) && r(e).each((r=>{
                                r(n, e, t),
                                o.stop()
                            }
                            ))
                        }
                        )(o, a)
                    }
                    ), (e=>{
                        a.stop()
                    }
                    ))
                }
                )), Zo(xo(), ((n,r)=>{
                    s(n, r, o, e, t).each((e=>{
                        r.stop()
                    }
                    ))
                }
                ))];
                return Jo(a.toArray().concat(i))
            }
        };
        return a
    }
      , hm = e=>{
        const t = [bn("onEscape"), bn("onEnter"), wn("selector", '[data-alloy-tabstop="true"]:not(:disabled)'), wn("firstTabstop", 0), wn("useTabstopAt", O), bn("visibilitySelector")].concat([e])
          , n = (e,t)=>{
            const n = e.visibilitySelector.bind((e=>ts(t, e))).getOr(t);
            return Yi(n) > 0
        }
          , o = (e,t,o)=>{
            ((e,t)=>{
                const o = lt(e.element, t.selector)
                  , r = z(o, (e=>n(t, e)));
                return E.from(r[t.firstTabstop])
            }
            )(e, t).each((n=>{
                t.focusManager.set(e, n)
            }
            ))
        }
          , r = (e,t,o,r)=>{
            const s = lt(e.element, o.selector);
            return ((e,t)=>t.focusManager.get(e).bind((e=>ts(e, t.selector))))(e, o).bind((t=>K(s, y(ie, t)).bind((t=>((e,t,o,r,s)=>s(t, o, (e=>((e,t)=>n(e, t) && e.useTabstopAt(t))(r, e))).fold((()=>r.cyclic ? E.some(!0) : E.none()), (t=>(r.focusManager.set(e, t),
            E.some(!0)))))(e, s, t, o, r)))))
        }
          , s = v([Zd(Kd([Yd, Gd(os)]), ((e,t,n)=>{
            const o = n.cyclic ? jd : zd;
            return r(e, 0, n, o)
        }
        )), Zd(Gd(os), ((e,t,n)=>{
            const o = n.cyclic ? $d : qd;
            return r(e, 0, n, o)
        }
        )), Zd(Kd([Jd, Gd(rs)]), ((e,t,n)=>n.onEnter.bind((n=>n(e, t)))))])
          , a = v([Zd(Gd(ss), ((e,t,n)=>n.onEscape.bind((n=>n(e, t)))))]);
        return pm(t, Sn.init, s, a, (()=>E.some(o)))
    }
    ;
    var vm = hm(gn("cyclic", w))
      , fm = hm(gn("cyclic", O));
    const bm = e=>pe("input")(e) && "radio" !== Dr(e, "type") || pe("textarea")(e)
      , ym = (e,t,n)=>bm(n) && Gd(as)(t.event) ? E.none() : ((e,t,n)=>(Yo(e, n, Fo()),
    E.some(!0)))(e, 0, n)
      , _m = (e,t)=>E.some(!0)
      , xm = [wn("execute", ym), wn("useSpace", !1), wn("useEnter", !0), wn("useControlEnter", !1), wn("useDown", !1)]
      , wm = (e,t,n)=>n.execute(e, t, e.element);
    var Om = pm(xm, Sn.init, ((e,t,n,o)=>{
        const r = n.useSpace && !bm(e.element) ? as : []
          , s = n.useEnter ? rs : []
          , a = n.useDown ? us : []
          , i = r.concat(s).concat(a);
        return [Zd(Gd(i), wm)].concat(n.useControlEnter ? [Zd(Kd([Qd, Gd(rs)]), wm)] : [])
    }
    ), ((e,t,n,o)=>n.useSpace && !bm(e.element) ? [Zd(Gd(as), _m)] : []), (()=>E.none()));
    const Sm = ()=>{
        const e = Yr();
        return Cn({
            readState: ()=>e.get().map((e=>({
                numRows: String(e.numRows),
                numColumns: String(e.numColumns)
            }))).getOr({
                numRows: "?",
                numColumns: "?"
            }),
            setGridSize: (t,n)=>{
                e.set({
                    numRows: t,
                    numColumns: n
                })
            }
            ,
            getNumRows: ()=>e.get().map((e=>e.numRows)),
            getNumColumns: ()=>e.get().map((e=>e.numColumns))
        })
    }
    ;
    var Cm = Object.freeze({
        __proto__: null,
        flatgrid: Sm,
        init: e=>e.state(e)
    });
    const Em = e=>(t,n,o,r)=>{
        const s = e(t.element);
        return Mm(s, t, n, o, r)
    }
      , km = (e,t)=>{
        const n = ul(e, t);
        return Em(n)
    }
      , Tm = (e,t)=>{
        const n = ul(t, e);
        return Em(n)
    }
      , Am = e=>(t,n,o,r)=>Mm(e, t, n, o, r)
      , Mm = (e,t,n,o,r)=>o.focusManager.get(t).bind((n=>e(t.element, n, o, r))).map((e=>(o.focusManager.set(t, e),
    !0)))
      , Rm = Am
      , Nm = Am
      , Fm = Am
      , Bm = (e,t,n)=>{
        const o = lt(e, n);
        return ((e,n)=>K(e, (e=>ie(e, t))).map((t=>({
            index: t,
            candidates: e
        }))))(z(o, Cu))
    }
      , Dm = (e,t)=>K(e, (e=>ie(t, e)))
      , Hm = (e,t,n,o)=>o(Math.floor(t / n), t % n).bind((t=>{
        const o = t.row * n + t.column;
        return o >= 0 && o < e.length ? E.some(e[o]) : E.none()
    }
    ))
      , Pm = (e,t,n,o,r)=>Hm(e, t, o, ((t,s)=>{
        const a = t === n - 1 ? e.length - t * o : o
          , i = Tc(s, r, 0, a - 1);
        return E.some({
            row: t,
            column: i
        })
    }
    ))
      , Im = (e,t,n,o,r)=>Hm(e, t, o, ((t,s)=>{
        const a = Tc(t, r, 0, n - 1)
          , i = a === n - 1 ? e.length - a * o : o
          , c = Ac(s, 0, i - 1);
        return E.some({
            row: a,
            column: c
        })
    }
    ))
      , Vm = [pn("selector"), wn("execute", ym), Va("onEscape"), wn("captureTab", !1), za()]
      , Wm = (e,t,n)=>{
        es(e.element, t.selector).each((n=>{
            t.focusManager.set(e, n)
        }
        ))
    }
      , Lm = e=>(t,n,o,r)=>Bm(t, n, o.selector).bind((t=>e(t.candidates, t.index, r.getNumRows().getOr(o.initSize.numRows), r.getNumColumns().getOr(o.initSize.numColumns))))
      , Um = (e,t,n)=>n.captureTab ? E.some(!0) : E.none()
      , jm = Lm(((e,t,n,o)=>Pm(e, t, n, o, -1)))
      , zm = Lm(((e,t,n,o)=>Pm(e, t, n, o, 1)))
      , $m = Lm(((e,t,n,o)=>Im(e, t, n, o, -1)))
      , qm = Lm(((e,t,n,o)=>Im(e, t, n, o, 1)))
      , Gm = v([Zd(Gd(is), km(jm, zm)), Zd(Gd(ls), Tm(jm, zm)), Zd(Gd(cs), Rm($m)), Zd(Gd(us), Nm(qm)), Zd(Kd([Yd, Gd(os)]), Um), Zd(Kd([Jd, Gd(os)]), Um), Zd(Gd(as.concat(rs)), ((e,t,n,o)=>((e,t)=>t.focusManager.get(e).bind((e=>ts(e, t.selector))))(e, n).bind((o=>n.execute(e, t, o)))))])
      , Km = v([Zd(Gd(ss), ((e,t,n)=>n.onEscape(e, t))), Zd(Gd(as), _m)]);
    var Ym = pm(Vm, Sm, Gm, Km, (()=>E.some(Wm)));
    const Qm = (e,t,n,o)=>{
        const r = (e,t,n)=>{
            const s = Tc(t, o, 0, n.length - 1);
            return s === e ? E.none() : (a = n[s],
            "button" === ce(a) && "disabled" === Dr(a, "disabled") ? r(e, s, n) : E.from(n[s]));
            var a
        }
        ;
        return Bm(e, n, t).bind((e=>{
            const t = e.index
              , n = e.candidates;
            return r(t, t, n)
        }
        ))
    }
      , Jm = [pn("selector"), wn("getInitial", E.none), wn("execute", ym), Va("onEscape"), wn("executeOnMove", !1), wn("allowVertical", !0)]
      , Xm = (e,t,n)=>((e,t)=>t.focusManager.get(e).bind((e=>ts(e, t.selector))))(e, n).bind((o=>n.execute(e, t, o)))
      , Zm = (e,t,n)=>{
        t.getInitial(e).orThunk((()=>es(e.element, t.selector))).each((n=>{
            t.focusManager.set(e, n)
        }
        ))
    }
      , eg = (e,t,n)=>Qm(e, n.selector, t, -1)
      , tg = (e,t,n)=>Qm(e, n.selector, t, 1)
      , ng = e=>(t,n,o,r)=>e(t, n, o, r).bind((()=>o.executeOnMove ? Xm(t, n, o) : E.some(!0)))
      , og = v([Zd(Gd(as), _m), Zd(Gd(ss), ((e,t,n)=>n.onEscape(e, t)))]);
    var rg = pm(Jm, Sn.init, ((e,t,n,o)=>{
        const r = is.concat(n.allowVertical ? cs : [])
          , s = ls.concat(n.allowVertical ? us : []);
        return [Zd(Gd(r), ng(km(eg, tg))), Zd(Gd(s), ng(Tm(eg, tg))), Zd(Gd(rs), Xm), Zd(Gd(as), Xm)]
    }
    ), og, (()=>E.some(Zm)));
    const sg = (e,t,n)=>E.from(e[t]).bind((e=>E.from(e[n]).map((e=>({
        rowIndex: t,
        columnIndex: n,
        cell: e
    })))))
      , ag = (e,t,n,o)=>{
        const r = e[t].length
          , s = Tc(n, o, 0, r - 1);
        return sg(e, t, s)
    }
      , ig = (e,t,n,o)=>{
        const r = Tc(n, o, 0, e.length - 1)
          , s = e[r].length
          , a = Ac(t, 0, s - 1);
        return sg(e, r, a)
    }
      , cg = (e,t,n,o)=>{
        const r = e[t].length
          , s = Ac(n + o, 0, r - 1);
        return sg(e, t, s)
    }
      , lg = (e,t,n,o)=>{
        const r = Ac(n + o, 0, e.length - 1)
          , s = e[r].length
          , a = Ac(t, 0, s - 1);
        return sg(e, r, a)
    }
      , ug = [fn("selectors", [pn("row"), pn("cell")]), wn("cycles", !0), wn("previousSelector", E.none), wn("execute", ym)]
      , dg = (e,t,n)=>{
        const o = t.previousSelector(e).orThunk((()=>{
            const n = t.selectors;
            return es(e.element, n.cell)
        }
        ));
        o.each((n=>{
            t.focusManager.set(e, n)
        }
        ))
    }
      , mg = (e,t)=>(n,o,r)=>{
        const s = r.cycles ? e : t;
        return ts(o, r.selectors.row).bind((e=>{
            const t = lt(e, r.selectors.cell);
            return Dm(t, o).bind((t=>{
                const o = lt(n, r.selectors.row);
                return Dm(o, e).bind((e=>{
                    const n = ((e,t)=>U(e, (e=>lt(e, t.selectors.cell))))(o, r);
                    return s(n, e, t).map((e=>e.cell))
                }
                ))
            }
            ))
        }
        ))
    }
      , gg = mg(((e,t,n)=>ag(e, t, n, -1)), ((e,t,n)=>cg(e, t, n, -1)))
      , pg = mg(((e,t,n)=>ag(e, t, n, 1)), ((e,t,n)=>cg(e, t, n, 1)))
      , hg = mg(((e,t,n)=>ig(e, n, t, -1)), ((e,t,n)=>lg(e, n, t, -1)))
      , vg = mg(((e,t,n)=>ig(e, n, t, 1)), ((e,t,n)=>lg(e, n, t, 1)))
      , fg = v([Zd(Gd(is), km(gg, pg)), Zd(Gd(ls), Tm(gg, pg)), Zd(Gd(cs), Rm(hg)), Zd(Gd(us), Nm(vg)), Zd(Gd(as.concat(rs)), ((e,t,n)=>Er(e.element).bind((o=>n.execute(e, t, o)))))])
      , bg = v([Zd(Gd(as), _m)]);
    var yg = pm(ug, Sn.init, fg, bg, (()=>E.some(dg)));
    const _g = [pn("selector"), wn("execute", ym), wn("moveOnTab", !1)]
      , xg = (e,t,n)=>n.focusManager.get(e).bind((o=>n.execute(e, t, o)))
      , wg = (e,t,n)=>{
        es(e.element, t.selector).each((n=>{
            t.focusManager.set(e, n)
        }
        ))
    }
      , Og = (e,t,n)=>Qm(e, n.selector, t, -1)
      , Sg = (e,t,n)=>Qm(e, n.selector, t, 1)
      , Cg = v([Zd(Gd(cs), Fm(Og)), Zd(Gd(us), Fm(Sg)), Zd(Kd([Yd, Gd(os)]), ((e,t,n,o)=>n.moveOnTab ? Fm(Og)(e, t, n, o) : E.none())), Zd(Kd([Jd, Gd(os)]), ((e,t,n,o)=>n.moveOnTab ? Fm(Sg)(e, t, n, o) : E.none())), Zd(Gd(rs), xg), Zd(Gd(as), xg)])
      , Eg = v([Zd(Gd(as), _m)]);
    var kg = pm(_g, Sn.init, Cg, Eg, (()=>E.some(wg)));
    const Tg = [Va("onSpace"), Va("onEnter"), Va("onShiftEnter"), Va("onLeft"), Va("onRight"), Va("onTab"), Va("onShiftTab"), Va("onUp"), Va("onDown"), Va("onEscape"), wn("stopSpaceKeyup", !1), bn("focusIn")];
    var Ag = pm(Tg, Sn.init, ((e,t,n)=>[Zd(Gd(as), n.onSpace), Zd(Kd([Jd, Gd(rs)]), n.onEnter), Zd(Kd([Yd, Gd(rs)]), n.onShiftEnter), Zd(Kd([Yd, Gd(os)]), n.onShiftTab), Zd(Kd([Jd, Gd(os)]), n.onTab), Zd(Gd(cs), n.onUp), Zd(Gd(us), n.onDown), Zd(Gd(is), n.onLeft), Zd(Gd(ls), n.onRight), Zd(Gd(as), n.onSpace)]), ((e,t,n)=>[...n.stopSpaceKeyup ? [Zd(Gd(as), _m)] : [], Zd(Gd(ss), n.onEscape)]), (e=>e.focusIn));
    const Mg = vm.schema()
      , Rg = fm.schema()
      , Ng = rg.schema()
      , Fg = Ym.schema()
      , Bg = yg.schema()
      , Dg = Om.schema()
      , Hg = kg.schema()
      , Pg = Ag.schema()
      , Ig = (e=>{
        const t = ln("Creating behaviour: " + e.name, _r, e);
        return ((e,t,n,o,r,s)=>{
            const a = e
              , i = _n(t, [yn("config", e)]);
            return vr(a, i, t, n, o, r, s)
        }
        )(dn(t.branchKey, t.branches), t.name, t.active, t.apis, t.extra, t.state)
    }
    )({
        branchKey: "mode",
        branches: Object.freeze({
            __proto__: null,
            acyclic: Mg,
            cyclic: Rg,
            flow: Ng,
            flatgrid: Fg,
            matrix: Bg,
            execution: Dg,
            menu: Hg,
            special: Pg
        }),
        name: "keying",
        active: {
            events: (e,t)=>e.handler.toEvents(e, t)
        },
        apis: {
            focusIn: (e,t,n)=>{
                t.sendFocusIn(t).fold((()=>{
                    e.getSystem().triggerFocus(e.element, e.element)
                }
                ), (o=>{
                    o(e, t, n)
                }
                ))
            }
            ,
            setGridSize: (e,t,n,o,r)=>{
                (e=>qe(e, "setGridSize"))(n) ? n.setGridSize(o, r) : console.error("Layout does not support setGridSize")
            }
        },
        state: Cm
    })
      , Vg = Ei({
        name: "Button",
        factory: e=>{
            const t = Ud(e.action)
              , n = e.dom.tag
              , o = t=>ze(e.dom, "attributes").bind((e=>ze(e, t)));
            return {
                uid: e.uid,
                dom: e.dom,
                components: e.components,
                events: t,
                behaviours: Ma(e.buttonBehaviours, [id.config({}), Ig.config({
                    mode: "execution",
                    useSpace: !0,
                    useEnter: !0
                })]),
                domModification: {
                    attributes: "button" === n ? {
                        type: o("type").getOr("button"),
                        ...o("role").map((e=>({
                            role: e
                        }))).getOr({})
                    } : {
                        role: o("role").getOr("button")
                    }
                },
                eventOrder: e.eventOrder
            }
        }
        ,
        configFields: [wn("uid", void 0), pn("dom"), wn("components", []), Aa("buttonBehaviours", [id, Ig]), bn("action"), bn("role"), wn("eventOrder", {})]
    })
      , Wg = ["input", "button", "textarea", "select"]
      , Lg = (e,t,n)=>{
        (t.disabled() ? Gg : Kg)(e, t)
    }
      , Ug = (e,t)=>!0 === t.useNative && W(Wg, ce(e.element))
      , jg = e=>{
        Fr(e.element, "disabled", "disabled")
    }
      , zg = e=>{
        Ir(e.element, "disabled")
    }
      , $g = e=>{
        Fr(e.element, "aria-disabled", "true")
    }
      , qg = e=>{
        Fr(e.element, "aria-disabled", "false")
    }
      , Gg = (e,t,n)=>{
        t.disableClass.each((t=>{
            Qs(e.element, t)
        }
        )),
        (Ug(e, t) ? jg : $g)(e),
        t.onDisabled(e)
    }
      , Kg = (e,t,n)=>{
        t.disableClass.each((t=>{
            Js(e.element, t)
        }
        )),
        (Ug(e, t) ? zg : qg)(e),
        t.onEnabled(e)
    }
      , Yg = (e,t)=>Ug(e, t) ? (e=>Pr(e.element, "disabled"))(e) : (e=>"true" === Dr(e.element, "aria-disabled"))(e);
    var Qg = Object.freeze({
        __proto__: null,
        enable: Kg,
        disable: Gg,
        isDisabled: Yg,
        onLoad: Lg,
        set: (e,t,n,o)=>{
            (o ? Gg : Kg)(e, t)
        }
    })
      , Jg = Object.freeze({
        __proto__: null,
        exhibit: (e,t)=>gr({
            classes: t.disabled() ? t.disableClass.toArray() : []
        }),
        events: (e,t)=>Jo([Xo(Fo(), ((t,n)=>Yg(t, e))), pr(e, t, Lg)])
    })
      , Xg = [((e,t)=>On("disabled", t, nn))(0, w), wn("useNative", !0), bn("disableClass"), Ia("onDisabled"), Ia("onEnabled")];
    const Zg = yr({
        fields: Xg,
        name: "disabling",
        active: Jg,
        apis: Qg
    });
    var ep = Object.freeze({
        __proto__: null,
        events: e=>Jo([Zo(No(), ((t,n)=>{
            const o = e.channels
              , r = Be(o)
              , s = n
              , a = ((e,t)=>t.universal ? e : z(e, (e=>W(t.channels, e))))(r, s);
            j(a, (e=>{
                const n = o[e]
                  , r = n.schema
                  , a = ln("channel[" + e + "] data\nReceiver: " + Wr(t.element), r, s.data);
                n.onReceive(t, a)
            }
            ))
        }
        ))])
    })
      , tp = [hn("channels", sn(ot.value, Kt([Wa("onReceive"), wn("schema", Xt())])))];
    const np = yr({
        fields: tp,
        name: "receiving",
        active: ep
    })
      , op = Kt([vn("readonly"), vn("saving")])
      , rp = e=>e.readonly || e.saving
      , sp = e=>e.readonly
      , ap = e=>{
        var t;
        return Zg.config(null !== (t = e.disablingConfig) && void 0 !== t ? t : {})
    }
      , ip = e=>({
        [wt]: {
            schema: op,
            onReceive: (t,n)=>{
                Zg.set(t, e(n))
            }
        }
    })
      , cp = e=>{
        var t;
        const n = null !== (t = e.disableWhileSaving) && void 0 !== t && t;
        return [ap(e), (o = n ? rp : sp,
        np.config({
            channels: ip(o)
        }))];
        var o
    }
      , lp = e=>t=>{
        var n;
        const o = null !== (n = t.disableWhileSaving) && void 0 !== n && n
          , r = t.eventName.map((e=>({
            action: t=>{
                qo(t, e)
            }
        }))).getOr({});
        return Vg.sketch({
            dom: {
                tag: "button",
                classes: e,
                styles: void 0 !== t.styles ? t.styles : {}
            },
            components: [xa(t.text)],
            ...r,
            buttonBehaviours: fr([Od.config({}), ...cp({
                disableWhileSaving: o
            })])
        })
    }
      , up = lp(Qu.button)
      , dp = lp(Qu.secondaryButton)
      , mp = "tc-save-edit"
      , gp = "tc-cancel-edit"
      , pp = ys("tc-patch-comment-state-event")
      , hp = ys("tc-purge-comment-state-event")
      , vp = ys("tc-force-patch-state-event");
    var fp, bp;
    !function(e) {
        e.None = "Prop_None",
        e.Collapsed = "Prop_Collapsed",
        e.Expanded = "Prop_Expanded",
        e.CollapsedOrNone = "Prop_CollapsedOrNone",
        e.ExpandOrNone = "Prop_ExpandOrNone",
        e.Edit = "Prop_Edit"
    }(fp || (fp = {})),
    function(e) {
        e[e.Before = 0] = "Before",
        e[e.QueryingDelete = 1] = "QueryingDelete",
        e[e.QueryingResolve = 2] = "QueryingResolve",
        e[e.PostDelete = 3] = "PostDelete",
        e[e.PostResolve = 4] = "PostResolve"
    }(bp || (bp = {}));
    const yp = e=>U(e.conversation, (e=>e.props))
      , _p = (e,t)=>({
        ...e,
        targetUid: t
    })
      , xp = (e,t)=>({
        ...e,
        queue: e.queue.concat(t)
    })
      , wp = ()=>({
        targetUid: E.none(),
        conversation: [],
        queue: []
    })
      , Op = (e,t)=>n=>{
        const o = t(n);
        Go(n, pp, {
            uid: e,
            patch: o
        })
    }
      , Sp = (e,t)=>n=>{
        const o = t(n);
        Go(n, pp, {
            uid: e,
            patch: o
        }),
        qo(n, vp)
    }
      , Cp = e=>{
        qo(e, vp)
    }
      , Ep = (e,t)=>{
        ra(e.element, "visibility", "hidden"),
        Wd.set(e, !1);
        const n = e.element.dom.clientHeight;
        return Wd.set(e, !0),
        ua(e.element, "visibility"),
        e.element.dom.scrollHeight > n + 1 ? t : fp.None
    }
      , kp = e=>{
        Wd.off(e),
        Qs(e.element, Yu.bodyHasGradient)
    }
      , Tp = e=>{
        Wd.on(e),
        Js(e.element, Yu.bodyHasGradient)
    }
      , Ap = e=>xe(e.element)
      , Mp = e=>{
        Js(e.element, Yu.bodyHasGradient),
        Wd.set(e, !1),
        Ir(e.element, "aria-expanded")
    }
      , Rp = e=>{
        Ap(e).each((e=>{
            Ir(e, "readonly"),
            Qs(e, Yu.editingTextarea),
            Sr(e);
            const t = e.dom
              , n = ma(e).length;
            t.setSelectionRange(n, n)
        }
        )),
        e.element.dom.scrollTop = 0
    }
      , Np = e=>{
        const t = e=>t=>{
            j(e, (e=>e(t)))
        }
          , n = t=>{
            Ap(t).each((n=>{
                const o = la(n, "width");
                ra(n, "width", Xi(n) + "px"),
                ua(n, "height"),
                _d.setValue(t, e.props.content),
                t.getSystem().triggerEvent(wo(), n, {}),
                aa(n, {
                    width: o
                })
            }
            ))
        }
          , o = t=>{
            return n = t,
            o = e.memCommands,
            (e=>{
                Ap(e).each((e=>{
                    Fr(e, "readonly", "true"),
                    Js(e, Yu.editingTextarea)
                }
                ))
            }
            )(n),
            void o.getOpt(n).each((e=>{
                Su.remove(n, e)
            }
            ));
            var n, o
        }
          , r = {
            [fp.None]: t([o, n, Mp]),
            [fp.Expanded]: t([o, n, Tp]),
            [fp.Collapsed]: t([o, n, kp]),
            [fp.ExpandOrNone]: t([o, n, t=>{
                Qs(t.element, Yu.bodyNotAnimating);
                const n = Ep(t, fp.Expanded);
                Op(e.props.uid, (()=>({
                    mode: n
                })))(t)
            }
            ]),
            [fp.CollapsedOrNone]: t([o, n, t=>{
                Qs(t.element, Yu.bodyNotAnimating);
                const n = Ep(t, fp.Collapsed);
                n === fp.Collapsed && (Qs(t.element, Yu.bodyHasGradient),
                Wd.off(t)),
                da(t.element),
                Op(e.props.uid, (()=>({
                    mode: n
                })))(t)
            }
            ]),
            [fp.Edit]: t([t=>{
                return n = t,
                o = e.memCommands,
                Wd.on(n),
                Js(n.element, Yu.bodyHasGradient),
                void ((e,t)=>{
                    Rp(e),
                    t.getOpt(e).fold((()=>{
                        Su.append(e, t.asSpec())
                    }
                    ), p)
                }
                )(n, o);
                var n, o
            }
            , n])
        };
        return ze(r, e.props.mode)
    }
      , Fp = ys("tc-focus-outer-comment")
      , Bp = ys("tc-start-delete-comment")
      , Dp = ys("tc-start-delete-conversation")
      , Hp = ys("tc-start-resolve-conversation")
      , Pp = ys("tc-commit-delete")
      , Ip = ys("tc-commit-resolve")
      , Vp = ys("tc-start-edit-comment")
      , Wp = ys("tc-commit-edit-comment");
    ys("tc-cancel-edit-comment"),
    ys("tc-long-content"),
    ys("tc-short-content");
    const Lp = ys("tc-toggle-comment")
      , Up = v([bn("data"), wn("inputAttributes", {}), wn("inputStyles", {}), wn("tag", "input"), wn("inputClasses", []), Ia("onSetValue"), wn("styles", {}), wn("eventOrder", {}), ka("inputBehaviours", [_d, id]), wn("selectOnFocus", !0)])
      , jp = e=>fr([id.config({
        onFocus: e.selectOnFocus ? e=>{
            const t = e.element
              , n = ma(t);
            t.dom.setSelectionRange(0, n.length)
        }
        : p
    })])
      , zp = e=>({
        ...jp(e),
        ...Ta(e.inputBehaviours, [_d.config({
            store: {
                mode: "manual",
                ...e.data.map((e=>({
                    initialValue: e
                }))).getOr({}),
                getValue: e=>ma(e.element),
                setValue: (e,t)=>{
                    ma(e.element) !== t && ga(e.element, t)
                }
            },
            onSetValue: e.onSetValue
        })])
    })
      , $p = e=>({
        tag: e.tag,
        attributes: {
            type: "text",
            ...e.inputAttributes
        },
        styles: e.inputStyles,
        classes: e.inputClasses
    })
      , qp = Ei({
        name: "Input",
        configFields: Up(),
        factory: (e,t)=>({
            uid: e.uid,
            dom: $p(e),
            components: [],
            behaviours: zp(e),
            eventOrder: e.eventOrder
        })
    })
      , Gp = "data-alloy-widget-tabstop"
      , Kp = e=>Ig.config({
        mode: "cyclic",
        onEscape: e.onEscape,
        useTabstopAt: e=>"textarea" !== ce(e) || "true" !== Dr(e, "readonly")
    })
      , Yp = e=>Ig.config({
        mode: "special",
        onEnter: t=>(qo(t, e.enterEvent),
        E.some(!0)),
        onShiftEnter: (e,t)=>(t.cut(),
        E.none()),
        onSpace: (e,t)=>(t.cut(),
        E.none())
    })
      , Qp = e=>Ig.config({
        mode: "cyclic",
        selector: `[${Gp}="true"]`,
        focusInside: gm.OnEnterOrSpaceMode,
        onEscape: (t,n)=>Mn(t, n) ? E.none() : (qo(t, e.escapeEvent),
        E.some(!0))
    })
      , Jp = e=>Ig.config({
        mode: "flow",
        allowVertical: !0,
        selector: e.selector
    })
      , Xp = {
        "data-gramm_editor": "false",
        rows: "2"
    }
      , Zp = {
        "white-space": "pre-wrap"
    }
      , eh = e=>{
        const t = e.element.dom;
        ua(e.element, "height"),
        da(e.element);
        const n = t.clientHeight
          , o = t.scrollHeight;
        if (o > n) {
            const t = Yi(e.element) - n;
            ra(e.element, "height", o + t + "px")
        }
    }
      , th = e=>{
        const t = Yr();
        return qp.sketch({
            tag: "textarea",
            inputAttributes: {
                ...Xp,
                readonly: "true"
            },
            inputClasses: Qu.editTextarea,
            inputStyles: {
                ...Zp,
                "overflow-y": "hidden",
                border: "none !important"
            },
            data: e,
            inputBehaviours: fr([wr("textarea-events", [rr((e=>{
                t.set(Xi(e.element)),
                eh(e)
            }
            )), Zo(wo(), eh)]), np.config({
                channels: {
                    ...ip(rp),
                    [Ot]: {
                        onReceive: e=>{
                            const n = Xi(e.element);
                            t.on((t=>{
                                t !== n && ua(e.element, "height")
                            }
                            )),
                            t.set(n),
                            eh(e)
                        }
                    }
                }
            }), Yp({
                enterEvent: Wp
            }), Od.config({}), ap({})])
        })
    }
      , nh = yt
      , oh = {
        [nh.LessThanMinute]: [Mu.tc_date_less_than_a_minute_ago, Mu.tc_date_less_than_a_minute_ago],
        [nh.Minute]: [Mu.tc_date_1_minute_ago, Mu.tc_date_x_minutes_ago],
        [nh.Hour]: [Mu.tc_date_1_hour_ago, Mu.tc_date_x_hours_ago],
        [nh.Day]: [Mu.tc_date_1_day_ago, Mu.tc_date_x_days_ago],
        [nh.Week]: [Mu.tc_date_1_week_ago, Mu.tc_date_x_weeks_ago],
        [nh.Month]: [Mu.tc_date_1_month_ago, Mu.tc_date_x_months_ago],
        [nh.Year]: [Mu.tc_date_1_year_ago, Mu.tc_date_x_years_ago]
    }
      , rh = (e,t)=>{
        const n = oh[e.interval]
          , o = 1 === e.intervalUnits ? n[0] : n[1];
        return t.translate([o, e.intervalUnits])
    }
      , sh = {
        editCommentEvent: ys("tc-conversation-edit-comment"),
        deleteCommentEvent: ys("tc-conversation-delete-comment"),
        deleteConversationEvent: ys("tc-conversation-delete-all"),
        resolveConversationEvent: ys("tc-conversation-resolve"),
        createCommentEvent: ys("tc-conversation-create")
    }
      , ah = "aria-controls"
      , ih = (e,t)=>ml(t, (t=>ie(t, e.element)), w) || ((e,t)=>(e=>Xr(e, (e=>{
        if (!ue(e))
            return !1;
        const t = Dr(e, "id");
        return void 0 !== t && t.indexOf(ah) > -1
    }
    )).bind((e=>{
        const t = Dr(e, "id")
          , n = Ce(e);
        return es(n, `[${ah}="${t}"]`)
    }
    )))(t).exists((t=>ih(e, t))))(e, t);
    var ch = Object.freeze({
        __proto__: null,
        getCoupled: (e,t,n,o)=>n.getOrCreate(e, t, o)
    })
      , lh = [hn("others", sn(ot.value, Xt()))]
      , uh = Object.freeze({
        __proto__: null,
        init: ()=>{
            const e = {}
              , t = v({});
            return Cn({
                readState: t,
                getOrCreate: (t,n,o)=>{
                    const r = Be(n.others);
                    if (r)
                        return ze(e, o).getOrThunk((()=>{
                            const r = ze(n.others, o).getOrDie("No information found for coupled component: " + o)(t)
                              , s = t.getSystem().build(r);
                            return e[o] = s,
                            s
                        }
                        ));
                    throw new Error("Cannot find coupled component: " + o + ". Known coupled components: " + JSON.stringify(r, null, 2))
                }
            })
        }
    });
    const dh = yr({
        fields: lh,
        name: "coupling",
        apis: ch,
        state: uh
    })
      , mh = (e,t,n,o)=>{
        n.get().each((t=>{
            Ii(e)
        }
        ));
        const r = t.getAttachPoint(e);
        Bi(r, e);
        const s = e.getSystem().build(o);
        return Bi(e, s),
        n.set(s),
        s
    }
      , gh = (e,t,n,o)=>{
        const r = mh(e, t, n, o);
        return t.onOpen(e, r),
        r
    }
      , ph = (e,t,n)=>{
        n.get().each((o=>{
            Ii(e),
            Pi(e),
            t.onClose(e, o),
            n.clear()
        }
        ))
    }
      , hh = (e,t,n)=>n.isOpen()
      , vh = (e,t,n)=>{
        const o = t.getAttachPoint(e);
        ra(e.element, "position", hu.getMode(o)),
        ((e,t,n,o)=>{
            la(e.element, t).fold((()=>{
                Ir(e.element, n)
            }
            ), (t=>{
                Fr(e.element, n, t)
            }
            )),
            ra(e.element, t, "hidden")
        }
        )(e, "visibility", t.cloakVisibilityAttr)
    }
      , fh = (e,t,n)=>{
        (e=>L(["top", "left", "right", "bottom"], (t=>la(e, t).isSome())))(e.element) || ua(e.element, "position"),
        ((e,t,n)=>{
            Hr(e.element, n).fold((()=>ua(e.element, t)), (n=>ra(e.element, t, n)))
        }
        )(e, "visibility", t.cloakVisibilityAttr)
    }
    ;
    var bh = Object.freeze({
        __proto__: null,
        cloak: vh,
        decloak: fh,
        open: gh,
        openWhileCloaked: (e,t,n,o,r)=>{
            vh(e, t),
            gh(e, t, n, o),
            r(),
            fh(e, t)
        }
        ,
        close: ph,
        isOpen: hh,
        isPartOf: (e,t,n,o)=>hh(0, 0, n) && n.get().exists((n=>t.isPartOf(e, n, o))),
        getState: (e,t,n)=>n.get(),
        setContent: (e,t,n,o)=>n.get().map((()=>mh(e, t, n, o)))
    })
      , yh = Object.freeze({
        __proto__: null,
        events: (e,t)=>Jo([Zo(Po(), ((n,o)=>{
            ph(n, e, t)
        }
        ))])
    })
      , _h = [Ia("onOpen"), Ia("onClose"), pn("isPartOf"), pn("getAttachPoint"), wn("cloakVisibilityAttr", "data-precloak-visibility")]
      , xh = Object.freeze({
        __proto__: null,
        init: ()=>{
            const e = Yr()
              , t = v("not-implemented");
            return Cn({
                readState: t,
                isOpen: e.isSet,
                clear: e.clear,
                set: e.set,
                get: e.get
            })
        }
    });
    const wh = yr({
        fields: _h,
        name: "sandboxing",
        active: yh,
        apis: bh,
        state: xh
    })
      , Oh = "alloy.item-hover"
      , Sh = "alloy.item-focus"
      , Ch = "alloy.item-toggled"
      , Eh = e=>{
        (Er(e.element).isNone() || id.isFocused(e)) && (id.isFocused(e) || id.focus(e),
        Go(e, Oh, {
            item: e
        }))
    }
      , kh = e=>{
        Go(e, Sh, {
            item: e
        })
    }
      , Th = v(Oh)
      , Ah = v(Sh)
      , Mh = v(Ch)
      , Rh = e=>e.toggling.map((e=>e.exclusive ? "menuitemradio" : "menuitemcheckbox")).getOr("menuitem")
      , Nh = [pn("data"), pn("components"), pn("dom"), wn("hasSubmenu", !1), bn("toggling"), Aa("itemBehaviours", [Wd, id, Ig, _d]), wn("ignoreFocus", !1), wn("domModification", {}), Ua("builder", (e=>({
        dom: e.dom,
        domModification: {
            ...e.domModification,
            attributes: {
                role: Rh(e),
                ...e.domModification.attributes,
                "aria-haspopup": e.hasSubmenu,
                ...e.hasSubmenu ? {
                    "aria-expanded": !1
                } : {}
            }
        },
        behaviours: Ma(e.itemBehaviours, [e.toggling.fold(Wd.revoke, (e=>Wd.config((e=>({
            aria: {
                mode: "checked"
            },
            ...Le(e, ((e,t)=>"exclusive" !== t)),
            onToggled: (t,n)=>{
                m(e.onToggled) && e.onToggled(t, n),
                ((e,t)=>{
                    Go(e, Ch, {
                        item: e,
                        state: t
                    })
                }
                )(t, n)
            }
        }))(e)))), id.config({
            ignore: e.ignoreFocus,
            stopMousedown: e.ignoreFocus,
            onFocus: e=>{
                kh(e)
            }
        }), Ig.config({
            mode: "execution"
        }), _d.config({
            store: {
                mode: "memory",
                initialValue: e.data
            }
        }), wr("item-type-events", [...Ld(), Zo(yo(), Eh), Zo(Bo(), id.focus)])]),
        components: e.components,
        eventOrder: e.eventOrder
    }))), wn("eventOrder", {})]
      , Fh = [pn("dom"), pn("components"), Ua("builder", (e=>({
        dom: e.dom,
        components: e.components,
        events: Jo([nr(Bo())])
    })))]
      , Bh = v("item-widget")
      , Dh = v([mi({
        name: "widget",
        overrides: e=>({
            behaviours: fr([_d.config({
                store: {
                    mode: "manual",
                    getValue: t=>e.data,
                    setValue: p
                }
            })])
        })
    })])
      , Hh = [pn("uid"), pn("data"), pn("components"), pn("dom"), wn("autofocus", !1), wn("ignoreFocus", !1), Aa("widgetBehaviours", [_d, id, Ig]), wn("domModification", {}), xi(Dh()), Ua("builder", (e=>{
        const t = yi(Bh(), e, Dh())
          , n = _i(Bh(), e, t.internals())
          , o = t=>((e,t,n)=>{
            const o = t.partUids.widget;
            return e.getSystem().getByUid(o).toOptional()
        }
        )(t, e).map((e=>(Ig.focusIn(e),
        e)))
          , r = (t,n)=>bm(n.event.target) ? E.none() : e.autofocus ? (n.setSource(t.element),
        E.none()) : E.none();
        return {
            dom: e.dom,
            components: n,
            domModification: e.domModification,
            events: Jo([ir(((e,t)=>{
                o(e).each((e=>{
                    t.stop()
                }
                ))
            }
            )), Zo(yo(), Eh), Zo(Bo(), ((t,n)=>{
                e.autofocus ? o(t) : id.focus(t)
            }
            ))]),
            behaviours: Ma(e.widgetBehaviours, [_d.config({
                store: {
                    mode: "memory",
                    initialValue: e.data
                }
            }), id.config({
                ignore: e.ignoreFocus,
                onFocus: e=>{
                    kh(e)
                }
            }), Ig.config({
                mode: "special",
                focusIn: e.autofocus ? e=>{
                    o(e)
                }
                : xr(),
                onLeft: r,
                onRight: r,
                onEscape: (t,n)=>id.isFocused(t) || e.autofocus ? e.autofocus ? (n.setSource(t.element),
                E.none()) : E.none() : (id.focus(t),
                E.some(!0))
            })])
        }
    }
    ))]
      , Ph = dn("type", {
        widget: Hh,
        item: Nh,
        separator: Fh
    })
      , Ih = v([hi({
        factory: {
            sketch: e=>{
                const t = ln("menu.spec item", Ph, e);
                return t.builder(t)
            }
        },
        name: "items",
        unit: "item",
        defaults: (e,t)=>$e(t, "uid") ? t : {
            ...t,
            uid: Es("item")
        },
        overrides: (e,t)=>({
            type: t.type,
            ignoreFocus: e.fakeFocus,
            domModification: {
                classes: [e.markers.item]
            }
        })
    })])
      , Vh = v([pn("value"), pn("items"), pn("dom"), pn("components"), wn("eventOrder", {}), ka("menuBehaviours", [lm, _d, nd, Ig]), On("movement", {
        mode: "menu",
        moveOnTab: !0
    }, dn("mode", {
        grid: [za(), Ua("config", ((e,t)=>({
            mode: "flatgrid",
            selector: "." + e.markers.item,
            initSize: {
                numColumns: t.initSize.numColumns,
                numRows: t.initSize.numRows
            },
            focusManager: e.focusManager
        })))],
        matrix: [Ua("config", ((e,t)=>({
            mode: "matrix",
            selectors: {
                row: t.rowSelector,
                cell: "." + e.markers.item
            },
            focusManager: e.focusManager
        }))), pn("rowSelector")],
        menu: [wn("moveOnTab", !0), Ua("config", ((e,t)=>({
            mode: "menu",
            selector: "." + e.markers.item,
            moveOnTab: t.moveOnTab,
            focusManager: e.focusManager
        })))]
    })), hn("markers", Ba()), wn("fakeFocus", !1), wn("focusManager", dm()), Ia("onHighlight")])
      , Wh = v("alloy.menu-focus")
      , Lh = ki({
        name: "Menu",
        configFields: Vh(),
        partFields: Ih(),
        factory: (e,t,n,o)=>({
            uid: e.uid,
            dom: e.dom,
            markers: e.markers,
            behaviours: Ta(e.menuBehaviours, [lm.config({
                highlightClass: e.markers.selectedItem,
                itemClass: e.markers.item,
                onHighlight: e.onHighlight
            }), _d.config({
                store: {
                    mode: "memory",
                    initialValue: e.value
                }
            }), nd.config({
                find: E.some
            }), Ig.config(e.movement.config(e, e.movement))]),
            events: Jo([Zo(Ah(), ((e,t)=>{
                const n = t.event;
                e.getSystem().getByDom(n.target).each((n=>{
                    lm.highlight(e, n),
                    t.stop(),
                    Go(e, Wh(), {
                        menu: e,
                        item: n
                    })
                }
                ))
            }
            )), Zo(Th(), ((e,t)=>{
                const n = t.event.item;
                lm.highlight(e, n)
            }
            )), Zo(Mh(), ((e,t)=>{
                const {item: n, state: o} = t.event;
                o && "menuitemradio" === Dr(n.element, "role") && ((e,t)=>{
                    const n = lt(e.element, '[role="menuitemradio"][aria-checked="true"]');
                    j(n, (n=>{
                        ie(n, t.element) || e.getSystem().getByDom(n).each((e=>{
                            Wd.off(e)
                        }
                        ))
                    }
                    ))
                }
                )(e, n)
            }
            ))]),
            components: t,
            eventOrder: e.eventOrder,
            domModification: {
                attributes: {
                    role: "menu"
                }
            }
        })
    })
      , Uh = (e,t,n,o)=>ze(n, o).bind((o=>ze(e, o).bind((o=>{
        const r = Uh(e, t, n, o);
        return E.some([o].concat(r))
    }
    )))).getOr([])
      , jh = e=>"prepared" === e.type ? E.some(e.menu) : E.none()
      , zh = ()=>{
        const e = mt({})
          , t = mt({})
          , n = mt({})
          , o = Yr()
          , r = mt({})
          , s = e=>a(e).bind(jh)
          , a = e=>ze(t.get(), e)
          , i = t=>ze(e.get(), t);
        return {
            setMenuBuilt: (e,n)=>{
                t.set({
                    ...t.get(),
                    [e]: {
                        type: "prepared",
                        menu: n
                    }
                })
            }
            ,
            setContents: (s,a,i,c)=>{
                o.set(s),
                e.set(i),
                t.set(a),
                r.set(c);
                const l = ((e,t)=>{
                    const n = {};
                    He(e, ((e,t)=>{
                        j(e, (e=>{
                            n[e] = t
                        }
                        ))
                    }
                    ));
                    const o = t
                      , r = Ie(t, ((e,t)=>({
                        k: e,
                        v: t
                    })))
                      , s = Pe(r, ((e,t)=>[t].concat(Uh(n, o, r, t))));
                    return Pe(n, (e=>ze(s, e).getOr([e])))
                }
                )(c, i);
                n.set(l)
            }
            ,
            expand: t=>ze(e.get(), t).map((e=>{
                const o = ze(n.get(), t).getOr([]);
                return [e].concat(o)
            }
            )),
            refresh: e=>ze(n.get(), e),
            collapse: e=>ze(n.get(), e).bind((e=>e.length > 1 ? E.some(e.slice(1)) : E.none())),
            lookupMenu: a,
            lookupItem: i,
            otherMenus: e=>{
                const t = r.get();
                return Z(Be(t), e)
            }
            ,
            getPrimary: ()=>o.get().bind(s),
            getMenus: ()=>t.get(),
            clear: ()=>{
                e.set({}),
                t.set({}),
                n.set({}),
                o.clear()
            }
            ,
            isClear: ()=>o.get().isNone(),
            getTriggeringPath: (t,r)=>{
                const a = z(i(t).toArray(), (e=>s(e).isSome()));
                return ze(n.get(), t).bind((t=>{
                    const n = X(a.concat(t));
                    return (e=>{
                        const t = [];
                        for (let n = 0; n < e.length; n++) {
                            const o = e[n];
                            if (!o.isSome())
                                return E.none();
                            t.push(o.getOrDie())
                        }
                        return E.some(t)
                    }
                    )(Q(n, ((t,a)=>((t,n,o)=>s(t).bind((r=>(t=>je(e.get(), ((e,n)=>e === t)))(t).bind((e=>n(e).map((e=>({
                        triggeredMenu: r,
                        triggeringItem: e,
                        triggeringPath: o
                    }))))))))(t, r, n.slice(0, a + 1)).fold((()=>cr(o.get(), t) ? [] : [E.none()]), (e=>[E.some(e)])))))
                }
                ))
            }
        }
    }
      , $h = jh
      , qh = v("collapse-item")
      , Gh = Ei({
        name: "TieredMenu",
        configFields: [La("onExecute"), La("onEscape"), Wa("onOpenMenu"), Wa("onOpenSubmenu"), Ia("onRepositionMenu"), Ia("onCollapseMenu"), wn("highlightImmediately", !0), fn("data", [pn("primary"), pn("menus"), pn("expansions")]), wn("fakeFocus", !1), Ia("onHighlight"), Ia("onHover"), Ha(), pn("dom"), wn("navigateOnHover", !0), wn("stayInDom", !1), ka("tmenuBehaviours", [Ig, lm, nd, Su]), wn("eventOrder", {})],
        apis: {
            collapseMenu: (e,t)=>{
                e.collapseMenu(t)
            }
            ,
            highlightPrimary: (e,t)=>{
                e.highlightPrimary(t)
            }
            ,
            repositionMenus: (e,t)=>{
                e.repositionMenus(t)
            }
        },
        factory: (e,t)=>{
            const n = Yr()
              , o = zh()
              , r = e=>_d.getValue(e).value
              , s = t=>Pe(e.data.menus, ((e,t)=>Q(e.items, (e=>"separator" === e.type ? [] : [e.data.value]))))
              , a = (e,t)=>{
                lm.highlight(e, t),
                lm.getHighlighted(t).orThunk((()=>lm.getFirst(t))).each((t=>{
                    Yo(e, t.element, Bo())
                }
                ))
            }
              , i = (e,t)=>lr(U(t, (t=>e.lookupMenu(t).bind((e=>"prepared" === e.type ? E.some(e.menu) : E.none())))))
              , c = (t,n,o)=>{
                const r = i(n, n.otherMenus(o));
                j(r, (n=>{
                    ea(n.element, [e.markers.backgroundMenu]),
                    e.stayInDom || Su.remove(t, n)
                }
                ))
            }
              , l = (t,o)=>{
                const s = (t=>n.get().getOrThunk((()=>{
                    const o = {}
                      , s = lt(t.element, `.${e.markers.item}`)
                      , a = z(s, (e=>"true" === Dr(e, "aria-haspopup")));
                    return j(a, (e=>{
                        t.getSystem().getByDom(e).each((e=>{
                            const t = r(e);
                            o[t] = e
                        }
                        ))
                    }
                    )),
                    n.set(o),
                    o
                }
                )))(t);
                He(s, ((e,t)=>{
                    const n = W(o, t);
                    Fr(e.element, "aria-expanded", n)
                }
                ))
            }
              , u = (t,n,o)=>E.from(o[0]).bind((r=>n.lookupMenu(r).bind((r=>{
                if ("notbuilt" === r.type)
                    return E.none();
                {
                    const s = r.menu
                      , l = i(n, o.slice(1));
                    return j(l, (t=>{
                        Qs(t.element, e.markers.backgroundMenu)
                    }
                    )),
                    ct(s.element) || Su.append(t, Ea(s)),
                    ea(s.element, [e.markers.backgroundMenu]),
                    a(t, s),
                    c(t, n, o),
                    E.some(s)
                }
            }
            ))));
            let d;
            !function(e) {
                e[e.HighlightSubmenu = 0] = "HighlightSubmenu",
                e[e.HighlightParent = 1] = "HighlightParent"
            }(d || (d = {}));
            const m = (t,n,s=d.HighlightSubmenu)=>{
                if (n.hasConfigured(Zg) && Zg.isDisabled(n))
                    return E.some(n);
                {
                    const a = r(n);
                    return o.expand(a).bind((r=>(l(t, r),
                    E.from(r[0]).bind((a=>o.lookupMenu(a).bind((i=>{
                        const c = ((e,t,n)=>{
                            if ("notbuilt" === n.type) {
                                const r = e.getSystem().build(n.nbMenu());
                                return o.setMenuBuilt(t, r),
                                r
                            }
                            return n.menu
                        }
                        )(t, a, i);
                        return ct(c.element) || Su.append(t, Ea(c)),
                        e.onOpenSubmenu(t, n, c, X(r)),
                        s === d.HighlightSubmenu ? (lm.highlightFirst(c),
                        u(t, o, r)) : (lm.dehighlightAll(c),
                        E.some(n))
                    }
                    )))))))
                }
            }
              , g = (t,n)=>{
                const s = r(n);
                return o.collapse(s).bind((r=>(l(t, r),
                u(t, o, r).map((o=>(e.onCollapseMenu(t, n, o),
                o))))))
            }
              , h = t=>(n,o)=>ts(o.getSource(), "." + e.markers.item).bind((e=>n.getSystem().getByDom(e).toOptional().bind((e=>t(n, e).map(O)))))
              , v = Jo([Zo(Wh(), ((e,t)=>{
                const n = t.event.item;
                o.lookupItem(r(n)).each((()=>{
                    const n = t.event.menu;
                    lm.highlight(e, n);
                    const s = r(t.event.item);
                    o.refresh(s).each((t=>c(e, o, t)))
                }
                ))
            }
            )), ir(((t,n)=>{
                const o = n.event.target;
                t.getSystem().getByDom(o).each((n=>{
                    0 === r(n).indexOf("collapse-item") && g(t, n),
                    m(t, n, d.HighlightSubmenu).fold((()=>{
                        e.onExecute(t, n)
                    }
                    ), p)
                }
                ))
            }
            )), rr(((t,n)=>{
                (t=>{
                    const n = ((t,n,o)=>Pe(o, ((o,r)=>{
                        const s = ()=>Lh.sketch({
                            ...o,
                            value: r,
                            markers: e.markers,
                            fakeFocus: e.fakeFocus,
                            onHighlight: e.onHighlight,
                            focusManager: e.fakeFocus ? mm() : dm()
                        });
                        return r === n ? {
                            type: "prepared",
                            menu: t.getSystem().build(s())
                        } : {
                            type: "notbuilt",
                            nbMenu: s
                        }
                    }
                    )))(t, e.data.primary, e.data.menus)
                      , r = s();
                    return o.setContents(e.data.primary, n, e.data.expansions, r),
                    o.getPrimary()
                }
                )(t).each((n=>{
                    Su.append(t, Ea(n)),
                    e.onOpenMenu(t, n),
                    e.highlightImmediately && a(t, n)
                }
                ))
            }
            ))].concat(e.navigateOnHover ? [Zo(Th(), ((t,n)=>{
                const s = n.event.item;
                ((e,t)=>{
                    const n = r(t);
                    o.refresh(n).bind((t=>(l(e, t),
                    u(e, o, t))))
                }
                )(t, s),
                m(t, s, d.HighlightParent),
                e.onHover(t, s)
            }
            ))] : []))
              , b = e=>lm.getHighlighted(e).bind(lm.getHighlighted)
              , y = {
                collapseMenu: e=>{
                    b(e).each((t=>{
                        g(e, t)
                    }
                    ))
                }
                ,
                highlightPrimary: e=>{
                    o.getPrimary().each((t=>{
                        a(e, t)
                    }
                    ))
                }
                ,
                repositionMenus: t=>{
                    const n = o.getPrimary().bind((e=>b(t).bind((e=>{
                        const t = r(e)
                          , n = (s = o.getMenus(),
                        Ue(s, f));
                        var s;
                        const a = lr(U(n, $h));
                        return o.getTriggeringPath(t, (e=>((e,t,n)=>re(t, (e=>{
                            if (!e.getSystem().isConnected())
                                return E.none();
                            const t = lm.getCandidates(e);
                            return G(t, (e=>r(e) === n))
                        }
                        )))(0, a, e)))
                    }
                    )).map((t=>({
                        primary: e,
                        triggeringPath: t
                    })))));
                    n.fold((()=>{
                        (e=>E.from(e.components()[0]).filter((e=>"menu" === Dr(e.element, "role"))))(t).each((n=>{
                            e.onRepositionMenu(t, n, [])
                        }
                        ))
                    }
                    ), (({primary: n, triggeringPath: o})=>{
                        e.onRepositionMenu(t, n, o)
                    }
                    ))
                }
            };
            return {
                uid: e.uid,
                dom: e.dom,
                markers: e.markers,
                behaviours: Ta(e.tmenuBehaviours, [Ig.config({
                    mode: "special",
                    onRight: h(((e,t)=>bm(t.element) ? E.none() : m(e, t, d.HighlightSubmenu))),
                    onLeft: h(((e,t)=>bm(t.element) ? E.none() : g(e, t))),
                    onEscape: h(((t,n)=>g(t, n).orThunk((()=>e.onEscape(t, n).map((()=>t)))))),
                    focusIn: (e,t)=>{
                        o.getPrimary().each((t=>{
                            Yo(e, t.element, Bo())
                        }
                        ))
                    }
                }), lm.config({
                    highlightClass: e.markers.selectedMenu,
                    itemClass: e.markers.menu
                }), nd.config({
                    find: e=>lm.getHighlighted(e)
                }), Su.config({})]),
                eventOrder: e.eventOrder,
                apis: y,
                events: v
            }
        }
        ,
        extraApis: {
            tieredData: (e,t,n)=>({
                primary: e,
                menus: t,
                expansions: n
            }),
            singleData: (e,t)=>({
                primary: e,
                menus: kn(e, t),
                expansions: {}
            }),
            collapseItem: e=>({
                value: ys(qh()),
                meta: {
                    text: e
                }
            })
        }
    })
      , Kh = v("sink")
      , Yh = v(pi({
        name: Kh(),
        overrides: v({
            dom: {
                tag: "div"
            },
            behaviours: fr([hu.config({
                useFixed: O
            })]),
            events: Jo([tr(_o()), tr(bo()), tr(Oo())])
        })
    }))
      , Qh = Kt([wn("isExtraPart", w), _n("fireEventInstead", [wn("event", Lo())])])
      , Jh = e=>{
        const t = ln("Dismissal", Qh, e);
        return {
            [S()]: {
                schema: Kt([pn("target")]),
                onReceive: (e,n)=>{
                    wh.isOpen(e) && (wh.isPartOf(e, n.target) || t.isExtraPart(e, n.target) || t.fireEventInstead.fold((()=>wh.close(e)), (t=>qo(e, t.event))))
                }
            }
        }
    }
      , Xh = Kt([_n("fireEventInstead", [wn("event", Uo())]), ("doReposition",
    hn("doReposition", nn))]);
    const Zh = e=>{
        const t = ln("Reposition", Xh, e);
        return {
            [C()]: {
                onReceive: e=>{
                    wh.isOpen(e) && t.fireEventInstead.fold((()=>t.doReposition(e)), (t=>qo(e, t.event)))
                }
            }
        }
    }
    ;
    var ev;
    !function(e) {
        e[e.HighlightFirst = 0] = "HighlightFirst",
        e[e.HighlightNone = 1] = "HighlightNone"
    }(ev || (ev = {}));
    const tv = (e,t)=>{
        const n = e.getHotspot(t).getOr(t)
          , o = "hotspot"
          , r = e.getAnchorOverrides();
        return e.layouts.fold((()=>({
            type: o,
            hotspot: n,
            overrides: r
        })), (e=>({
            type: o,
            hotspot: n,
            overrides: r,
            layouts: e
        })))
    }
      , nv = (e,t,n,o,r,s,a)=>{
        const i = ((e,t,n,o,r,s,a)=>{
            const i = ((e,t,n)=>(0,
            e.fetch)(n).map(t))(e, t, o)
              , c = sv(o, e);
            return i.map((e=>e.bind((e=>E.from(Gh.sketch({
                ...s.menu(),
                uid: Es(""),
                data: e,
                highlightImmediately: a === ev.HighlightFirst,
                onOpenMenu: (e,t)=>{
                    const o = c().getOrDie();
                    hu.position(o, t, {
                        anchor: n
                    }),
                    wh.decloak(r)
                }
                ,
                onOpenSubmenu: (e,t,n)=>{
                    const o = c().getOrDie();
                    hu.position(o, n, {
                        anchor: {
                            type: "submenu",
                            item: t
                        }
                    }),
                    wh.decloak(r)
                }
                ,
                onRepositionMenu: (e,t,o)=>{
                    const r = c().getOrDie();
                    hu.position(r, t, {
                        anchor: n
                    }),
                    j(o, (e=>{
                        hu.position(r, e.triggeredMenu, {
                            anchor: {
                                type: "submenu",
                                item: e.triggeringItem
                            }
                        })
                    }
                    ))
                }
                ,
                onEscape: ()=>(id.focus(o),
                wh.close(r),
                E.some(!0))
            }))))))
        }
        )(e, t, tv(e, n), n, o, r, a);
        return i.map((e=>(e.fold((()=>{
            wh.isOpen(o) && wh.close(o)
        }
        ), (e=>{
            wh.cloak(o),
            wh.open(o, e),
            s(o)
        }
        )),
        o)))
    }
      , ov = (e,t,n,o,r,s,a)=>(wh.close(o),
    et(o))
      , rv = (e,t,n,o,r,s)=>{
        const a = dh.getCoupled(n, "sandbox");
        return (wh.isOpen(a) ? ov : nv)(e, t, n, a, o, r, s)
    }
      , sv = (e,t)=>e.getSystem().getByUid(t.uid + "-" + Kh()).map((e=>()=>ot.value(e))).getOrThunk((()=>t.lazySink.fold((()=>()=>ot.error(new Error("No internal sink is specified, nor could an external sink be found"))), (t=>()=>t(e)))))
      , av = e=>{
        wh.getState(e).each((e=>{
            Gh.repositionMenus(e)
        }
        ))
    }
      , iv = (e,t,n)=>{
        const o = (()=>{
            const e = ys(ah);
            return {
                id: e,
                link: t=>{
                    Fr(t, ah, e)
                }
                ,
                unlink: e=>{
                    Ir(e, ah)
                }
            }
        }
        )()
          , r = sv(t, e);
        return {
            dom: {
                tag: "div",
                classes: e.sandboxClasses,
                attributes: {
                    id: o.id,
                    role: "listbox"
                }
            },
            behaviours: Ma(e.sandboxBehaviours, [_d.config({
                store: {
                    mode: "memory",
                    initialValue: t
                }
            }), wh.config({
                onOpen: (r,s)=>{
                    const a = tv(e, t);
                    o.link(t.element),
                    e.matchWidth && ((e,t,n)=>{
                        const o = nd.getCurrent(t).getOr(t)
                          , r = Xi(e.element);
                        n ? ra(o.element, "min-width", r + "px") : ((e,t)=>{
                            Ji.set(e, t)
                        }
                        )(o.element, r)
                    }
                    )(a.hotspot, s, e.useMinWidth),
                    e.onOpen(a, r, s),
                    void 0 !== n && void 0 !== n.onOpen && n.onOpen(r, s)
                }
                ,
                onClose: (e,r)=>{
                    o.unlink(t.element),
                    void 0 !== n && void 0 !== n.onClose && n.onClose(e, r)
                }
                ,
                isPartOf: (e,n,o)=>ih(n, o) || ih(t, o),
                getAttachPoint: ()=>r().getOrDie()
            }), nd.config({
                find: e=>wh.getState(e).bind((e=>nd.getCurrent(e)))
            }), np.config({
                channels: {
                    ...Jh({
                        isExtraPart: w
                    }),
                    ...Zh({
                        doReposition: av
                    })
                }
            })])
        }
    }
      , cv = v([pn("dom"), pn("fetch"), Ia("onOpen"), Va("onExecute"), wn("getHotspot", E.some), wn("getAnchorOverrides", v({})), hl(), ka("dropdownBehaviours", [Wd, dh, Ig, id]), pn("toggleClass"), wn("eventOrder", {}), bn("lazySink"), wn("matchWidth", !1), wn("useMinWidth", !1), bn("role")].concat([wn("sandboxClasses", []), Aa("sandboxBehaviours", [nd, np, wh, _d])]))
      , lv = v([gi({
        schema: [Ha()],
        name: "menu",
        defaults: e=>({
            onExecute: e.onExecute
        })
    }), Yh()])
      , uv = ki({
        name: "Dropdown",
        configFields: cv(),
        partFields: lv(),
        factory: (e,t,n,o)=>{
            const r = e=>{
                wh.getState(e).each((e=>{
                    Gh.highlightPrimary(e)
                }
                ))
            }
              , s = {
                expand: t=>{
                    Wd.isOn(t) || rv(e, f, t, o, p, ev.HighlightNone).get(p)
                }
                ,
                open: t=>{
                    Wd.isOn(t) || rv(e, f, t, o, p, ev.HighlightFirst).get(p)
                }
                ,
                isOpen: Wd.isOn,
                close: t=>{
                    Wd.isOn(t) && rv(e, f, t, o, p, ev.HighlightFirst).get(p)
                }
                ,
                repositionMenus: e=>{
                    Wd.isOn(e) && (e=>{
                        const t = dh.getCoupled(e, "sandbox");
                        av(t)
                    }
                    )(e)
                }
            }
              , a = (e,t)=>(Ko(e),
            E.some(!0));
            return {
                uid: e.uid,
                dom: e.dom,
                components: t,
                behaviours: Ta(e.dropdownBehaviours, [Wd.config({
                    toggleClass: e.toggleClass,
                    aria: {
                        mode: "expanded"
                    }
                }), dh.config({
                    others: {
                        sandbox: t=>iv(e, t, {
                            onOpen: ()=>Wd.on(t),
                            onClose: ()=>Wd.off(t)
                        })
                    }
                }), Ig.config({
                    mode: "special",
                    onSpace: a,
                    onEnter: a,
                    onDown: (e,t)=>{
                        if (uv.isOpen(e)) {
                            const t = dh.getCoupled(e, "sandbox");
                            r(t)
                        } else
                            uv.open(e);
                        return E.some(!0)
                    }
                    ,
                    onEscape: (e,t)=>uv.isOpen(e) ? (uv.close(e),
                    E.some(!0)) : E.none()
                }), id.config({})]),
                events: Ud(E.some((t=>{
                    rv(e, f, t, o, r, ev.HighlightFirst).get(p)
                }
                ))),
                eventOrder: {
                    ...e.eventOrder,
                    [Fo()]: ["disabling", "toggling", "alloy.base.behaviour"]
                },
                apis: s,
                domModification: {
                    attributes: {
                        "aria-haspopup": "true",
                        ...e.role.fold((()=>({})), (e=>({
                            role: e
                        }))),
                        ..."button" === e.dom.tag ? {
                            type: ("type",
                            ze(e.dom, "attributes").bind((e=>ze(e, "type")))).getOr("button")
                        } : {}
                    }
                }
            }
        }
        ,
        apis: {
            open: (e,t)=>e.open(t),
            expand: (e,t)=>e.expand(t),
            close: (e,t)=>e.close(t),
            isOpen: (e,t)=>e.isOpen(t),
            repositionMenus: (e,t)=>e.repositionMenus(t)
        }
    })
      , dv = "alloy.base.behaviour"
      , mv = ys("tc-kebab-action")
      , gv = (e,t)=>{
        const n = U(e, (e=>({
            type: "item",
            data: {
                value: e.eventName
            },
            dom: {
                tag: "div",
                classes: Qu.kebabItem
            },
            components: [{
                dom: {
                    tag: "span",
                    classes: Qu.kebabItemLabel
                },
                components: [xa(t.universe.translate(e.textKey))]
            }],
            itemBehaviours: fr([wr("item-events", [ir((t=>{
                Go(t, mv, {
                    eventName: e.eventName
                }),
                qo(t, Po())
            }
            ))]), ...cp({
                disablingConfig: {
                    disableClass: Qu.kebabDisabledItem.join(" ")
                }
            })]),
            eventOrder: {
                [Fo()]: [Zg.name(), dv, Wd.name(), "typeaheadevents", "item-events"]
            }
        })));
        return uv.sketch({
            dom: {
                tag: "button",
                attributes: {
                    type: "button"
                },
                classes: Qu.kebab
            },
            components: [{
                dom: {
                    tag: "div",
                    classes: Qu.kebabIcon,
                    innerHtml: '<svg width="24" height="24" data-name="icon-image-options"><g id="icon-image-options" stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2z" id="Shape" fill-rule="nonzero"></path></g></svg>'
                }
            }],
            lazySink: e=>t.getSink(e).fold((()=>ot.error("Could not find sink for kebab")), ot.value),
            dropdownBehaviours: fr([...cp({}), Od.config({
                tabAttr: Gp
            })]),
            sandboxBehaviours: fr([wr("kebab-sandbox-events", [Zo(mv, ((e,t)=>{
                const n = _d.getValue(e);
                qo(n, t.event.eventName)
            }
            ))])]),
            parts: {
                menu: {
                    dom: {
                        tag: "div"
                    },
                    markers: Ju.kebab
                }
            },
            toggleClass: Yu.kebabOpen,
            layouts: {
                onLtr: ()=>[Qc],
                onRtl: ()=>[Yc]
            },
            fetch: ()=>{
                const e = ys("kebab-id");
                return et(E.some(Gh.singleData(e, {
                    value: ys(e),
                    dom: {
                        tag: "div",
                        classes: Qu.kebabMenu
                    },
                    components: [{
                        dom: {
                            tag: "div",
                            classes: Qu.kebabMenuGroup
                        },
                        components: [Lh.parts.items({})]
                    }],
                    items: n
                })))
            }
        })
    }
      , pv = e=>{
        const t = T(e)
          , n = ye(t)
          , o = (e=>{
            const t = void 0 !== e.dom.attributes ? e.dom.attributes : [];
            return q(t, ((e,t)=>"class" === t.name ? e : {
                ...e,
                [t.name]: t.value
            }), {})
        }
        )(t)
          , r = (e=>Array.prototype.slice.call(e.dom.classList, 0))(t)
          , s = 0 === n.length ? {} : {
            innerHtml: Mr(t)
        };
        return {
            tag: ce(t),
            classes: r,
            attributes: o,
            ...s
        }
    }
      , hv = "overlay-button-events"
      , vv = [Od.config({}), wr(hv, [Zo(bo(), ((e,t)=>{
        t.event.prevent()
    }
    ))])]
      , fv = (e,t,n)=>{
        const o = t=>{
            qo(t, Fp),
            Sp(e(), (()=>({
                stage: bp.Before
            })))(t)
        }
          , r = (e,t,n)=>Vg.sketch({
            dom: {
                tag: "button",
                classes: e ? Qu.button : Qu.secondaryButton
            },
            components: [xa(t)],
            eventOrder: {
                [bo()]: [dv, id.name(), hv]
            },
            action: n,
            buttonBehaviours: fr(vv)
        })
          , s = {
            setText: (e,s,a)=>{
                const i = ((e,o)=>{
                    const r = U(((e,t)=>{
                        switch (t) {
                        case bp.QueryingDelete:
                            return n ? [Mu.tc_delete_prompts_conversation, 1 === e ? Mu.tc_delete_prompts_conversation_detail_sing : {
                                pattern: Mu.tc_delete_prompts_conversation_detail_pl,
                                targets: [e]
                            }] : [Mu.tc_delete_prompts_comment];
                        case bp.QueryingResolve:
                            return [Mu.tc_resolve_prompts_conversation, 1 === e ? Mu.tc_resolve_prompts_conversation_detail_sing : {
                                pattern: Mu.tc_resolve_prompts_conversation_detail_pl,
                                targets: [e]
                            }];
                        default:
                            return []
                        }
                    }
                    )(e, o), (e=>"string" == typeof e ? t.translate(e) : t.translate([e.pattern].concat(e.targets))))
                      , s = o === bp.QueryingDelete;
                    return {
                        lines: r,
                        cancelText: t.translate(Mu.tc_delete_buttons_cancel),
                        proceedText: t.translate(s ? Mu.tc_delete_buttons_proceed : Mu.tc_resolve_buttons_proceed),
                        proceedEvent: s ? Pp : Ip
                    }
                }
                )(s, a);
                Su.set(e, U(i.lines, (e=>({
                    dom: {
                        tag: "div"
                    },
                    components: [{
                        dom: pv(`<p>${e}</p>`)
                    }]
                }))).concat([{
                    dom: {
                        tag: "div",
                        classes: Qu.cardOverlayButtons
                    },
                    components: [r(!0, i.cancelText, o), r(!1, i.proceedText, (e=>{
                        qo(e, i.proceedEvent)
                    }
                    ))]
                }]))
            }
        };
        return {
            dom: {
                tag: "div",
                styles: {
                    display: "none"
                },
                classes: Qu.cardOverlayText
            },
            components: [],
            apis: s,
            behaviours: fr([Su.config({}), wr("card-delete-events", [Zo(Mo(), (t=>{
                Er(t.element).fold((()=>{
                    Sp(e(), (()=>({
                        stage: bp.Before
                    })))(t)
                }
                ), p)
            }
            ))]), Ig.config({
                mode: "cyclic",
                onEscape: e=>(o(e),
                E.some(!0))
            })])
        }
    }
      , bv = (e,t,n)=>{
        n ? (ua(t.element, "display"),
        t.hasConfigured(Ig) && Ig.focusIn(t)) : ra(t.element, "display", "none")
    }
      , yv = "basecamp"
      , _v = "deleting"
      , xv = {
        textKey: Mu.tc_kebab_edit,
        eventName: Vp
    }
      , wv = {
        textKey: Mu.tc_kebab_delete,
        eventName: Bp
    }
      , Ov = {
        textKey: Mu.tc_kebab_delete_conversation,
        eventName: Dp
    }
      , Sv = {
        textKey: Mu.tc_kebab_resolve_conversation,
        eventName: Hp
    }
      , Cv = (e,t,n,o)=>{
        let r = e;
        const s = Y([n.deleteConversation ? [Ov] : [], n.resolveConversation ? [Sv] : [], n.editComment ? [xv] : [], n.deleteComment ? [wv] : []])
          , a = Wi(((e,t)=>{
            const n = e=>[xa(`${rh(_t(e.createdAt), t)}`), {
                dom: {
                    tag: "span",
                    classes: []
                },
                components: e.modifiedAt === e.createdAt ? [] : [xa(t.translate(Mu.tc_date_comment_edited))]
            }]
              , o = {
                updateWith: (e,t,o)=>{
                    Su.set(e, n(t))
                }
            };
            return {
                dom: {
                    tag: "div",
                    classes: Qu.date
                },
                components: n(e),
                behaviours: fr([Su.config({})]),
                apis: o
            }
        }
        )(e, o.universe))
          , i = {
            updateWith: (e,t,n)=>{
                r = t,
                l.getOpt(e).each((e=>{
                    e.getApis().updateWith(e, t, {})
                }
                )),
                u.getOpt(e).each((e=>{
                    e.getApis().updateWith(e, t, {})
                }
                )),
                ((e,t,n)=>{
                    const o = n.stage === bp.QueryingDelete || n.stage === bp.QueryingResolve;
                    d.getOpt(e).each((e=>bv(0, e, o))),
                    m.getOpt(e).each((e=>{
                        e.getApis().setText(e, t, n.stage),
                        bv(0, e, o)
                    }
                    ))
                }
                )(e, n.numComments, t),
                t.stage !== bp.PostDelete && t.stage !== bp.PostResolve || Nd.getCurrentRoute(e).filter((e=>e.destination === _v)).fold((()=>{
                    Nd.progressTo(e, _v)
                }
                ), p),
                a.getOpt(e).each((e=>{
                    e.getApis().updateWith(e, t, {})
                }
                ))
            }
        }
          , c = {
            dom: {
                tag: "div",
                classes: Qu.cardHead
            },
            components: Y([[{
                dom: {
                    tag: "div",
                    classes: Qu.cardHeadMeta
                },
                components: [(e=>{
                    const t = ((e,t)=>({
                        dom: {
                            tag: "div",
                            classes: Qu.avatar
                        },
                        components: [{
                            dom: {
                                tag: "img",
                                attributes: {
                                    alt: "",
                                    role: "presentation",
                                    src: Zu(e, t)
                                }
                            }
                        }]
                    }))(o.avatarCache, e)
                      , n = {
                        dom: {
                            tag: "div",
                            classes: Qu.username
                        },
                        components: [xa(e.authorName)]
                    };
                    return {
                        dom: {
                            tag: "div",
                            classes: Qu.user
                        },
                        components: [t, {
                            dom: {
                                tag: "div"
                            },
                            components: [n, a.asSpec()]
                        }]
                    }
                }
                )(r)]
            }], s.length > 0 ? [gv(s, o)] : []])
        }
          , l = Wi((e=>{
            const t = mt(e)
              , n = {
                updateWith: (e,n,o)=>{
                    switch (t.set(n),
                    n.mode) {
                    case fp.None:
                        ra(e.element, "display", "none");
                        break;
                    case fp.Collapsed:
                        ua(e.element, "display"),
                        xe(e.element).each((e=>Rr(e, Mu.tc_comment_buttons_showmore)));
                        break;
                    case fp.Expanded:
                        ua(e.element, "display"),
                        xe(e.element).each((e=>Rr(e, Mu.tc_comment_buttons_showless)));
                        break;
                    case fp.ExpandOrNone:
                    case fp.CollapsedOrNone:
                        break;
                    case fp.Edit:
                        ra(e.element, "display", "none")
                    }
                }
            };
            return {
                dom: {
                    tag: "div",
                    classes: Qu.showMoreLessContainer,
                    styles: {
                        display: "none"
                    }
                },
                components: [Vg.sketch({
                    dom: {
                        tag: "p",
                        classes: Qu.showMoreLess
                    },
                    components: [xa(Mu.tc_comment_buttons_showmore)],
                    action: e=>{
                        Sp(t.get().uid, (()=>({
                            mode: t.get().mode === fp.Collapsed ? fp.Expanded : fp.Collapsed
                        })))(e)
                    }
                    ,
                    buttonBehaviours: fr([Od.config({
                        tabAttr: Gp
                    })])
                })],
                apis: n
            }
        }
        )({
            uid: e.uid,
            mode: e.mode
        }))
          , u = Wi(((e,t)=>{
            const n = mt(e)
              , o = e=>{
                qo(e, Fp),
                Sp(n.get().uid, (e=>({
                    mode: fp.ExpandOrNone
                })))(e)
            }
              , r = {
                updateWith: (e,t,o)=>{
                    n.set(t),
                    Np({
                        props: t,
                        memCommands: s
                    }).each((t=>{
                        Js(e.element, Yu.bodyNotAnimating),
                        t(e)
                    }
                    ))
                }
            }
              , s = Wi(((e,t)=>({
                dom: {
                    tag: "div",
                    classes: Qu.editActions
                },
                components: [dp({
                    text: t.translate(Mu.tc_edit_buttons_cancel),
                    eventName: E.some(gp),
                    disableWhileSaving: !0
                }), up({
                    text: t.translate(Mu.tc_edit_buttons_save),
                    eventName: E.some(mp),
                    disableWhileSaving: !0
                })]
            }))(n.get(), t));
            return {
                dom: {
                    tag: "div",
                    classes: Qu.cardBody
                },
                components: [th(n.get().content)],
                behaviours: fr([wr("overflow-events", [rr((e=>{
                    r.updateWith(e, n.get(), {})
                }
                )), Zo(mp, (e=>{
                    qo(e, Wp)
                }
                )), Zo(gp, o), or(Co(), ((e,t)=>{
                    "max-height" === t.event.raw.propertyName && xe(e.element).each((t=>{
                        e.getSystem().triggerEvent(wo(), t, {})
                    }
                    ))
                }
                ))]), Kp({
                    onEscape: e=>(o(e),
                    E.some(!0))
                }), Wd.config({
                    toggleClass: Yu.bodyExpanded,
                    selected: !1,
                    toggleOnExecute: !1,
                    aria: {
                        mode: "expanded"
                    }
                }), _d.config({
                    store: {
                        mode: "manual",
                        getValue: e=>xe(e.element).map(ma).getOr(""),
                        setValue: (e,t)=>{
                            xe(e.element).each((e=>{
                                ga(e, t)
                            }
                            ))
                        }
                    }
                }), Su.config({})]),
                apis: r
            }
        }
        )(r, o.universe))
          , d = Wi({
            dom: {
                tag: "div",
                classes: Qu.cardOverlay,
                styles: {
                    display: "none"
                }
            }
        })
          , m = Wi(fv((()=>r.uid), o.universe, t));
        return {
            dom: {
                tag: "div",
                classes: Qu.card,
                styles: {
                    position: "relative"
                }
            },
            components: [c, u.asSpec(), d.asSpec(), m.asSpec(), l.asSpec()],
            behaviours: fr([id.config({}), Od.config({}), Qp({
                escapeEvent: Fp
            }), Nd.config({
                initialState: yv,
                onTransition: e=>{
                    var t;
                    (t = r.uid,
                    e=>{
                        Go(e, hp, {
                            uid: t
                        })
                    }
                    )(e)
                }
                ,
                routes: {
                    [yv]: {
                        [_v]: {
                            transition: {
                                property: "opacity",
                                transitionClass: Yu.disappearing
                            }
                        }
                    }
                }
            }), _d.config({
                store: {
                    mode: "memory",
                    initialValue: r.uid
                }
            }), wr("comment-events", [Zo(Lp, (e=>Sp(r.uid, (()=>({
                mode: r.mode === fp.Collapsed ? fp.Expanded : fp.Collapsed
            })))(e))), Zo(Fp, id.focus), Zo(Bp, (e=>{
                Sp(r.uid, (()=>({
                    stage: bp.QueryingDelete
                })))(e)
            }
            )), Zo(Dp, (e=>{
                Sp(r.uid, (()=>({
                    stage: bp.QueryingDelete
                })))(e)
            }
            )), Zo(Hp, (e=>{
                Sp(r.uid, (()=>({
                    stage: bp.QueryingResolve
                })))(e)
            }
            )), Zo(Ip, (e=>{
                Go(e, sh.resolveConversationEvent, {
                    uid: r.uid
                })
            }
            )), Zo(Vp, (e=>Sp(r.uid, (e=>({
                mode: fp.Edit
            })))(e))), Zo(Wp, (e=>{
                u.getOpt(e).each((t=>{
                    const n = _d.getValue(t);
                    Go(e, sh.editCommentEvent, {
                        uid: r.uid,
                        content: n
                    })
                }
                ))
            }
            )), Zo(Pp, (e=>{
                Go(e, t ? sh.deleteConversationEvent : sh.deleteCommentEvent, {
                    uid: r.uid
                })
            }
            ))])]),
            apis: i
        }
    }
      , Ev = (e,t,n)=>U(e, ((e,o)=>{
        const r = 0 === o;
        return Cv(e, r, {
            editComment: !0,
            deleteComment: o > 0,
            deleteConversation: r,
            resolveConversation: r && n
        }, t)
    }
    ))
      , kv = (e,t,n=!1)=>{
        const o = {
            setComments: (e,o)=>{
                nd.getCurrent(e).each((e=>{
                    Su.set(e, Ev(o, t, n))
                }
                )),
                Cp(e)
            }
            ,
            updateWith: (e,o,r)=>{
                nd.getCurrent(e).each((r=>{
                    const s = Su.contents(r);
                    (e=>oe(e).exists((e=>e.stage === bp.QueryingDelete)))(o) || (e=>oe(e).exists((e=>e.stage === bp.QueryingResolve)))(o) ? Qs(r.element, Yu.commentThreadOverlay) : Js(r.element, Yu.commentThreadOverlay),
                    s.length !== o.length ? Su.set(r, Ev(o, t, n)) : j(s, ((e,t)=>{
                        s[t].getApis().updateWith(s[t], o[t], {
                            numComments: o.length
                        })
                    }
                    )),
                    Cp(e)
                }
                ))
            }
            ,
            scrollToEnd: e=>{
                nd.getCurrent(e).each((t=>{
                    var n;
                    (n = Su.contents(t),
                    ne(n, n.length - 1)).each((t=>{
                        const n = e.element.dom
                          , o = n.getBoundingClientRect()
                          , r = t.element.dom.getBoundingClientRect();
                        r.top < o.top ? n.scrollTop += r.top - o.top : r.bottom > o.bottom && (n.scrollTop += r.bottom - o.bottom)
                    }
                    ))
                }
                ))
            }
        };
        return {
            dom: {
                tag: "div",
                classes: Qu.outerScroll
            },
            components: [{
                dom: {
                    tag: "div",
                    classes: Qu.commentList
                },
                components: Ev(e, t, n),
                behaviours: fr([Jp({
                    selector: Ku.card
                }), Su.config({})])
            }],
            behaviours: fr([nd.config({
                find: e=>xe(e.element).bind((t=>e.getSystem().getByDom(t).toOptional()))
            })]),
            apis: o
        }
    }
      , Tv = e=>{
        return {
            dom: {
                tag: "div",
                classes: Qu.conversationsHead
            },
            components: [(t = e.translate(Mu.tc_conversations_title),
            {
                dom: {
                    tag: "div",
                    classes: Qu.conversationsTitle
                },
                components: [xa(t)]
            })]
        };
        var t
    }
    ;
    var Av;
    !function(e) {
        e[e.Start = 0] = "Start",
        e[e.Reply = 1] = "Reply"
    }(Av || (Av = {}));
    const Mv = ys("tc-clear-input")
      , Rv = ys("tc-submit-input")
      , Nv = (e,t)=>{
        const n = Wi((e=>((e,t)=>qp.sketch({
            tag: "textarea",
            inputClasses: Qu.replyTextarea,
            inputAttributes: {
                ...Xp,
                placeholder: t.translate(Mu.tc_reply_placeholders)
            },
            inputStyles: Zp,
            inputBehaviours: fr([Yp({
                enterEvent: e
            }), Od.config({}), wr("reply-events", [Zo(wo(), eh)]), ...cp({
                disableWhileSaving: !0
            })])
        }))(Rv, e))(t))
          , o = {
            focusEditor: e=>{
                n.getOpt(e).each(id.focus)
            }
            ,
            updateWith: (e,t,n)=>{
                L(t, (e=>e.mode === fp.Edit)) ? ra(e.element, "display", "none") : ua(e.element, "display")
            }
        };
        return {
            dom: {
                tag: "div",
                classes: Qu.replySection
            },
            behaviours: fr([wr("reply-events", [Zo(Mv, (e=>{
                n.getOpt(e).each((e=>{
                    _d.setValue(e, "")
                }
                ))
            }
            )), Zo(Rv, (t=>{
                n.getOpt(t).map(_d.getValue).each((n=>{
                    n.length > 0 && Go(t, sh.createCommentEvent, {
                        content: n,
                        mode: e
                    })
                }
                ))
            }
            ))])]),
            components: [n.asSpec(), dp({
                text: t.translate(Mu.tc_reply_buttons_clear),
                eventName: E.some(Mv),
                disableWhileSaving: !0
            }), up({
                text: t.translate(Mu.tc_reply_buttons_comment),
                eventName: E.some(Rv),
                disableWhileSaving: !0
            })],
            apis: o
        }
    }
      , Fv = ()=>{
        let e = wp();
        const t = t=>{
            e = t(e)
        }
        ;
        return {
            clearAll: ()=>{
                e = wp()
            }
            ,
            recalibrate: e=>{
                t((t=>{
                    return n = t,
                    o = e.comments,
                    {
                        targetUid: n.targetUid,
                        conversation: U(o, (e=>({
                            uid: e.uid,
                            props: {
                                ...e,
                                stage: bp.Before,
                                mode: cr(n.targetUid, e.uid) ? fp.ExpandOrNone : fp.CollapsedOrNone
                            }
                        }))),
                        queue: []
                    };
                    var n, o
                }
                ))
            }
            ,
            enqueuePatch: (e,n)=>{
                t((t=>((e,t)=>xp(e, [t]))(t, {
                    uid: e,
                    patch: n
                })))
            }
            ,
            enqueuePatches: e=>{
                t((t=>xp(t, e)))
            }
            ,
            setTargetUid: e=>{
                t((t=>_p(t, E.some(e))))
            }
            ,
            clearTargetUid: ()=>{
                t((e=>_p(e, E.none())))
            }
            ,
            processQueue: ()=>(e=>{
                if (e.queue.length > 0) {
                    const t = (e=>{
                        const t = U(e.conversation, (t=>G(e.queue, (e=>e.uid === t.uid)).fold((()=>t), (e=>{
                            const n = void 0 !== e.patch.content ? {
                                mode: fp.ExpandOrNone
                            } : {};
                            return {
                                uid: t.uid,
                                props: {
                                    ...t.props,
                                    ...e.patch,
                                    ...n
                                }
                            }
                        }
                        ))));
                        return {
                            targetUid: e.targetUid,
                            conversation: t,
                            queue: []
                        }
                    }
                    )(e);
                    return E.some({
                        world: t,
                        props: yp(t)
                    })
                }
                return E.none()
            }
            )(e).map((({world: t, props: n})=>(e = t,
            n))),
            purge: e=>{
                t((t=>{
                    const n = z(t.conversation, (t=>t.uid !== e));
                    return {
                        ...t,
                        conversation: n
                    }
                }
                ))
            }
            ,
            getProps: ()=>yp(e),
            adjust: e=>{
                t((t=>xp(t, U(e, (e=>({
                    uid: e.uid,
                    patch: "to-delete" === e.type ? {
                        stage: bp.PostDelete
                    } : {}
                }))))))
            }
        }
    }
      , Bv = e=>({
        type: "redraw-sidebar",
        view: e
    })
      , Dv = ys("tc-escapeInSidebar")
      , Hv = (e,t,n,o,r,s,a)=>{
        const i = e=>{
            v.get().each((t=>{
                "comments" === t.type && oe(t.conversation.comments).each((({author: n, authorName: o, content: r, createdAt: s})=>{
                    e(t.conversation.uid, {
                        author: n,
                        authorName: o
                    }, r, a(t.conversation.uid), s)
                }
                ))
            }
            ))
        }
          , c = (e,t)=>{
            v.get().each((n=>{
                "comments" === n.type && G(n.conversation.comments, (t=>t.uid === e)).each((({author: e, authorName: n, content: o})=>{
                    t({
                        author: e,
                        authorName: n
                    }, o)
                }
                ))
            }
            ))
        }
          , l = Fv()
          , u = (()=>{
            const e = {};
            return {
                lookup: t=>ze(e, t),
                store: (t,n)=>e[t] = n
            }
        }
        )()
          , d = ()=>{
            l.processQueue().each((e=>{
                w(e),
                b.getOpt(p).each((t=>{
                    t.getApis().updateWith(t, e, {})
                }
                ))
            }
            ))
        }
          , m = (e,t)=>{
            i(((n,o,r,s,a)=>e(n).get((e=>{
                e.fold((e=>e()), (e=>{
                    e(),
                    t(n, o, r, s, a)
                }
                ))
            }
            ))))
        }
          , g = (e,t)=>{
            e.get((e=>{
                e.fold((e=>e()), (e=>{
                    l.setTargetUid(e.targetUid),
                    e.fn(),
                    t(e.targetUid)
                }
                ))
            }
            ))
        }
          , p = Ca({
            dom: {
                tag: "div",
                classes: e,
                styles: {
                    position: "relative"
                }
            },
            behaviours: fr([Su.config({}), Kp({
                onEscape: e=>(qo(e, Dv),
                E.some(!0))
            }), wr("sidebar-events", [Zo(pp, ((e,t)=>{
                l.enqueuePatch(t.event.uid, t.event.patch)
            }
            )), Zo(hp, ((e,t)=>{
                l.purge(t.event.uid),
                b.getOpt(p).each((e=>{
                    const t = l.getProps();
                    w(t),
                    e.getApis().updateWith(e, t, {})
                }
                ))
            }
            )), Zo(vp, (()=>{
                d()
            }
            )), Zo(Dv, (()=>{
                t.onEscape()
            }
            )), Zo(sh.deleteConversationEvent, (()=>{
                m((e=>n.deleteConversation(e)), ((e,t,n,o,s)=>{
                    r({
                        type: "delete",
                        timestamp: gt(),
                        conversationUid: e,
                        conversationContext: o,
                        conversationContent: n,
                        conversationAuthor: t,
                        conversationCreatedAt: s
                    })
                }
                ))
            }
            )), Zo(sh.deleteCommentEvent, ((e,t)=>{
                const o = t.event.uid;
                m((e=>n.deleteComment(e, o)), ((e,t,n,s,a)=>{
                    c(o, ((i,c)=>{
                        r({
                            type: "delete-comment",
                            timestamp: gt(),
                            conversationUid: e,
                            commentUid: o,
                            conversationContext: s,
                            conversationContent: n,
                            conversationCreatedAt: a,
                            commentContent: c,
                            commentAuthor: i,
                            conversationAuthor: t
                        })
                    }
                    ))
                }
                ))
            }
            )), Zo(sh.resolveConversationEvent, (()=>{
                n.optResolveConversation.each((e=>{
                    m((t=>e(t)), ((e,t,n,o,s)=>{
                        r({
                            type: "resolve",
                            timestamp: gt(),
                            conversationUid: e,
                            conversationContext: o,
                            conversationContent: n,
                            conversationCreatedAt: s,
                            conversationAuthor: t
                        })
                    }
                    ))
                }
                ))
            }
            )), Zo(sh.editCommentEvent, ((e,t)=>{
                const {uid: o, content: s} = t.event;
                i(((e,t,a,i,l)=>{
                    g(n.editComment(e, o, s), (()=>{
                        c(o, (n=>{
                            r({
                                type: "edit-comment",
                                timestamp: gt(),
                                conversationUid: e,
                                commentUid: o,
                                conversationContext: i,
                                conversationContent: a,
                                conversationCreatedAt: l,
                                commentContent: s,
                                commentAuthor: n,
                                conversationAuthor: t
                            })
                        }
                        ))
                    }
                    ))
                }
                ))
            }
            )), Zo(sh.createCommentEvent, ((e,t)=>{
                const o = t.event.content;
                t.event.mode === Av.Reply ? i(((e,t,s,a,i)=>{
                    g(n.reply(e, o), (n=>{
                        r({
                            type: "reply",
                            timestamp: gt(),
                            conversationUid: e,
                            commentUid: n,
                            conversationContext: a,
                            conversationContent: s,
                            conversationCreatedAt: i,
                            commentContent: o,
                            conversationAuthor: t
                        })
                    }
                    ))
                }
                )) : g(n.createConversation(o), (e=>{
                    r({
                        type: "create",
                        timestamp: gt(),
                        conversationUid: e,
                        conversationContext: a(e),
                        conversationContent: o
                    })
                }
                ))
            }
            ))])])
        })
          , h = Vi(p)
          , v = mt(E.none())
          , f = e=>{
            Su.set(p, [y.asSpec(), Tv(o)].concat(e))
        }
          , b = Wi(kv([], {
            getSink: e=>y.getOpt(e),
            universe: o,
            avatarCache: u
        }, s.useResolveConversation))
          , y = Wi({
            dom: {
                tag: "div",
                styles: {
                    "z-index": "100"
                }
            },
            behaviours: fr([hu.config({})])
        })
          , _ = Wi(Nv(Av.Start, o))
          , x = Wi(Nv(Av.Reply, o))
          , w = e=>{
            x.getOpt(p).each((t=>{
                t.getApis().updateWith(t, e, {})
            }
            ))
        }
          , O = e=>{
            "splash" === e.view.type ? (l.clearAll(),
            f([_.asSpec()])) : "comments" === e.view.type && (l.recalibrate(e.view.conversation),
            f([b.asSpec(), x.asSpec()]),
            b.getOpt(p).each((e=>{
                const t = l.getProps();
                w(t),
                e.getApis().setComments(e, t),
                e.getApis().scrollToEnd(e)
            }
            )))
        }
        ;
        return {
            system: h,
            root: p,
            element: h.element,
            update: e=>{
                b.getOpt(p).bind((e=>v.get().map((t=>({
                    convUi: e,
                    pview: t
                }))))).fold((()=>O(e)), (({pview: t})=>{
                    const n = ((e,t)=>e.type !== t.type ? Bv(t) : "splash" === t.type ? {
                        type: "no-change"
                    } : ((e,t)=>{
                        if (e.conversation.uid === t.conversation.uid) {
                            const n = U(e.conversation.comments, (e=>e.uid))
                              , o = U(t.conversation.comments, (e=>e.uid));
                            return ((e,t,n=H)=>D(n).eq(e, t))(n, o) ? {
                                type: "refresh-comments",
                                comments: U(t.conversation.comments, (e=>({
                                    uid: e.uid,
                                    patch: {
                                        ...e
                                    }
                                })))
                            } : 0 === Z(o, n).length ? {
                                type: "remove-comments",
                                adjustments: U(n, (e=>({
                                    type: W(o, e) ? "to-remain" : "to-delete",
                                    uid: e
                                })))
                            } : Bv(t)
                        }
                        return Bv(t)
                    }
                    )(e, t))(t, e.view);
                    switch (n.type) {
                    case "add-comment":
                    case "redraw-sidebar":
                        O(e);
                        break;
                    case "no-change":
                        break;
                    case "remove-comments":
                        l.adjust(n.adjustments),
                        d();
                        break;
                    case "refresh-comments":
                        l.enqueuePatches(n.comments),
                        d()
                    }
                }
                )),
                v.set(E.some(e.view)),
                Cu(p.element) && e.grabFocus() && x.getOpt(p).orThunk((()=>_.getOpt(p))).each((e=>{
                    e.getApis().focusEditor(e)
                }
                ))
            }
            ,
            hasFocus: ()=>Er(p.element).isSome(),
            sendGlobalUiState: e=>{
                e.readonly && h.broadcastOn([S()], {
                    target: h.element
                }),
                h.broadcastOn([wt], e)
            }
            ,
            getSink: y.getOpt
        }
    }
      , Pv = (e,t)=>{
        e.execCommand("tc-delete-conversation-at-cursor", null, {
            conversationUid: t
        })
    }
      , Iv = (e,t,n,o)=>e.fold((e=>ot.error({
        message: t,
        error: e,
        refresh: o
    })), (e=>n(e).fold((e=>ot.error({
        message: e.permError,
        error: e.reason,
        refresh: o
    })), ot.value)))
      , Vv = e=>ze(e, "reason").getOr("");
    tinymce.Resource.add("tinymce.plugins.tinycomments.sidebar", ((e,t,n,o,s,a)=>{
        const i = ((e,t,n)=>{
            const o = e=>()=>{
                n().showError(e.message, e.error),
                e.refresh && e.refresh()
            }
            ;
            return {
                createConversation: r=>(n().setSaving(!0),
                it.wrap(e.create({
                    content: r,
                    createdAt: gt()
                }).map((e=>{
                    const r = ot.value
                      , s = p;
                    return n().setSaving(!1),
                    Iv(e, Mu.tc_create_problem, r, s).fold((e=>ot.error(o(e))), (e=>ot.value({
                        targetUid: e.conversationUid,
                        fn: ()=>{
                            n().refreshReadonly() ? ze(e, "onError").each((e=>e(new Error("Unable to create a new conversation")))) : (t.annotator.annotate(Ge(), {
                                uid: e.conversationUid
                            }),
                            n().refreshSidebar(E.some(e.conversationUid), 3),
                            ze(e, "onSuccess").each((t=>t(e.conversationUid))))
                        }
                    })))
                }
                )))),
                reply: (t,r)=>(n().setSaving(!0),
                it.wrap(e.reply({
                    conversationUid: t,
                    content: r,
                    createdAt: gt()
                }).map((e=>{
                    const r = ot.value
                      , s = p;
                    return n().setSaving(!1),
                    Iv(e, Mu.tc_reply_problem, r, s).fold((e=>ot.error(o(e))), (e=>ot.value({
                        targetUid: e.commentUid,
                        fn: ()=>{
                            n().refreshSidebar(E.some(t), 3)
                        }
                    })))
                }
                )))),
                editComment: (t,r,s)=>(n().setSaving(!0),
                it.wrap(e.editComment({
                    conversationUid: t,
                    commentUid: r,
                    content: s,
                    modifiedAt: gt()
                }).map((e=>{
                    const s = p;
                    return n().setSaving(!1),
                    Iv(e, Mu.tc_edit_problem_comment, (e=>e.canEdit ? ot.value(e) : ot.error({
                        permError: Mu.tc_edit_unauthorised_comment,
                        reason: Vv(e)
                    })), s).fold((e=>ot.error(o(e))), (()=>ot.value({
                        targetUid: r,
                        fn: ()=>{
                            n().refreshSidebar(E.some(t), 4)
                        }
                    })))
                }
                )))),
                deleteComment: (t,r)=>it.wrap(e.deleteComment({
                    conversationUid: t,
                    commentUid: r
                }).map((e=>Iv(e, Mu.tc_delete_problem_comment, (e=>e.canDelete ? ot.value(e) : ot.error({
                    permError: Mu.tc_delete_unauthorised_comment,
                    reason: Vv(e)
                })), (()=>{
                    n().refreshSidebar(E.some(t), 4)
                }
                )).fold((e=>ot.error(o(e))), (()=>ot.value((()=>{
                    n().refreshSidebar(E.some(t), 4)
                }
                ))))))),
                deleteConversation: r=>it.wrap(e.deleteConversation({
                    conversationUid: r
                }).map((e=>Iv(e, Mu.tc_delete_problem_conversation, (e=>e.canDelete ? ot.value(e) : ot.error({
                    permError: Mu.tc_delete_unauthorised_conversation,
                    reason: Vv(e)
                })), (()=>{
                    n().refreshSidebar(E.some(r), 4)
                }
                )).fold((e=>ot.error(o(e))), (()=>ot.value((()=>{
                    Pv(t, r),
                    n().refreshSidebar(E.none(), 2)
                }
                ))))))),
                optResolveConversation: e.resolveConversation.map((e=>r=>it.wrap(e({
                    conversationUid: r
                }).map((e=>Iv(e, Mu.tc_resolve_problem_conversation, (e=>e.canResolve ? ot.value(e) : ot.error({
                    permError: Mu.tc_resolve_unauthorised_conversation,
                    reason: Vv(e)
                })), (()=>{
                    n().refreshSidebar(E.some(r), 4)
                }
                )).fold((e=>ot.error(o(e))), (()=>ot.value((()=>{
                    Pv(t, r),
                    n().refreshSidebar(E.none(), 2)
                }
                )))))))))
            }
        }
        )(t, e, (()=>u))
          , c = {
            useResolveConversation: t.resolveConversation.isSome()
        }
          , l = Hv(Qu.roots, {
            onEscape: ()=>e.focus()
        }, i, a, ((e,t)=>n=>{
            const o = (e=>(t={})=>r(t.after) ? xt(e, t.after) : xt(e))(t);
            t.set(t.get().concat([n])),
            ((e,t)=>{
                const n = {
                    getEventLog: t
                };
                e.dispatch("CommentChange", n)
            }
            )(e, o)
        }
        )(e, o), c, (t=>((e,t)=>ze(e.annotator.getAll(Ge()), t).map((t=>U(t, (t=>((e,t)=>{
            const n = "SPAN" === t.nodeName;
            return e.serialize(t, {
                getInner: n,
                selection: !0
            })
        }
        )(e.serializer, t))).join(" "))).getOr(""))(e, t)))
          , u = dt(t, n, e, l)
          , d = e=>{
            l.system.broadcastOn([S()], {
                target: R(e.target)
            })
        }
        ;
        e.on("ResizeEditor", (()=>{
            l.system.broadcastOn([Ot], {})
        }
        ));
        const m = Me(R(document), "mousedown", (e=>{
            l.system.broadcastOn([S()], {
                target: e.target
            })
        }
        ));
        e.on("mousedown", d),
        e.on("remove", (()=>{
            e.off("mousedown", d),
            m.unbind()
        }
        )),
        s({
            controller: u,
            attachTo: e=>{
                Fe(e, l.element)
            }
        })
    }
    ))
}();
