/*!
 * Tiny Comments plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 3.1.0-66
 */

!function() {
    "use strict";
    const e = e=>{
        let t = e;
        return {
            get: ()=>t,
            set: e=>{
                t = e
            }
        }
    }
      , t = Object.getPrototypeOf
      , o = (e,t,o)=>{
        var n;
        return !!o(e, t.prototype) || (null === (n = e.constructor) || void 0 === n ? void 0 : n.name) === t.name
    }
      , n = e=>t=>(e=>{
        const t = typeof e;
        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && o(e, String, ((e,t)=>t.isPrototypeOf(e))) ? "string" : t
    }
    )(t) === e
      , r = e=>t=>typeof t === e
      , s = e=>t=>e === t
      , a = n("string")
      , i = n("object")
      , c = e=>((e,n)=>i(e) && o(e, n, ((e,o)=>t(e) === o)))(e, Object)
      , l = s(null)
      , m = r("boolean")
      , d = s(void 0)
      , u = r("function")
      , h = r("number");
    class _ {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new _(!0,e)
        }
        static none() {
            return _.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? _.some(e(this.value)) : _.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : _.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : _.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return null == e ? _.none() : _.some(e)
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    _.singletonNone = new _(!1);
    const v = e=>parseInt(e, 10)
      , p = (e,t)=>{
        const o = e - t;
        return 0 === o ? 0 : o > 0 ? 1 : -1
    }
      , g = (e,t,o)=>({
        major: e,
        minor: t,
        patch: o
    })
      , y = e=>{
        const t = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(e);
        return t ? g(v(t[1]), v(t[2]), v(t[3])) : g(0, 0, 0)
    }
    ;
    let f = 0;
    const b = e=>{
        const t = (new Date).getTime()
          , o = Math.floor(1e9 * Math.random());
        return f++,
        e + "_" + o + f + String(t)
    }
      , w = ()=>{}
      , C = e=>()=>e
      , S = e=>e
      , O = e=>e()
      , x = C(!1)
      , A = C(!0)
      , D = Array.prototype.indexOf
      , E = (e,t)=>{
        const o = e.length
          , n = new Array(o);
        for (let r = 0; r < o; r++) {
            const o = e[r];
            n[r] = t(o, r)
        }
        return n
    }
      , R = (e,t)=>{
        for (let o = 0, n = e.length; o < n; o++)
            t(e[o], o)
    }
      , k = (e,t)=>{
        const o = [];
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            t(r, n) && o.push(r)
        }
        return o
    }
      , T = (e,t)=>((e,t,o)=>{
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (t(r, n))
                return _.some(r);
            if (o(r, n))
                break
        }
        return _.none()
    }
    )(e, t, x)
      , M = (e,t)=>t >= 0 && t < e.length ? _.some(e[t]) : _.none()
      , L = Object.keys
      , U = Object.hasOwnProperty
      , N = (e,t)=>{
        const o = L(e);
        for (let n = 0, r = o.length; n < r; n++) {
            const r = o[n];
            t(e[r], r)
        }
    }
      , j = (e,t)=>P(e, ((e,o)=>({
        k: o,
        v: t(e, o)
    })))
      , P = (e,t)=>{
        const o = {};
        return N(e, ((e,n)=>{
            const r = t(e, n);
            o[r.k] = r.v
        }
        )),
        o
    }
      , I = (e,t)=>U.call(e, t);
    "undefined" != typeof window ? window : Function("return this;")();
    const $ = e=>t=>(e=>e.dom.nodeType)(t) === e
      , F = $(1)
      , H = $(9)
      , B = (e,t,o)=>{
        if (!(a(o) || m(o) || h(o)))
            throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e),
            new Error("Attribute value was not simple");
        e.setAttribute(t, o + "")
    }
      , V = (e,t,o)=>{
        B(e.dom, t, o)
    }
      , Y = (e,t)=>{
        const o = e.dom.getAttribute(t);
        return null === o ? void 0 : o
    }
      , W = (e,t)=>_.from(Y(e, t))
      , G = (e,t)=>{
        e.dom.removeAttribute(t)
    }
      , q = (e,t)=>-1 !== e.indexOf(t)
      , z = e=>t=>t.replace(e, "")
      , J = z(/^\s+|\s+$/g)
      , K = z(/^\s+/g)
      , Q = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , X = (e,t)=>{
        const o = (t || document).createElement("div");
        if (o.innerHTML = e,
        !o.hasChildNodes() || o.childNodes.length > 1) {
            const t = "HTML does not have a single root node";
            throw console.error(t, e),
            new Error(t)
        }
        return Q(o.childNodes[0])
    }
      , Z = (e,t)=>{
        const o = (t || document).createElement(e);
        return Q(o)
    }
      , ee = Q
      , te = e=>1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount
      , oe = e=>ee(e.dom.ownerDocument)
      , ne = e=>_.from(e.dom.parentNode).map(ee)
      , re = e=>E(e.dom.childNodes, ee)
      , se = u(Element.prototype.attachShadow) && u(Node.prototype.getRootNode) ? e=>ee(e.dom.getRootNode()) : e=>H(e) ? e : oe(e)
      , ae = ()=>ie(ee(document))
      , ie = e=>{
        const t = e.dom.body;
        if (null == t)
            throw new Error("Body is not available yet");
        return ee(t)
    }
      , ce = (e,t)=>{
        e.dom.appendChild(t.dom)
    }
      , le = e=>{
        e.dom.textContent = "",
        R(re(e), (e=>{
            me(e)
        }
        ))
    }
      , me = e=>{
        const t = e.dom;
        null !== t.parentNode && t.parentNode.removeChild(t)
    }
      , de = e=>{
        const t = re(e);
        var o, n;
        t.length > 0 && (o = e,
        R(n = t, ((e,t)=>{
            ((e,t)=>{
                const o = (e=>_.from(e.dom.nextSibling).map(ee))(e);
                o.fold((()=>{
                    ne(e).each((e=>{
                        ce(e, t)
                    }
                    ))
                }
                ), (e=>{
                    ((e,t)=>{
                        ne(e).each((o=>{
                            o.dom.insertBefore(t.dom, e.dom)
                        }
                        ))
                    }
                    )(e, t)
                }
                ))
            }
            )(0 === t ? o : n[t - 1], e)
        }
        ))),
        me(e)
    }
      , ue = e=>e.dom.innerHTML
      , he = (e,t)=>{
        const o = oe(e).dom
          , n = ee(o.createDocumentFragment());
        ((e,t)=>{
            R(t, (t=>{
                ce(e, t)
            }
            ))
        }
        )(n, ((e,t)=>{
            const o = (t || document).createElement("div");
            return o.innerHTML = e,
            re(ee(o))
        }
        )(t, o)),
        le(e),
        ce(e, n)
    }
      , _e = e=>{
        let t, o = !1;
        return (...n)=>(o || (o = !0,
        t = e.apply(null, n)),
        t)
    }
      , ve = ()=>pe(0, 0)
      , pe = (e,t)=>({
        major: e,
        minor: t
    })
      , ge = {
        nu: pe,
        detect: (e,t)=>{
            const o = String(t).toLowerCase();
            return 0 === e.length ? ve() : ((e,t)=>{
                const o = ((e,t)=>{
                    for (let o = 0; o < e.length; o++) {
                        const n = e[o];
                        if (n.test(t))
                            return n
                    }
                }
                )(e, t);
                if (!o)
                    return {
                        major: 0,
                        minor: 0
                    };
                const n = e=>Number(t.replace(o, "$" + e));
                return pe(n(1), n(2))
            }
            )(e, o)
        }
        ,
        unknown: ve
    }
      , ye = (e,t)=>{
        const o = String(t).toLowerCase();
        return T(e, (e=>e.search(o)))
    }
      , fe = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/
      , be = e=>t=>q(t, e)
      , we = [{
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: e=>q(e, "edge/") && q(e, "chrome") && q(e, "safari") && q(e, "applewebkit")
    }, {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, fe],
        search: e=>q(e, "chrome") && !q(e, "chromeframe")
    }, {
        name: "IE",
        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
        search: e=>q(e, "msie") || q(e, "trident")
    }, {
        name: "Opera",
        versionRegexes: [fe, /.*?opera\/([0-9]+)\.([0-9]+).*/],
        search: be("opera")
    }, {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: be("firefox")
    }, {
        name: "Safari",
        versionRegexes: [fe, /.*?cpu os ([0-9]+)_([0-9]+).*/],
        search: e=>(q(e, "safari") || q(e, "mobile/")) && q(e, "applewebkit")
    }]
      , Ce = [{
        name: "Windows",
        search: be("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "iOS",
        search: e=>q(e, "iphone") || q(e, "ipad"),
        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
    }, {
        name: "Android",
        search: be("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "macOS",
        search: be("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    }, {
        name: "Linux",
        search: be("linux"),
        versionRegexes: []
    }, {
        name: "Solaris",
        search: be("sunos"),
        versionRegexes: []
    }, {
        name: "FreeBSD",
        search: be("freebsd"),
        versionRegexes: []
    }, {
        name: "ChromeOS",
        search: be("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }]
      , Se = {
        browsers: C(we),
        oses: C(Ce)
    }
      , Oe = "Edge"
      , xe = "Chromium"
      , Ae = "Opera"
      , De = "Firefox"
      , Ee = "Safari"
      , Re = e=>{
        const t = e.current
          , o = e.version
          , n = e=>()=>t === e;
        return {
            current: t,
            version: o,
            isEdge: n(Oe),
            isChromium: n(xe),
            isIE: n("IE"),
            isOpera: n(Ae),
            isFirefox: n(De),
            isSafari: n(Ee)
        }
    }
      , ke = ()=>Re({
        current: void 0,
        version: ge.unknown()
    })
      , Te = Re
      , Me = (C(Oe),
    C(xe),
    C("IE"),
    C(Ae),
    C(De),
    C(Ee),
    "Windows")
      , Le = "Android"
      , Ue = "Linux"
      , Ne = "macOS"
      , je = "Solaris"
      , Pe = "FreeBSD"
      , Ie = "ChromeOS"
      , $e = e=>{
        const t = e.current
          , o = e.version
          , n = e=>()=>t === e;
        return {
            current: t,
            version: o,
            isWindows: n(Me),
            isiOS: n("iOS"),
            isAndroid: n(Le),
            isMacOS: n(Ne),
            isLinux: n(Ue),
            isSolaris: n(je),
            isFreeBSD: n(Pe),
            isChromeOS: n(Ie)
        }
    }
      , Fe = ()=>$e({
        current: void 0,
        version: ge.unknown()
    })
      , He = $e
      , Be = (C(Me),
    C("iOS"),
    C(Le),
    C(Ue),
    C(Ne),
    C(je),
    C(Pe),
    C(Ie),
    (e,t,o)=>{
        const n = Se.browsers()
          , r = Se.oses()
          , s = t.bind((e=>((e,t)=>((e,t)=>{
            for (let o = 0; o < e.length; o++) {
                const n = t(e[o]);
                if (n.isSome())
                    return n
            }
            return _.none()
        }
        )(t.brands, (t=>{
            const o = t.brand.toLowerCase();
            return T(e, (e=>{
                var t;
                return o === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
            }
            )).map((e=>({
                current: e.name,
                version: ge.nu(parseInt(t.version, 10), 0)
            })))
        }
        )))(n, e))).orThunk((()=>((e,t)=>ye(e, t).map((e=>{
            const o = ge.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: o
            }
        }
        )))(n, e))).fold(ke, Te)
          , a = ((e,t)=>ye(e, t).map((e=>{
            const o = ge.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: o
            }
        }
        )))(r, e).fold(Fe, He)
          , i = ((e,t,o,n)=>{
            const r = e.isiOS() && !0 === /ipad/i.test(o)
              , s = e.isiOS() && !r
              , a = e.isiOS() || e.isAndroid()
              , i = a || n("(pointer:coarse)")
              , c = r || !s && a && n("(min-device-width:768px)")
              , l = s || a && !c
              , m = t.isSafari() && e.isiOS() && !1 === /safari/i.test(o)
              , d = !l && !c && !m;
            return {
                isiPad: C(r),
                isiPhone: C(s),
                isTablet: C(c),
                isPhone: C(l),
                isTouch: C(i),
                isAndroid: e.isAndroid,
                isiOS: e.isiOS,
                isWebView: C(m),
                isDesktop: C(d)
            }
        }
        )(a, s, e, o);
        return {
            browser: s,
            os: a,
            deviceType: i
        }
    }
    )
      , Ve = e=>window.matchMedia(e).matches
      , Ye = _e((()=>Be(navigator.userAgent, _.from(navigator.userAgentData), Ve)))().os.isMacOS() ? "\u2318" : "Ctrl"
      , We = j({
        tc_menu_name: "TinyComments",
        tc_conversations_title: "Comments",
        tc_announce_sidebar_available: `Comment. Sidebar available. Press ${Ye} + Alt + M to switch to sidebar`,
        tc_items_addcomment: "Add comment",
        tc_items_showcomments: "Show comments",
        tc_items_deleteall: "Delete all conversations",
        tc_edit_buttons_save: "Save",
        tc_edit_buttons_cancel: "Cancel",
        tc_reply_buttons_comment: "Comment",
        tc_reply_buttons_clear: "Clear",
        tc_reply_placeholders: "Add comment...",
        tc_kebab_delete_conversation: "Delete conversation",
        tc_kebab_resolve_conversation: "Resolve conversation",
        tc_kebab_delete: "Delete",
        tc_kebab_edit: "Edit",
        tc_edit_problem_comment: "An error occurred editing this comment. See the console for details.",
        tc_edit_unauthorised_comment: "You are not allowed to edit this comment",
        tc_delete_buttons_cancel: "Cancel",
        tc_delete_buttons_proceed: "Delete",
        tc_resolve_buttons_proceed: "Resolve",
        tc_create_problem: "An error occurred while creating a comment. See the console for details",
        tc_reply_problem: "An error occurred while replying to a comment. See the console for details",
        tc_delete_prompts_conversation: "Delete this conversation?",
        tc_delete_prompts_conversation_detail_sing: "1 comment will be deleted. You can't undo this action.",
        tc_delete_prompts_conversation_detail_pl: "{0} comments will be deleted. You can't undo this action.",
        tc_delete_prompts_all: "Delete all conversations in the content? This cannot be undone.",
        tc_delete_prompts_comment: "Are you sure you want to delete this comment?",
        tc_resolve_prompts_conversation: "Resolve this conversation?",
        tc_resolve_prompts_conversation_detail_sing: "1 comment will be resolved. You can't undo this action.",
        tc_resolve_prompts_conversation_detail_pl: "{0} comments will be resolved. You can't undo this action.",
        tc_delete_problem_all: "An error occurred deleting all the conversations. See the console for details.",
        tc_delete_problem_conversation: "An error occurred deleting the conversation. See the console for details.",
        tc_delete_problem_comment: "An error occurred deleting the comment. See the console for details.",
        tc_delete_unauthorised_all: "You are not allowed to delete all the conversations",
        tc_delete_unauthorised_conversation: "You are not allowed to delete this conversation",
        tc_delete_unauthorised_comment: "You are not allowed to delete this comment",
        tc_resolve_unauthorised_conversation: "You are not allowed to resolve this conversation",
        tc_resolve_problem_conversation: "An error occurred resolving the conversation. See the console for details.",
        tc_date_less_than_a_minute_ago: "a moment ago",
        tc_date_1_minute_ago: "1 minute ago",
        tc_date_x_minutes_ago: "{0} minutes ago",
        tc_date_1_hour_ago: "1 hour ago",
        tc_date_x_hours_ago: "{0} hours ago",
        tc_date_1_day_ago: "1 day ago",
        tc_date_x_days_ago: "{0} days ago",
        tc_date_1_week_ago: "1 week ago",
        tc_date_x_weeks_ago: "{0} weeks ago",
        tc_date_1_month_ago: "1 month ago",
        tc_date_x_months_ago: "{0} months ago",
        tc_date_1_year_ago: "1 year ago",
        tc_date_x_years_ago: "{0} years ago",
        tc_date_comment_edited: " (edited)",
        tc_comment_buttons_showmore: "SHOW MORE",
        tc_comment_buttons_showless: "SHOW LESS"
    }, S)
      , Ge = b("aria-comment-description");
    let qe = 0;
    const ze = e=>{
        const t = (o = ae(),
        n = `#${Ge}`,
        ((e,t)=>{
            const o = void 0 === t ? document : t.dom;
            return te(o) ? _.none() : _.from(o.querySelector(e)).map(ee)
        }
        )(n, o)).getOrThunk((()=>{
            const e = Z("span");
            return ((e,t)=>{
                const o = e.dom;
                N(t, ((e,t)=>{
                    B(o, t, e)
                }
                ))
            }
            )(e, {
                id: Ge,
                "aria-live": "polite",
                "aria-atomic": "true",
                role: "alert"
            }),
            ((e,t)=>{
                const o = e.dom;
                N({
                    position: "absolute",
                    left: "-10000px",
                    top: "-1000px"
                }, ((e,t)=>{
                    ((e,t,o)=>{
                        if (!a(o))
                            throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", o, ":: Element ", e),
                            new Error("CSS value must be a string: " + o);
                        (e=>void 0 !== e.style && u(e.style.getPropertyValue))(e) && e.style.setProperty(t, o)
                    }
                    )(o, t, e)
                }
                ))
            }
            )(e),
            ce(ae(), e),
            e
        }
        ));
        var o, n;
        return qe++,
        ((e,t)=>({
            onComment: ()=>{
                he(t, e.translate(We.tc_announce_sidebar_available))
            }
            ,
            notOnComment: ()=>{
                he(t, "")
            }
            ,
            getMarker: ()=>t,
            release: ()=>{
                qe--,
                0 === qe && me(t)
            }
        }))(e, t)
    }
      , Je = (e,t)=>((e,t)=>{
        const o = void 0 === t ? document : t.dom;
        return te(o) ? [] : E(o.querySelectorAll(e), ee)
    }
    )(t, e)
      , Ke = _e((()=>document.implementation.createHTMLDocument("undo")))
      , Qe = e=>"fragmented" === e.type ? e.fragments.join("") : e.content
      , Xe = e=>{
        const t = Z("body", Ke());
        return he(t, Qe(e)),
        R(Je(t, "*[data-mce-bogus]"), de),
        ue(t)
    }
      , Ze = t=>{
        const o = e(null);
        return t.on("change AddUndo", (e=>o.set({
            ...e.level
        }))),
        {
            fireIfChanged: ()=>{
                const e = t.undoManager.data;
                var n;
                (n = e,
                M(n, n.length - 1)).filter((e=>{
                    return t = o.get(),
                    n = e,
                    !(t && n && (((e,t)=>Qe(e) === Qe(t))(t, n) || ((e,t)=>Xe(e) === Xe(t))(t, n)));
                    var t, n
                }
                )).each((o=>{
                    t.setDirty(!0),
                    t.dispatch("change", {
                        level: o,
                        lastLevel: M(e, e.length - 2).getOrNull()
                    })
                }
                ))
            }
        }
    }
      , et = ()=>(new Date).toISOString();
    var tt;
    !function(e) {
        e[e.LessThanMinute = 0] = "LessThanMinute",
        e[e.Minute = 1] = "Minute",
        e[e.Hour = 2] = "Hour",
        e[e.Day = 3] = "Day",
        e[e.Week = 4] = "Week",
        e[e.Month = 5] = "Month",
        e[e.Year = 6] = "Year"
    }(tt || (tt = {}));
    const ot = (e,t="")=>{
        const o = e.get()
          , n = "" === t ? 0 : Date.parse(t);
        return {
            timestamp: et(),
            events: n > 0 ? k(o, (e=>Date.parse(e.timestamp) > n)) : o
        }
    }
      , nt = e=>(t={})=>a(t.after) ? ot(e, t.after) : ot(e)
      , rt = (e,t)=>{
        const o = Y(e, t);
        return void 0 === o || "" === o ? [] : o.split(" ")
    }
      , st = e=>void 0 !== e.dom.classList
      , at = (e,t)=>{
        st(e) ? e.dom.classList.remove(t) : ((e,t)=>{
            ((e,t,o)=>{
                const n = k(rt(e, t), (e=>e !== o));
                n.length > 0 ? V(e, t, n.join(" ")) : G(e, t)
            }
            )(e, "class", t)
        }
        )(e, t),
        (e=>{
            const t = st(e) ? e.dom.classList : (e=>rt(e, "class"))(e);
            0 === t.length && G(e, "class")
        }
        )(e)
    }
      , it = C("tox-comment")
      , ct = C("tinycomments")
      , lt = C("mce-annotation")
      , mt = C("data-mce-annotation")
      , dt = C("data-mce-annotation-uid")
      , ut = C("data-mce-annotation-active")
      , ht = C("data-mce-annotation-classes")
      , _t = C("data-mce-annotation-attrs")
      , vt = C("tox-comments-visible")
      , pt = ("span",
    e=>F(e) && "span" === e.dom.nodeName.toLowerCase());
    const gt = e=>{
        pt(e) ? de(e) : (e=>{
            at(e, lt()),
            G(e, `${dt()}`),
            G(e, `${mt()}`),
            G(e, `${ut()}`);
            const t = W(e, `${_t()}`).map((e=>e.split(","))).getOr([])
              , o = W(e, `${ht()}`).map((e=>e.split(","))).getOr([]);
            var n;
            R(t, (t=>G(e, t))),
            n = e,
            R(o, (e=>{
                at(n, e)
            }
            )),
            G(e, `${ht()}`),
            G(e, `${_t()}`)
        }
        )(e)
    }
      , yt = (e,t,o,n)=>(he(e, t),
    R(Je(e, o), n),
    e.dom.innerHTML)
      , ft = (e,t,o)=>{
        const n = Z("div");
        R(e, (e=>{
            e.content = yt(n, e.content, t, o),
            R(e.fragments || [], ((r,s)=>{
                e.fragments[s] = yt(n, e.fragments[s], t, o)
            }
            ))
        }
        ))
    }
      , bt = "tc-open-comment"
      , wt = "tc-try-delete-all-conversations"
      , Ct = (e,t,o,n,r,s)=>{
        e.on("init", (()=>{
            ((e,t,o)=>{
                e.addCommand(bt, ((e,n)=>{
                    const r = o.get();
                    t.refreshSidebar(r, n.grabFocus ? 1 : 0)
                }
                ))
            }
            )(e, t, r),
            ((e,t,o)=>{
                e.addCommand("tc-delete-conversation-at-cursor", ((n,r)=>{
                    var s, a;
                    e.undoManager.transact((()=>e.annotator.remove(ct()))),
                    s = e.undoManager.data,
                    a = r.conversationUid,
                    ft(s, (e=>`[${dt()}="${e}"]`)(a), gt),
                    o.fireIfChanged(),
                    t.refreshSidebar(_.none(), 2),
                    e.focus()
                }
                ))
            }
            )(e, t, s),
            ((e,t,o,n,r)=>{
                e.addCommand(wt, (()=>{
                    e.windowManager.confirm(We.tc_delete_prompts_all, (s=>{
                        if (s)
                            return o.deleteAllConversations({}).get((o=>{
                                o.fold((e=>t.showError(We.tc_delete_problem_all, e)), (o=>{
                                    var s;
                                    o.canDelete ? (n({
                                        type: "delete-all-conversations",
                                        timestamp: et()
                                    }),
                                    e.annotator.removeAll(ct()),
                                    s = e.undoManager.data,
                                    ft(s, `[${mt()}="${ct()}"]`, gt),
                                    r.fireIfChanged(),
                                    t.refreshSidebar(_.none(), 2),
                                    e.focus()) : t.showError(We.tc_delete_unauthorised_all)
                                }
                                ))
                            }
                            ))
                    }
                    ))
                }
                ))
            }
            )(e, t, o, n, s)
        }
        ))
    }
      , St = (e,t)=>{
        e.execCommand(bt, null, {
            grabFocus: t
        }, {
            skip_focus: !t
        })
    }
      , Ot = e=>{
        e.execCommand("ToggleSidebar", null, "showcomments")
    }
      , xt = e=>{
        let t = _.none()
          , o = [];
        const n = e=>{
            r() ? s(e) : o.push(e)
        }
          , r = ()=>t.isSome()
          , s = e=>{
            t.each((t=>{
                setTimeout((()=>{
                    e(t)
                }
                ), 0)
            }
            ))
        }
        ;
        return e((e=>{
            r() || (t = _.some(e),
            R(o, s),
            o = [])
        }
        )),
        {
            get: n,
            map: e=>xt((t=>{
                n((o=>{
                    t(e(o))
                }
                ))
            }
            )),
            isReady: r
        }
    }
      , At = {
        nu: xt,
        pure: e=>xt((t=>{
            t(e)
        }
        ))
    }
      , Dt = e=>{
        setTimeout((()=>{
            throw e
        }
        ), 0)
    }
      , Et = e=>{
        const t = t=>{
            e().then(t, Dt)
        }
        ;
        return {
            map: t=>Et((()=>e().then(t))),
            bind: t=>Et((()=>e().then((e=>t(e).toPromise())))),
            anonBind: t=>Et((()=>e().then((()=>t.toPromise())))),
            toLazy: ()=>At.nu(t),
            toCached: ()=>{
                let t = null;
                return Et((()=>(null === t && (t = e()),
                t)))
            }
            ,
            toPromise: e,
            get: t
        }
    }
      , Rt = e=>Et((()=>new Promise(e)))
      , kt = e=>Et((()=>Promise.resolve(e)))
      , Tt = e=>{
        const t = t=>t(e)
          , o = C(e)
          , n = ()=>r
          , r = {
            tag: !0,
            inner: e,
            fold: (t,o)=>o(e),
            isValue: A,
            isError: x,
            map: t=>Lt.value(t(e)),
            mapError: n,
            bind: t,
            exists: t,
            forall: t,
            getOr: o,
            or: n,
            getOrThunk: o,
            orThunk: n,
            getOrDie: o,
            each: t=>{
                t(e)
            }
            ,
            toOptional: ()=>_.some(e)
        };
        return r
    }
      , Mt = e=>{
        const t = ()=>o
          , o = {
            tag: !1,
            inner: e,
            fold: (t,o)=>t(e),
            isValue: x,
            isError: A,
            map: t,
            mapError: t=>Lt.error(t(e)),
            bind: t,
            exists: x,
            forall: A,
            getOr: S,
            or: S,
            getOrThunk: O,
            orThunk: O,
            getOrDie: (n = String(e),
            ()=>{
                throw new Error(n)
            }
            ),
            each: w,
            toOptional: _.none
        };
        var n;
        return o
    }
      , Lt = {
        value: Tt,
        error: Mt,
        fromOption: (e,t)=>e.fold((()=>Mt(t)), Tt)
    }
      , Ut = e=>({
        ...e,
        toCached: ()=>Ut(e.toCached()),
        bindFuture: t=>Ut(e.bind((e=>e.fold((e=>kt(Lt.error(e))), (e=>t(e)))))),
        bindResult: t=>Ut(e.map((e=>e.bind(t)))),
        mapResult: t=>Ut(e.map((e=>e.map(t)))),
        mapError: t=>Ut(e.map((e=>e.mapError(t)))),
        foldResult: (t,o)=>e.map((e=>e.fold(t, o))),
        withTimeout: (t,o)=>Ut(Rt((n=>{
            let r = !1;
            const s = setTimeout((()=>{
                r = !0,
                n(Lt.error(o()))
            }
            ), t);
            e.get((e=>{
                r || (clearTimeout(s),
                n(e))
            }
            ))
        }
        )))
    })
      , Nt = e=>Ut(Rt(e))
      , jt = e=>Ut(kt(Lt.value(e)))
      , Pt = e=>Ut(kt(Lt.error(e)))
      , It = e=>t=>Nt((o=>e(t, (e=>{
        o(Lt.value(e))
    }
    ), (e=>{
        o(Lt.error(e))
    }
    ))))
      , $t = e=>t=>t.options.get(e)
      , Ft = e=>t=>_.from($t(e)(t)).filter(u)
      , Ht = e=>t=>Ft(e)(t).getOrDie(e + " has not been implemented.")
      , Bt = (e,t)=>o=>{
        var n;
        return null !== (n = o.options.get(e)) && void 0 !== n ? n : t(o)
    }
      , Vt = (e,t)=>o=>{
        const n = Bt(e, (()=>t(Xt(o))))(o);
        return It(n)
    }
      , Yt = Ht("tinycomments_create")
      , Wt = Ht("tinycomments_reply")
      , Gt = Ht("tinycomments_delete")
      , qt = Ft("tinycomments_resolve")
      , zt = Ht("tinycomments_delete_all")
      , Jt = Ht("tinycomments_delete_comment")
      , Kt = Ht("tinycomments_edit_comment")
      , Qt = Ht("tinycomments_lookup")
      , Xt = $t("tinycomments_author")
      , Zt = Bt("tinycomments_author_name", Xt)
      , eo = $t("tinycomments_author_avatar")
      , to = Vt("tinycomments_can_delete", (e=>(t,o,n)=>{
        o({
            canDelete: t.comments.length > 0 && t.comments[0].author === e && !0
        })
    }
    ))
      , oo = Ft("tinycomments_can_resolve")
      , no = Vt("tinycomments_can_delete_comment", (e=>(t,o,n)=>{
        o({
            canDelete: t.comment.author === e && !0
        })
    }
    ))
      , ro = Vt("tinycomments_can_edit_comment", (e=>(t,o,n)=>{
        o({
            canEdit: t.comment.author === e && !0
        })
    }
    ))
      , so = $t("tinycomments_mode")
      , ao = $t("tinycomments_css_url")
      , io = $t("tinycomments_js_url")
      , co = (lo = (e,t)=>c(e) && c(t) ? co(e, t) : t,
    (...e)=>{
        if (0 === e.length)
            throw new Error("Can't merge zero objects");
        const t = {};
        for (let o = 0; o < e.length; o++) {
            const n = e[o];
            for (const e in n)
                I(n, e) && (t[e] = lo(t[e], n[e]))
        }
        return t
    }
    );
    var lo;
    const mo = e=>{
        const t = Yt(e)
          , o = Wt(e)
          , n = Qt(e)
          , r = Gt(e)
          , s = qt(e)
          , a = zt(e)
          , i = Jt(e)
          , c = Kt(e);
        return {
            create: It(t),
            reply: It(o),
            lookup: It((l = n,
            (e,t,o)=>{
                l(e, (e=>{
                    const o = E(e.conversation.comments, (e=>({
                        authorName: e.author,
                        ...e
                    })));
                    t(co(e, {
                        conversation: {
                            comments: o
                        }
                    }))
                }
                ), o)
            }
            )),
            deleteConversation: It(r),
            resolveConversation: s.map((e=>It(e))),
            deleteAllConversations: It(a),
            editComment: It(c),
            deleteComment: It(i),
            lifecycleHooks: {
                onPreInit: w,
                onGetContent: _.none
            }
        };
        var l
    }
      , uo = {
        base64: {
            versions: ["2.0", "2.1"],
            encryptor: {
                encryptText: e=>{
                    const t = new Blob([e],{
                        type: "application/json"
                    })
                      , o = new FileReader;
                    return Nt((e=>{
                        o.addEventListener("loadend", (()=>e(Lt.value({
                            encrypted: [o.result]
                        })))),
                        o.addEventListener("error", (()=>e(Lt.error(o.error)))),
                        o.readAsDataURL(t)
                    }
                    ))
                }
                ,
                decryptText: e=>{
                    return (t = e[0],
                    (e=>{
                        const t = e.split(",")
                          , o = /data:([^;]+)/.exec(t[0]);
                        if (!o)
                            return _.none();
                        const n = o[1]
                          , r = t[1]
                          , s = 1024
                          , a = atob(r)
                          , i = a.length
                          , c = Math.ceil(i / s)
                          , l = new Array(c);
                        for (let e = 0; e < c; ++e) {
                            const t = e * s
                              , o = Math.min(t + s, i)
                              , n = new Array(o - t);
                            for (let e = t, r = 0; e < o; ++r,
                            ++e)
                                n[r] = a[e].charCodeAt(0);
                            l[e] = new Uint8Array(n)
                        }
                        return _.some(new Blob(l,{
                            type: n
                        }))
                    }
                    )(t)).fold((()=>Pt("Could not decode URI")), (e=>{
                        const t = new FileReader;
                        return Nt((o=>{
                            t.addEventListener("loadend", (()=>o(Lt.value({
                                decrypted: t.result
                            })))),
                            t.addEventListener("error", (()=>o(Lt.error(t.error.message)))),
                            t.readAsText(e)
                        }
                        ))
                    }
                    ));
                    var t
                }
            }
        }
    };
    uo.current = uo.base64;
    const ho = e=>((e,t)=>{
        const o = L(e);
        for (let n = 0, r = o.length; n < r; n++) {
            const r = o[n]
              , s = e[r];
            if (t(s))
                return _.some(s)
        }
        return _.none()
    }
    )(uo, (t=>{
        return o = t.versions,
        n = o,
        r = e,
        D.call(n, r) > -1;
        var o, n, r
    }
    )).map((e=>e.encryptor))
      , _o = (e,t,o)=>t === e ? o : "2.0" === e ? _o("2.1", t, (e=>({
        ...e,
        authorName: e.author
    }))(o)) : o
      , vo = "tinycomments"
      , po = "2.1"
      , go = e=>{
        return t = K(e),
        "" === (o = vo) || t.length >= o.length && t.substr(0, 0 + o.length) === o;
        var t, o
    }
      , yo = e=>{
        const t = J(e).split("|");
        return t.length > 2 ? Lt.value({
            version: t[1],
            rest: t.slice(2)
        }) : Lt.error("Embedded comments not in expected format.")
    }
      , fo = (e,t,o)=>((e,t)=>{
        const o = (e=>{
            try {
                const t = JSON.parse(e);
                return Lt.value(t)
            } catch (e) {
                return Lt.error("Could not JSON parse conversations.")
            }
        }
        )(t);
        return e !== po ? o.map((t=>j(t, (t=>({
            ...t,
            comments: E(t.comments, (t=>_o(e, po, t)))
        }))))) : o
    }
    )(e, o).map((e=>({
        conversations: e,
        encrypted: {
            encrypted: t
        }
    })))
      , bo = e=>{
        const t = Xt(e)
          , o = Zt(e)
          , n = eo(e)
          , r = (()=>{
            let e = {}
              , t = _.none();
            const o = t=>Object.prototype.hasOwnProperty.call(e, t) ? _.some(e[t]) : _.none();
            return {
                get: ()=>co(e, {}),
                clear: ()=>{
                    e = {},
                    t = _.none()
                }
                ,
                addData: (t,o)=>{
                    e[t] = o
                }
                ,
                setData: (o,n)=>{
                    e = o,
                    t = _.some(n)
                }
                ,
                setEncryptedData: e=>{
                    t = _.some(e)
                }
                ,
                getEncryptedData: ()=>t,
                lookupData: o,
                removeData: t=>{
                    delete e[t]
                }
                ,
                updateData: (t,n)=>o(t).map((o=>{
                    const r = n(o);
                    return e[t] = r,
                    r
                }
                ))
            }
        }
        )()
          , s = to(e)
          , a = no(e)
          , i = ro(e)
          , c = oo(e).map((e=>It(e)))
          , l = {
            author: t,
            authorName: o
        }
          , m = ((e,t)=>{
            const o = {};
            var n;
            return ((e,t,o,n)=>{
                N(e, ((e,r)=>{
                    (t(e, r) ? o : n)(e, r)
                }
                ))
            }
            )(e, t, (n = o,
            (e,t)=>{
                n[t] = e
            }
            ), w),
            o
        }
        )({
            authorAvatar: n
        }, (e=>!d(e)))
          , u = uo.current.encryptor
          , h = ()=>u.encryptText(JSON.stringify(r.get())).mapResult((e=>r.setEncryptedData(e)))
          , v = c.map((e=>t=>r.lookupData(t.conversationUid).fold((()=>Pt("Could not find conversation to resolve")), (o=>e({
            conversationUid: o.uid,
            comments: o.comments
        }).bindFuture((e=>e.canResolve ? (r.removeData(t.conversationUid),
        h().mapResult((()=>({
            canResolve: !0
        })))) : jt({
            canResolve: !1
        })))))))
          , p = (e,t,o,n)=>(e=>r.lookupData(e.conversationUid).fold((()=>Lt.error(`Could not find conversation with uid ${e.conversationUid}`)), (t=>T(t.comments, (t=>t.uid === e.commentUid)).fold((()=>Lt.error(`Could not find comment with uid ${e.commentUid} in conversation ${e.conversationUid}`)), (e=>Lt.value({
            conversationUid: t.uid,
            comment: e
        }))))))(e).fold((e=>Pt(e)), (s=>o(s).bindFuture((o=>!0 === o[t] ? r.updateData(e.conversationUid, n(s)).fold((()=>Pt("Could not operate on comment (" + t + ")")), (e=>h().mapResult((()=>({
            [t]: !0
        }))))) : jt({
            [t]: !1
        })))));
        return {
            create: e=>{
                const t = b("mce-conversation");
                return r.addData(t, {
                    uid: t,
                    comments: [{
                        uid: t,
                        ...l,
                        ...m,
                        content: e.content,
                        createdAt: e.createdAt,
                        modifiedAt: e.createdAt
                    }]
                }),
                h().mapResult((()=>({
                    conversationUid: t
                })))
            }
            ,
            reply: e=>{
                const t = b("mce-reply")
                  , o = {
                    uid: t,
                    ...l,
                    ...m,
                    content: e.content,
                    createdAt: e.createdAt,
                    modifiedAt: e.createdAt
                };
                return r.updateData(e.conversationUid, (e=>({
                    ...e,
                    comments: e.comments.concat([o])
                }))).fold((()=>Pt("Could not reply to uid: " + e.conversationUid)), (()=>h().mapResult((()=>({
                    commentUid: t
                })))))
            }
            ,
            lookup: e=>r.lookupData(e.conversationUid).fold((()=>Pt("Could not find uid: " + e.conversationUid)), (e=>jt({
                conversation: e
            }))),
            deleteConversation: e=>r.lookupData(e.conversationUid).fold((()=>Pt("Could not find conversation to delete")), (t=>s({
                conversationUid: t.uid,
                comments: t.comments
            }).bindFuture((t=>t.canDelete ? (r.removeData(e.conversationUid),
            h().mapResult((()=>({
                canDelete: !0
            })))) : jt({
                canDelete: !1
            }))))),
            resolveConversation: v,
            deleteAllConversations: ()=>{
                const e = L(r.get())
                  , t = E(e, (e=>r.lookupData(e).fold((()=>Pt("Could not find conversation")), (e=>s({
                    conversationUid: e.uid,
                    comments: e.comments
                })))));
                return Nt((e=>{
                    var o;
                    (o = t,
                    ((e,t)=>t((t=>{
                        const o = [];
                        let n = 0;
                        0 === e.length ? t([]) : R(e, ((r,s)=>{
                            r.get((r=>s=>{
                                o[r] = s,
                                n++,
                                n >= e.length && t(o)
                            }
                            )(s))
                        }
                        ))
                    }
                    )))(o, Rt)).get((t=>{
                        const o = ((e,t)=>{
                            for (let t = 0, o = e.length; t < o; ++t)
                                if (!0 !== e[t].exists((e=>e.canDelete)))
                                    return !1;
                            return !0
                        }
                        )(t);
                        o && r.clear(),
                        e(Lt.value({
                            canDelete: o
                        }))
                    }
                    ))
                }
                ))
            }
            ,
            deleteComment: e=>p(e, "canDelete", a, (e=>{
                return t = e.comment.uid,
                e=>({
                    uid: e.uid,
                    comments: k(e.comments, (e=>e.uid !== t))
                });
                var t
            }
            )),
            editComment: e=>p(e, "canEdit", (t=>i({
                ...t,
                edit: {
                    modifiedAt: e.modifiedAt,
                    content: e.content
                }
            })), (()=>{
                return t = e.commentUid,
                o = e.content,
                n = e.modifiedAt,
                e=>({
                    uid: e.uid,
                    comments: E(e.comments, (e=>e.uid === t ? {
                        ...e,
                        content: o,
                        modifiedAt: n
                    } : e))
                });
                var t, o, n
            }
            )),
            lifecycleHooks: {
                onPreInit: t=>{
                    e.parser.addNodeFilter("#comment", ((e,t,o)=>{
                        o.isRootContent && (r.clear(),
                        R(e, (e=>{
                            const t = e.value;
                            var o;
                            go(t) && (e.remove(),
                            yo(t).each((e=>r.setEncryptedData({
                                encrypted: e.rest
                            }))),
                            (o = t,
                            go(o) ? yo(o).fold(Pt, (({version: e, rest: t})=>((e,t)=>ho(e).fold((()=>Pt(`No Encryptor for version: ${e}`)), (e=>e.decryptText(t))))(e, t).bindResult((({decrypted: o})=>fo(e, t, o))))) : jt({
                                conversations: {},
                                encrypted: {
                                    encrypted: []
                                }
                            })).get((e=>e.fold((e=>console.error("Error extracting embedded conversations: " + e)), (e=>{
                                r.setData(e.conversations, e.encrypted)
                            }
                            )))))
                        }
                        )))
                    }
                    ))
                }
                ,
                onGetContent: (e,t)=>r.getEncryptedData().map((e=>t + (e=>{
                    const t = ee(document.createComment((e=>[vo, po, ...e.encrypted].join("|"))(e)));
                    return (e=>{
                        const t = Z("div")
                          , o = ee(e.dom.cloneNode(!0));
                        return ce(t, o),
                        ue(t)
                    }
                    )(t)
                }
                )(e)))
            }
        }
    }
      , wo = (e,t,o)=>{
        e.on("init", (()=>{
            e.annotator.register(ct(), {
                decorate: ()=>({
                    classes: [it()],
                    attributes: {}
                })
            }),
            e.annotator.annotationChanged(ct(), ((e,n,r)=>{
                if (e) {
                    o.onComment();
                    const {uid: e, nodes: n} = r;
                    t.refreshView(_.some({
                        uid: e,
                        nodes: E(n, ee)
                    }))
                } else
                    o.notOnComment(),
                    t.refreshView(_.none())
            }
            ));
            const n = ((e,t)=>{
                let o = null;
                const n = ()=>{
                    l(o) || (clearTimeout(o),
                    o = null)
                }
                ;
                return {
                    cancel: n,
                    throttle: (...t)=>{
                        n(),
                        o = setTimeout((()=>{
                            o = null,
                            e.apply(null, t)
                        }
                        ), 50)
                    }
                }
            }
            )((()=>{
                t.refreshReadonly()
            }
            ));
            e.on("SelectionChange", n.throttle),
            e.on("remove", n.cancel)
        }
        ))
    }
      , Co = (e,t)=>()=>{
        var o, n;
        t.set(xo.Open),
        o = ee(e.getBody()),
        n = vt(),
        st(o) ? o.dom.classList.add(n) : ((e,t)=>{
            ((e,t,o)=>{
                const n = rt(e, t).concat([o]);
                V(e, t, n.join(" "))
            }
            )(e, "class", t)
        }
        )(o, n),
        e.dispatch("mce-tinycomments-update", {}),
        St(e, !1)
    }
      , So = (e,t)=>o=>{
        var n;
        (n = ee(o.element()),
        ((e=(()=>ee(document))())=>_.from(e.dom.activeElement).map(ee))(se(n)).filter((e=>n.dom.contains(e.dom)))).each((t=>{
            e.focus()
        }
        )),
        t.set(xo.Closed),
        at(ee(e.getBody()), vt()),
        e.dispatch("mce-tinycomments-update", {})
    }
      , Oo = (e,t)=>{
        t.get() !== xo.Closed && t.get() !== xo.Closing || Ot(e),
        St(e, !0)
    }
    ;
    var xo;
    !function(e) {
        e[e.Open = 0] = "Open",
        e[e.Closed = 1] = "Closed",
        e[e.Closing = 2] = "Closing"
    }(xo || (xo = {}));
    const Ao = (t,o)=>{
        const n = e(!1)
          , r = e(_.none())
          , s = e([]);
        ((e,t)=>{
            const o = e.options.register;
            o("tinycomments_css_url", {
                processor: "string",
                default: t + "/css"
            }),
            o("tinycomments_js_url", {
                processor: "string",
                default: t + "/js"
            }),
            o("tinycomments_mode", {
                processor: "string",
                default: "callback"
            }),
            o("tinycomments_author", {
                processor: "string",
                default: "Anon"
            }),
            o("tinycomments_author_name", {
                processor: "string"
            }),
            o("tinycomments_author_avatar", {
                processor: "string"
            }),
            R(["tinycomments_create", "tinycomments_reply", "tinycomments_lookup", "tinycomments_delete", "tinycomments_delete_all", "tinycomments_delete_comment", "tinycomments_can_delete", "tinycomments_can_delete_comment", "tinycomments_resolve", "tinycomments_can_resolve", "tinycomments_edit_comment", "tinycomments_can_edit_comment"], (e=>o(e, {
                processor: "function"
            })))
        }
        )(t, o);
        const i = (e=>("embedded" === so(e) ? bo : mo)(e))(t)
          , c = (()=>{
            const t = e(_.none())
              , o = e(_.none());
            return {
                rememberSidebar: e=>{
                    o.set(_.some(e)),
                    t.get().fold((()=>{
                        const t = X('<div aria-busy="true" class="tox-conversations" style="position: relative;">\n  <div class="tox-dialog__busy-spinner">\n  <div class="tox-loading-text">\n      <div>\n      <p>Comments are loading</p>\n      </div>\n  <div class="tox-spinner">\n      <div></div>\n      <div></div>\n      <div></div>\n  </div>\n</div></div>');
                        ce(e, t)
                    }
                    ), (t=>{
                        t.attachTo(e)
                    }
                    ))
                }
                ,
                setUi: e=>{
                    t.set(_.some(e)),
                    o.get().each((t=>{
                        le(t),
                        e.attachTo(t),
                        e.controller.refreshReadonly()
                    }
                    ))
                }
                ,
                refreshView: e=>{
                    t.get().fold(w, (t=>{
                        t.controller.refreshView(e)
                    }
                    ))
                }
                ,
                refreshSidebar: (e,o)=>{
                    t.get().fold(w, (t=>{
                        t.controller.refreshSidebar(e, o)
                    }
                    ))
                }
                ,
                setReadonly: e=>{
                    t.get().each((t=>t.controller.setReadonly(e)))
                }
                ,
                setSaving: e=>{
                    t.get().each((t=>t.controller.setSaving(e)))
                }
                ,
                showError: (e,o)=>{
                    t.get().each((t=>t.controller.showError(e, o)))
                }
                ,
                refreshReadonly: ()=>t.get().map((e=>e.controller.refreshReadonly())).getOr(!1)
            }
        }
        )()
          , l = {
            translate: e=>tinymce.translate(e),
            getIcon: e=>{
                var o;
                return null !== (o = t.ui.registry.getAll().icons[e]) && void 0 !== o ? o : "temporary-placeholder"
            }
        }
          , m = Ze(t);
        ((e,t)=>tinymce.Resource.load("tinymce.plugins.tinycomments.sidebar", t))(0, (e=>io(e) + "/")(t) + "tinycomments-sidebar.min.js").then((e=>e(t, i, r, s, (e=>{
            c.setUi(e),
            c.refreshSidebar(r.get(), 5),
            n.set(!0)
        }
        ), l)));
        const d = ze(l);
        return t.on("remove", d.release),
        Ct(t, c, i, ((e,t)=>o=>{
            const n = nt(t);
            t.set(t.get().concat([o])),
            ((e,t)=>{
                const o = {
                    getEventLog: t
                };
                e.dispatch("CommentChange", o)
            }
            )(e, n)
        }
        )(t, s), r, m),
        wo(t, c, d),
        ((t,o)=>{
            const n = e(xo.Closed);
            t.shortcuts.add("meta+alt+m", "TinyComments addComment", (()=>{
                Oo(t, n)
            }
            )),
            ((e,t,o)=>{
                const n = "comment-add";
                e.ui.registry.addButton("addcomment", {
                    tooltip: We.tc_items_addcomment,
                    icon: n,
                    onAction: ()=>{
                        Oo(e, o)
                    }
                }),
                e.ui.registry.addMenuItem("addcomment", {
                    text: We.tc_items_addcomment,
                    shortcut: "meta+Alt+M",
                    icon: n,
                    onAction: ()=>{
                        Oo(e, o)
                    }
                }),
                e.ui.registry.addMenuItem("deleteallconversations", {
                    text: We.tc_items_deleteall,
                    onAction: ()=>{
                        (e=>{
                            e.execCommand(wt, null, {})
                        }
                        )(e)
                    }
                }),
                e.ui.registry.addToggleMenuItem("showcomments", {
                    text: We.tc_items_showcomments,
                    icon: "comment",
                    onAction: ()=>{
                        Ot(e)
                    }
                    ,
                    onSetup: t=>{
                        const n = ()=>{
                            t.setActive(o.get() === xo.Open)
                        }
                        ;
                        return e.on("mce-tinycomments-update", n),
                        n(),
                        ()=>{
                            e.off("mce-tinycomments-update", n)
                        }
                    }
                }),
                e.ui.registry.addSidebar("showcomments", {
                    tooltip: We.tc_items_showcomments,
                    icon: "comment",
                    onSetup: e=>(t.rememberSidebar(ee(e.element())),
                    w),
                    onShow: Co(e, o),
                    onHide: So(e, o)
                })
            }
            )(t, o, n)
        }
        )(t, c),
        t.on("PostRender", (()=>{
            (e=>{
                var t, o, n;
                o = ao(e) + "/tinycomments.css",
                (null != (n = _.from(null === (t = e.ui) || void 0 === t ? void 0 : t.styleSheetLoader).getOr(tinymce.DOM.styleSheetLoader)) ? n : tinymce.DOM.styleSheetLoader).load(o)
            }
            )(t)
        }
        )),
        t.on("init", (()=>{
            c.refreshSidebar(_.none(), 5)
        }
        )),
        t.on("PreInit", (()=>{
            i.lifecycleHooks.onPreInit(t)
        }
        )),
        t.on("setContent", (e=>{
            e.selection || c.refreshView(_.none())
        }
        )),
        t.on("SwitchMode", (()=>{
            c.setReadonly(t.readonly)
        }
        )),
        t.on("GetContent", (e=>{
            if (a(e.content)) {
                const o = !0 === e.source_view
                  , n = !0 === e.contextual
                  , r = !0 === e.selection
                  , s = o || n || r ? _.none() : i.lifecycleHooks.onGetContent(t, e.content);
                e.content = s.getOr(e.content)
            }
        }
        )),
        ((e,t)=>({
            getEventLog: nt(t),
            hasLoadedUi: e.get
        }))(n, s)
    }
    ;
    tinymce.PluginManager.requireLangPack("tinycomments", "ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_PT,pt_BR,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW"),
    tinymce.PluginManager.add("tinycomments", ((e,t)=>((e,t)=>!!e && -1 === ((e,t)=>{
        const o = p(e.major, t.major);
        if (0 !== o)
            return o;
        const n = p(e.minor, t.minor);
        if (0 !== n)
            return n;
        const r = p(e.patch, t.patch);
        return 0 !== r ? r : 0
    }
    )((e=>y((e=>[e.majorVersion, e.minorVersion].join(".").split(".").slice(0, 3).join("."))(e)))(e), y(t)))(tinymce, "6.1.0") ? (console.error("The tinycomments plugin requires at least version 6.1.0 of TinyMCE."),
    {}) : Ao(e, t)))
}();
